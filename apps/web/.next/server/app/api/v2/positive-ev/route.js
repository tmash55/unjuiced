/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/v2/positive-ev/route";
exports.ids = ["app/api/v2/positive-ev/route"];
exports.modules = {

/***/ "(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fv2%2Fpositive-ev%2Froute&page=%2Fapi%2Fv2%2Fpositive-ev%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fv2%2Fpositive-ev%2Froute.ts&appDir=%2FUsers%2Fdrewmaschoff%2Fdev%2Funjuiced%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fdrewmaschoff%2Fdev%2Funjuiced%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fv2%2Fpositive-ev%2Froute&page=%2Fapi%2Fv2%2Fpositive-ev%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fv2%2Fpositive-ev%2Froute.ts&appDir=%2FUsers%2Fdrewmaschoff%2Fdev%2Funjuiced%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fdrewmaschoff%2Fdev%2Funjuiced%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/../../node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/../../node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/../../node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/../../node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/../../node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/../../node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/../../node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/../../node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/../../node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/../../node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/../../node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/../../node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/../../node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/../../node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var _Users_drewmaschoff_dev_unjuiced_apps_web_app_api_v2_positive_ev_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./app/api/v2/positive-ev/route.ts */ \"(rsc)/./app/api/v2/positive-ev/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/v2/positive-ev/route\",\n        pathname: \"/api/v2/positive-ev\",\n        filename: \"route\",\n        bundlePath: \"app/api/v2/positive-ev/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"/Users/drewmaschoff/dev/unjuiced/apps/web/app/api/v2/positive-ev/route.ts\",\n    nextConfigOutput,\n    userland: _Users_drewmaschoff_dev_unjuiced_apps_web_app_api_v2_positive_ev_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/v2/positive-ev/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1hcHAtbG9hZGVyL2luZGV4LmpzP25hbWU9YXBwJTJGYXBpJTJGdjIlMkZwb3NpdGl2ZS1ldiUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGdjIlMkZwb3NpdGl2ZS1ldiUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRnYyJTJGcG9zaXRpdmUtZXYlMkZyb3V0ZS50cyZhcHBEaXI9JTJGVXNlcnMlMkZkcmV3bWFzY2hvZmYlMkZkZXYlMkZ1bmp1aWNlZCUyRmFwcHMlMkZ3ZWIlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGZHJld21hc2Nob2ZmJTJGZGV2JTJGdW5qdWljZWQlMkZhcHBzJTJGd2ViJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEJmlzR2xvYmFsTm90Rm91bmRFbmFibGVkPSEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0Y7QUFDdkM7QUFDcUI7QUFDZDtBQUNTO0FBQ087QUFDSztBQUNtQztBQUNqRDtBQUNPO0FBQ2Y7QUFDc0M7QUFDekI7QUFDTTtBQUNDO0FBQ2hCO0FBQ29DO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5R0FBbUI7QUFDM0M7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWEsT0FBb0MsSUFBSSxDQUFFO0FBQ3ZELHdCQUF3QixNQUF1QztBQUMvRDtBQUNBO0FB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O0FBQ2xFO0FBQ0Esa0JBQWtCLDZFQUFZO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZFQUE2RSxnRkFBYztBQUMzRixpQ0FBaUMsUUFBUSxFQUFFLFFBQVE7QUFDbkQsMEJBQTBCLHVFQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsTUFBTTtBQUNOLDZCQUE2Qiw2RkFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyRkFBbUI7QUFDckQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkVBQVk7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0IHsgZ2V0UmVxdWVzdE1ldGEgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0LW1ldGFcIjtcbmltcG9ydCB7IGdldFRyYWNlciwgU3BhbktpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvdHJhY2VyXCI7XG5pbXBvcnQgeyBub3JtYWxpemVBcHBQYXRoIH0gZnJvbSBcIm5leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hcHAtcGF0aHNcIjtcbmltcG9ydCB7IE5vZGVOZXh0UmVxdWVzdCwgTm9kZU5leHRSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Jhc2UtaHR0cC9ub2RlXCI7XG5pbXBvcnQgeyBOZXh0UmVxdWVzdEFkYXB0ZXIsIHNpZ25hbEZyb21Ob2RlUmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvbmV4dC1yZXF1ZXN0XCI7XG5pbXBvcnQgeyBCYXNlU2VydmVyU3BhbiB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS9jb25zdGFudHNcIjtcbmltcG9ydCB7IGdldFJldmFsaWRhdGVSZWFzb24gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9pbnN0cnVtZW50YXRpb24vdXRpbHNcIjtcbmltcG9ydCB7IHNlbmRSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3NlbmQtcmVzcG9uc2VcIjtcbmltcG9ydCB7IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycywgdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3dlYi91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0Q2FjaGVDb250cm9sSGVhZGVyIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL2NhY2hlLWNvbnRyb2xcIjtcbmltcG9ydCB7IElORklOSVRFX0NBQ0hFLCBORVhUX0NBQ0hFX1RBR1NfSEVBREVSIH0gZnJvbSBcIm5leHQvZGlzdC9saWIvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBOb0ZhbGxiYWNrRXJyb3IgfSBmcm9tIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvbm8tZmFsbGJhY2stZXJyb3IuZXh0ZXJuYWxcIjtcbmltcG9ydCB7IENhY2hlZFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3Jlc3BvbnNlLWNhY2hlXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL2RyZXdtYXNjaG9mZi9kZXYvdW5qdWljZWQvYXBwcy93ZWIvYXBwL2FwaS92Mi9wb3NpdGl2ZS1ldi9yb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvdjIvcG9zaXRpdmUtZXYvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS92Mi9wb3NpdGl2ZS1ldlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvdjIvcG9zaXRpdmUtZXYvcm91dGVcIlxuICAgIH0sXG4gICAgZGlzdERpcjogcHJvY2Vzcy5lbnYuX19ORVhUX1JFTEFUSVZFX0RJU1RfRElSIHx8ICcnLFxuICAgIHJlbGF0aXZlUHJvamVjdERpcjogcHJvY2Vzcy5lbnYuX19ORVhUX1JFTEFUSVZFX1BST0pFQ1RfRElSIHx8ICcnLFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL2RyZXdtYXNjaG9mZi9kZXYvdW5qdWljZWQvYXBwcy93ZWIvYXBwL2FwaS92Mi9wb3NpdGl2ZS1ldi9yb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHdvcmtBc3luY1N0b3JhZ2UsIHdvcmtVbml0QXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHdvcmtBc3luY1N0b3JhZ2UsXG4gICAgICAgIHdvcmtVbml0QXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBwYXRjaEZldGNoLCAgfTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzLCBjdHgpIHtcbiAgICB2YXIgX25leHRDb25maWdfZXhwZXJpbWVudGFsO1xuICAgIGxldCBzcmNQYWdlID0gXCIvYXBpL3YyL3Bvc2l0aXZlLWV2L3JvdXRlXCI7XG4gICAgLy8gdHVyYm9wYWNrIGRvZXNuJ3Qgbm9ybWFsaXplIGAvaW5kZXhgIGluIHRoZSBwYWdlIG5hbWVcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIHRvIHByb2Nlc3MgZHluYW1pYyByb3V0ZXMgcHJvcGVybHlcbiAgICAvLyBUT0RPOiBmaXggdHVyYm9wYWNrIHByb3ZpZGluZyBkaWZmZXJpbmcgdmFsdWUgZnJvbSB3ZWJwYWNrXG4gICAgaWYgKHByb2Nlc3MuZW52LlRVUkJPUEFDSykge1xuICAgICAgICBzcmNQYWdlID0gc3JjUGFnZS5yZXBsYWNlKC9cXC9pbmRleCQvLCAnJykgfHwgJy8nO1xuICAgIH0gZWxzZSBpZiAoc3JjUGFnZSA9PT0gJy9pbmRleCcpIHtcbiAgICAgICAgLy8gd2UgYWx3YXlzIG5vcm1hbGl6ZSAvaW5kZXggc3BlY2lmaWNhbGx5XG4gICAgICAgIHNyY1BhZ2UgPSAnLyc7XG4gICAgfVxuICAgIGNvbnN0IG11bHRpWm9uZURyYWZ0TW9kZSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9NVUxUSV9aT05FX0RSQUZUX01PREU7XG4gICAgY29uc3QgcHJlcGFyZVJlc3VsdCA9IGF3YWl0IHJvdXRlTW9kdWxlLnByZXBhcmUocmVxLCByZXMsIHtcbiAgICAgICAgc3JjUGFnZSxcbiAgICAgICAgbXVsdGlab25lRHJhZnRNb2RlXG4gICAgfSk7XG4gICAgaWYgKCFwcmVwYXJlUmVzdWx0KSB7XG4gICAgICAgIHJlcy5zdGF0dXNDb2RlID0gNDAwO1xuICAgICAgICByZXMuZW5kKCdCYWQgUmVxdWVzdCcpO1xuICAgICAgICBjdHgud2FpdFVudGlsID09IG51bGwgPyB2b2lkIDAgOiBjdHgud2FpdFVudGlsLmNhbGwoY3R4LCBQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IGJ1aWxkSWQsIHBhcmFtcywgbmV4dENvbmZpZywgaXNEcmFmdE1vZGUsIHByZXJlbmRlck1hbmlmZXN0LCByb3V0ZXJTZXJ2ZXJDb250ZXh0LCBpc09uRGVtYW5kUmV2YWxpZGF0ZSwgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQsIHJlc29sdmVkUGF0aG5hbWUgfSA9IHByZXBhcmVSZXN1bHQ7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNyY1BhZ2UgPSBub3JtYWxpemVBcHBQYXRoKHNyY1BhZ2UpO1xuICAgIGxldCBpc0lzciA9IEJvb2xlYW4ocHJlcmVuZGVyTWFuaWZlc3QuZHluYW1pY1JvdXRlc1tub3JtYWxpemVkU3JjUGFnZV0gfHwgcHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW3Jlc29sdmVkUGF0aG5hbWVdKTtcbiAgICBpZiAoaXNJc3IgJiYgIWlzRHJhZnRNb2RlKSB7XG4gICAgICAgIGNvbnN0IGlzUHJlcmVuZGVyZWQgPSBCb29sZWFuKHByZXJlbmRlck1hbmlmZXN0LnJvdXRlc1tyZXNvbHZlZFBhdGhuYW1lXSk7XG4gICAgICAgIGNvbnN0IHByZXJlbmRlckluZm8gPSBwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXTtcbiAgICAgICAgaWYgKHByZXJlbmRlckluZm8pIHtcbiAgICAgICAgICAgIGlmIChwcmVyZW5kZXJJbmZvLmZhbGxiYWNrID09PSBmYWxzZSAmJiAhaXNQcmVyZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb0ZhbGxiYWNrRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY2FjaGVLZXkgPSBudWxsO1xuICAgIGlmIChpc0lzciAmJiAhcm91dGVNb2R1bGUuaXNEZXYgJiYgIWlzRHJhZnRNb2RlKSB7XG4gICAgICAgIGNhY2hlS2V5ID0gcmVzb2x2ZWRQYXRobmFtZTtcbiAgICAgICAgLy8gZW5zdXJlIC9pbmRleCBhbmQgLyBpcyBub3JtYWxpemVkIHRvIG9uZSBrZXlcbiAgICAgICAgY2FjaGVLZXkgPSBjYWNoZUtleSA9PT0gJy9pbmRleCcgPyAnLycgOiBjYWNoZUtleTtcbiAgICB9XG4gICAgY29uc3Qgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2UgPSAvLyBJZiB3ZSdyZSBpbiBkZXZlbG9wbWVudCwgd2UgYWx3YXlzIHN1cHBvcnQgZHluYW1pYyBIVE1MXG4gICAgcm91dGVNb2R1bGUuaXNEZXYgPT09IHRydWUgfHwgLy8gSWYgdGhpcyBpcyBub3QgU1NHIG9yIGRvZXMgbm90IGhhdmUgc3RhdGljIHBhdGhzLCB0aGVuIGl0IHN1cHBvcnRzXG4gICAgLy8gZHluYW1pYyBIVE1MLlxuICAgICFpc0lzcjtcbiAgICAvLyBUaGlzIGlzIGEgcmV2YWxpZGF0aW9uIHJlcXVlc3QgaWYgdGhlIHJlcXVlc3QgaXMgZm9yIGEgc3RhdGljXG4gICAgLy8gcGFnZSBhbmQgaXQgaXMgbm90IGJlaW5nIHJlc3VtZWQgZnJvbSBhIHBvc3Rwb25lZCByZW5kZXIgYW5kXG4gICAgLy8gaXQgaXMgbm90IGEgZHluYW1pYyBSU0MgcmVxdWVzdCB0aGVuIGl0IGlzIGEgcmV2YWxpZGF0aW9uXG4gICAgLy8gcmVxdWVzdC5cbiAgICBjb25zdCBpc1JldmFsaWRhdGUgPSBpc0lzciAmJiAhc3VwcG9ydHNEeW5hbWljUmVzcG9uc2U7XG4gICAgY29uc3QgbWV0aG9kID0gcmVxLm1ldGhvZCB8fCAnR0VUJztcbiAgICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcbiAgICBjb25zdCBhY3RpdmVTcGFuID0gdHJhY2VyLmdldEFjdGl2ZVNjb3BlU3BhbigpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3QsXG4gICAgICAgIHJlbmRlck9wdHM6IHtcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbDoge1xuICAgICAgICAgICAgICAgIGNhY2hlQ29tcG9uZW50czogQm9vbGVhbihuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbC5jYWNoZUNvbXBvbmVudHMpLFxuICAgICAgICAgICAgICAgIGF1dGhJbnRlcnJ1cHRzOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmF1dGhJbnRlcnJ1cHRzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN1cHBvcnRzRHluYW1pY1Jlc3BvbnNlLFxuICAgICAgICAgICAgaW5jcmVtZW50YWxDYWNoZTogZ2V0UmVxdWVzdE1ldGEocmVxLCAnaW5jcmVtZW50YWxDYWNoZScpLFxuICAgICAgICAgICAgY2FjaGVMaWZlUHJvZmlsZXM6IChfbmV4dENvbmZpZ19leHBlcmltZW50YWwgPSBuZXh0Q29uZmlnLmV4cGVyaW1lbnRhbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9uZXh0Q29uZmlnX2V4cGVyaW1lbnRhbC5jYWNoZUxpZmUsXG4gICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICB3YWl0VW50aWw6IGN0eC53YWl0VW50aWwsXG4gICAgICAgICAgICBvbkNsb3NlOiAoY2IpPT57XG4gICAgICAgICAgICAgICAgcmVzLm9uKCdjbG9zZScsIGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkFmdGVyVGFza0Vycm9yOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvbkluc3RydW1lbnRhdGlvblJlcXVlc3RFcnJvcjogKGVycm9yLCBfcmVxdWVzdCwgZXJyb3JDb250ZXh0KT0+cm91dGVNb2R1bGUub25SZXF1ZXN0RXJyb3IocmVxLCBlcnJvciwgZXJyb3JDb250ZXh0LCByb3V0ZXJTZXJ2ZXJDb250ZXh0KVxuICAgICAgICB9LFxuICAgICAgICBzaGFyZWRDb250ZXh0OiB7XG4gICAgICAgICAgICBidWlsZElkXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5vZGVOZXh0UmVxID0gbmV3IE5vZGVOZXh0UmVxdWVzdChyZXEpO1xuICAgIGNvbnN0IG5vZGVOZXh0UmVzID0gbmV3IE5vZGVOZXh0UmVzcG9uc2UocmVzKTtcbiAgICBjb25zdCBuZXh0UmVxID0gTmV4dFJlcXVlc3RBZGFwdGVyLmZyb21Ob2RlTmV4dFJlcXVlc3Qobm9kZU5leHRSZXEsIHNpZ25hbEZyb21Ob2RlUmVzcG9uc2UocmVzKSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaW52b2tlUm91dGVNb2R1bGUgPSBhc3luYyAoc3Bhbik9PntcbiAgICAgICAgICAgIHJldHVybiByb3V0ZU1vZHVsZS5oYW5kbGUobmV4dFJlcSwgY29udGV4dCkuZmluYWxseSgoKT0+e1xuICAgICAgICAgICAgICAgIGlmICghc3BhbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICdodHRwLnN0YXR1c19jb2RlJzogcmVzLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgICduZXh0LnJzYyc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdFNwYW5BdHRyaWJ1dGVzID0gdHJhY2VyLmdldFJvb3RTcGFuQXR0cmlidXRlcygpO1xuICAgICAgICAgICAgICAgIC8vIFdlIHdlcmUgdW5hYmxlIHRvIGdldCBhdHRyaWJ1dGVzLCBwcm9iYWJseSBPVEVMIGlzIG5vdCBlbmFibGVkXG4gICAgICAgICAgICAgICAgaWYgKCFyb290U3BhbkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5zcGFuX3R5cGUnKSAhPT0gQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFVuZXhwZWN0ZWQgcm9vdCBzcGFuIHR5cGUgJyR7cm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5zcGFuX3R5cGUnKX0nLiBQbGVhc2UgcmVwb3J0IHRoaXMgTmV4dC5qcyBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanNgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZSA9IHJvb3RTcGFuQXR0cmlidXRlcy5nZXQoJ25leHQucm91dGUnKTtcbiAgICAgICAgICAgICAgICBpZiAocm91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGAke21ldGhvZH0gJHtyb3V0ZX1gO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ25leHQucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdodHRwLnJvdXRlJzogcm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5zcGFuX25hbWUnOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi51cGRhdGVOYW1lKGAke21ldGhvZH0gJHtyZXEudXJsfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVSZXNwb25zZSA9IGFzeW5jIChjdXJyZW50U3Bhbik9PntcbiAgICAgICAgICAgIHZhciBfY2FjaGVFbnRyeV92YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlR2VuZXJhdG9yID0gYXN5bmMgKHsgcHJldmlvdXNDYWNoZUVudHJ5IH0pPT57XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpICYmIGlzT25EZW1hbmRSZXZhbGlkYXRlICYmIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkICYmICFwcmV2aW91c0NhY2hlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID0gNDA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24tZGVtYW5kIHJldmFsaWRhdGUgYWx3YXlzIHNldHMgdGhpcyBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ3gtbmV4dGpzLWNhY2hlJywgJ1JFVkFMSURBVEVEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuZW5kKCdUaGlzIHBhZ2UgY291bGQgbm90IGJlIGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGludm9rZVJvdXRlTW9kdWxlKGN1cnJlbnRTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmZldGNoTWV0cmljcyA9IGNvbnRleHQucmVuZGVyT3B0cy5mZXRjaE1ldHJpY3M7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwZW5kaW5nV2FpdFVudGlsID0gY29udGV4dC5yZW5kZXJPcHRzLnBlbmRpbmdXYWl0VW50aWw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdXNpbmcgcHJvdmlkZWQgd2FpdFVudGlsIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIG5vdCB3ZSBmYWxsYmFjayB0byBzZW5kUmVzcG9uc2UncyBoYW5kbGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVuZGluZ1dhaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN0eC53YWl0VW50aWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgud2FpdFVudGlsKHBlbmRpbmdXYWl0VW50aWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdXYWl0VW50aWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVUYWdzID0gY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFRhZ3M7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGlzIGZvciBhIHN0YXRpYyByZXNwb25zZSwgd2UgY2FuIGNhY2hlIGl0IHNvIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXQncyBub3QgZWRnZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSXNyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgaGVhZGVycyBmcm9tIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0b05vZGVPdXRnb2luZ0h0dHBIZWFkZXJzKHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlVGFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbTkVYVF9DQUNIRV9UQUdTX0hFQURFUl0gPSBjYWNoZVRhZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddICYmIGJsb2IudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gYmxvYi50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV2YWxpZGF0ZSA9IHR5cGVvZiBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGUgPj0gSU5GSU5JVEVfQ0FDSEUgPyBmYWxzZSA6IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwaXJlID0gdHlwZW9mIGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRFeHBpcmUgPT09ICd1bmRlZmluZWQnIHx8IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRFeHBpcmUgPj0gSU5GSU5JVEVfQ0FDSEUgPyB1bmRlZmluZWQgOiBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkRXhwaXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBjYWNoZSBlbnRyeSBmb3IgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBDYWNoZWRSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogQnVmZmVyLmZyb20oYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVDb250cm9sOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgcmVzcG9uc2Ugd2l0aG91dCBjYWNoaW5nIGlmIG5vdCBJU1JcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbmRSZXNwb25zZShub2RlTmV4dFJlcSwgbm9kZU5leHRSZXMsIHJlc3BvbnNlLCBjb250ZXh0LnJlbmRlck9wdHMucGVuZGluZ1dhaXRVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGEgYmFja2dyb3VuZCByZXZhbGlkYXRlIHdlIG5lZWQgdG8gcmVwb3J0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0IGVycm9yIGhlcmUgYXMgaXQgd29uJ3QgYmUgYnViYmxlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNDYWNoZUVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2aW91c0NhY2hlRW50cnkuaXNTdGFsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcm91dGVNb2R1bGUub25SZXF1ZXN0RXJyb3IocmVxLCBlcnIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXJLaW5kOiAnQXBwIFJvdXRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVQYXRoOiBzcmNQYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlVHlwZTogJ3JvdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZhbGlkYXRlUmVhc29uOiBnZXRSZXZhbGlkYXRlUmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc09uRGVtYW5kUmV2YWxpZGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByb3V0ZXJTZXJ2ZXJDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRW50cnkgPSBhd2FpdCByb3V0ZU1vZHVsZS5oYW5kbGVSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgcm91dGVLaW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICAgICAgICAgIGlzRmFsbGJhY2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByZXJlbmRlck1hbmlmZXN0LFxuICAgICAgICAgICAgICAgIGlzUm91dGVQUFJFbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc09uRGVtYW5kUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICByZXZhbGlkYXRlT25seUdlbmVyYXRlZCxcbiAgICAgICAgICAgICAgICByZXNwb25zZUdlbmVyYXRvcixcbiAgICAgICAgICAgICAgICB3YWl0VW50aWw6IGN0eC53YWl0VW50aWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY3JlYXRlIGEgY2FjaGVFbnRyeSBmb3IgSVNSXG4gICAgICAgICAgICBpZiAoIWlzSXNyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGNhY2hlRW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IChfY2FjaGVFbnRyeV92YWx1ZSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZS5raW5kKSAhPT0gQ2FjaGVkUm91dGVLaW5kLkFQUF9ST1VURSkge1xuICAgICAgICAgICAgICAgIHZhciBfY2FjaGVFbnRyeV92YWx1ZTE7XG4gICAgICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ldyBFcnJvcihgSW52YXJpYW50OiBhcHAtcm91dGUgcmVjZWl2ZWQgaW52YWxpZCBjYWNoZSBlbnRyeSAke2NhY2hlRW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IChfY2FjaGVFbnRyeV92YWx1ZTEgPSBjYWNoZUVudHJ5LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogX2NhY2hlRW50cnlfdmFsdWUxLmtpbmR9YCksIFwiX19ORVhUX0VSUk9SX0NPREVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJFNzAxXCIsXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ3gtbmV4dGpzLWNhY2hlJywgaXNPbkRlbWFuZFJldmFsaWRhdGUgPyAnUkVWQUxJREFURUQnIDogY2FjaGVFbnRyeS5pc01pc3MgPyAnTUlTUycgOiBjYWNoZUVudHJ5LmlzU3RhbGUgPyAnU1RBTEUnIDogJ0hJVCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRHJhZnQgbW9kZSBzaG91bGQgbmV2ZXIgYmUgY2FjaGVkXG4gICAgICAgICAgICBpZiAoaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKCdDYWNoZS1Db250cm9sJywgJ3ByaXZhdGUsIG5vLWNhY2hlLCBuby1zdG9yZSwgbWF4LWFnZT0wLCBtdXN0LXJldmFsaWRhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBmcm9tTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMoY2FjaGVFbnRyeS52YWx1ZS5oZWFkZXJzKTtcbiAgICAgICAgICAgIGlmICghKGdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiYgaXNJc3IpKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5kZWxldGUoTkVYVF9DQUNIRV9UQUdTX0hFQURFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBjYWNoZSBjb250cm9sIGlzIGFscmVhZHkgc2V0IG9uIHRoZSByZXNwb25zZSB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gb3ZlcnJpZGUgaXQgdG8gYWxsb3cgdXNlcnMgdG8gY3VzdG9taXplIGl0IHZpYSBuZXh0LmNvbmZpZ1xuICAgICAgICAgICAgaWYgKGNhY2hlRW50cnkuY2FjaGVDb250cm9sICYmICFyZXMuZ2V0SGVhZGVyKCdDYWNoZS1Db250cm9sJykgJiYgIWhlYWRlcnMuZ2V0KCdDYWNoZS1Db250cm9sJykpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnNldCgnQ2FjaGUtQ29udHJvbCcsIGdldENhY2hlQ29udHJvbEhlYWRlcihjYWNoZUVudHJ5LmNhY2hlQ29udHJvbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgc2VuZFJlc3BvbnNlKG5vZGVOZXh0UmVxLCBub2RlTmV4dFJlcywgbmV3IFJlc3BvbnNlKGNhY2hlRW50cnkudmFsdWUuYm9keSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBjYWNoZUVudHJ5LnZhbHVlLnN0YXR1cyB8fCAyMDBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiBhY3RpdmVTcGFuIGNvZGUgcGF0aCBpcyBmb3Igd2hlbiB3cmFwcGVkIGJ5XG4gICAgICAgIC8vIG5leHQtc2VydmVyIGNhbiBiZSByZW1vdmVkIHdoZW4gdGhpcyBpcyBubyBsb25nZXIgdXNlZFxuICAgICAgICBpZiAoYWN0aXZlU3Bhbikge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlUmVzcG9uc2UoYWN0aXZlU3Bhbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0cmFjZXIud2l0aFByb3BhZ2F0ZWRDb250ZXh0KHJlcS5oZWFkZXJzLCAoKT0+dHJhY2VyLnRyYWNlKEJhc2VTZXJ2ZXJTcGFuLmhhbmRsZVJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbk5hbWU6IGAke21ldGhvZH0gJHtyZXEudXJsfWAsXG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IFNwYW5LaW5kLlNFUlZFUixcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAubWV0aG9kJzogbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAudGFyZ2V0JzogcmVxLnVybFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlUmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBOb0ZhbGxiYWNrRXJyb3IpKSB7XG4gICAgICAgICAgICBhd2FpdCByb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVyciwge1xuICAgICAgICAgICAgICAgIHJvdXRlcktpbmQ6ICdBcHAgUm91dGVyJyxcbiAgICAgICAgICAgICAgICByb3V0ZVBhdGg6IG5vcm1hbGl6ZWRTcmNQYWdlLFxuICAgICAgICAgICAgICAgIHJvdXRlVHlwZTogJ3JvdXRlJyxcbiAgICAgICAgICAgICAgICByZXZhbGlkYXRlUmVhc29uOiBnZXRSZXZhbGlkYXRlUmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgaXNSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICBpc09uRGVtYW5kUmV2YWxpZGF0ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXRocm93IHNvIHRoYXQgd2UgY2FuIGhhbmRsZSBzZXJ2aW5nIGVycm9yIHBhZ2VcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBkdXJpbmcgc3RhdGljIGdlbmVyYXRpb24sIHRocm93IHRoZSBlcnJvciBhZ2Fpbi5cbiAgICAgICAgaWYgKGlzSXNyKSB0aHJvdyBlcnI7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2VuZCBhIDUwMCByZXNwb25zZS5cbiAgICAgICAgYXdhaXQgc2VuZFJlc3BvbnNlKG5vZGVOZXh0UmVxLCBub2RlTmV4dFJlcywgbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgICAgIHN0YXR1czogNTAwXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fv2%2Fpositive-ev%2Froute&page=%2Fapi%2Fv2%2Fpositive-ev%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fv2%2Fpositive-ev%2Froute.ts&appDir=%2FUsers%2Fdrewmaschoff%2Fdev%2Funjuiced%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fdrewmaschoff%2Fdev%2Funjuiced%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \**********************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./app/api/v2/positive-ev/route.ts":
/*!*****************************************!*\
  !*** ./app/api/v2/positive-ev/route.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   OPTIONS: () => (/* binding */ OPTIONS),\n/* harmony export */   maxDuration: () => (/* binding */ maxDuration),\n/* harmony export */   runtime: () => (/* binding */ runtime)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/../../node_modules/next/dist/api/server.js\");\n/* harmony import */ var _upstash_redis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @upstash/redis */ \"(rsc)/../../node_modules/@upstash/redis/nodejs.mjs\");\n/* harmony import */ var _lib_odds_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/odds/types */ \"(rsc)/./lib/odds/types.ts\");\n/* harmony import */ var _lib_ev__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/ev */ \"(rsc)/./lib/ev/index.ts\");\n/* harmony import */ var _lib_ev_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/ev/constants */ \"(rsc)/./lib/ev/constants.ts\");\n/* harmony import */ var _libs_supabase_server__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/libs/supabase/server */ \"(rsc)/./libs/supabase/server.ts\");\n/* harmony import */ var _lib_plans_server__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/plans-server */ \"(rsc)/./lib/plans-server.ts\");\n/* harmony import */ var _lib_plans__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/lib/plans */ \"(rsc)/./lib/plans.ts\");\n// Use Node.js runtime for longer timeouts and better performance\nconst runtime = \"nodejs\";\nconst maxDuration = 60; // Allow up to 60 seconds\n\n\n\n\n\n\n\n\nconst redis = new _upstash_redis__WEBPACK_IMPORTED_MODULE_1__.Redis({\n    url: process.env.UPSTASH_REDIS_REST_URL,\n    token: process.env.UPSTASH_REDIS_REST_TOKEN\n});\n// Configuration - optimized for speed\nconst SCAN_COUNT = 2000; // Larger scan batches\nconst MGET_CHUNK_SIZE = 500; // Reduced to prevent connection issues\n// =============================================================================\n// Redis Response Cache (shared across all instances)\n// =============================================================================\nconst RESPONSE_CACHE_PREFIX = \"ev:response:\";\nconst RESPONSE_CACHE_TTL_PRESET = 15; // 15 seconds for standard presets\nconst RESPONSE_CACHE_TTL_CUSTOM = 30; // 30 seconds for custom models (configs rarely change)\nfunction resolveAllowedOrigin(origin) {\n    if (!origin) return null;\n    const isLocalhost = /^http:\\/\\/localhost:\\d+$/.test(origin) || /^http:\\/\\/127\\.0\\.0\\.1:\\d+$/.test(origin);\n    if (isLocalhost) return origin;\n    if (origin === \"https://app.unjuiced.bet\") return origin;\n    if (origin === \"https://www.unjuiced.bet\") return origin;\n    if (origin === \"https://unjuiced.bet\") return origin;\n    return null;\n}\nfunction getCorsHeaders(origin) {\n    const allowedOrigin = resolveAllowedOrigin(origin);\n    return {\n        \"Access-Control-Allow-Origin\": allowedOrigin ?? \"null\",\n        \"Access-Control-Allow-Methods\": \"GET, OPTIONS\",\n        \"Access-Control-Allow-Headers\": \"Authorization, Content-Type, Cache-Control, Pragma\",\n        \"Access-Control-Allow-Credentials\": \"true\",\n        \"Access-Control-Max-Age\": \"86400\",\n        Vary: \"Origin\"\n    };\n}\nfunction jsonWithHeaders(body, status, origin, extraHeaders) {\n    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(body, {\n        status,\n        headers: {\n            ...getCorsHeaders(origin),\n            ...extraHeaders ?? {}\n        }\n    });\n}\n/**\n * Build cache key from request parameters\n */ function buildResponseCacheKey(params) {\n    const keys = [\n        'sports',\n        'sharpPreset',\n        'devigMethods',\n        'minEV',\n        'maxEV',\n        'books',\n        'limit',\n        'mode',\n        'minBooksPerSide',\n        'customSharpBooks',\n        'customBookWeights'\n    ];\n    return keys.map((k)=>`${k}:${params.get(k) || ''}`).join('|');\n}\n/**\n * Check if request is using a custom model (has customSharpBooks)\n */ function isCustomModelRequest(params) {\n    const customBooks = params.get(\"customSharpBooks\");\n    return !!customBooks && customBooks.length > 0;\n}\n/**\n * Get hash of cache key for shorter Redis keys\n */ function hashCacheKey(key) {\n    // Simple hash function for shorter keys\n    let hash = 5381;\n    for(let i = 0; i < key.length; i++){\n        hash = (hash << 5) + hash ^ key.charCodeAt(i);\n    }\n    return (hash >>> 0).toString(16).padStart(8, '0');\n}\n/**\n * Check Redis response cache\n */ async function getFromResponseCache(key) {\n    try {\n        const redisKey = `${RESPONSE_CACHE_PREFIX}${hashCacheKey(key)}`;\n        const cached = await redis.get(redisKey);\n        return cached;\n    } catch (error) {\n        console.error(\"[positive-ev] Redis cache read error:\", error);\n        return null;\n    }\n}\n/**\n * Store in Redis response cache with tiered TTL\n */ async function setInResponseCache(key, data, isCustom) {\n    try {\n        const ttl = isCustom ? RESPONSE_CACHE_TTL_CUSTOM : RESPONSE_CACHE_TTL_PRESET;\n        const redisKey = `${RESPONSE_CACHE_PREFIX}${hashCacheKey(key)}`;\n        await redis.set(redisKey, data, {\n            ex: ttl\n        });\n    } catch (error) {\n        console.error(\"[positive-ev] Redis cache write error:\", error);\n    }\n}\n// Supported sports\nconst VALID_SPORTS = new Set([\n    \"nba\",\n    \"nfl\",\n    \"nhl\",\n    \"ncaab\",\n    \"ncaaf\",\n    \"mlb\",\n    \"wnba\",\n    \"soccer_epl\"\n]);\n// Books to exclude (regional variants)\nconst EXCLUDED_BOOKS = new Set([\n    \"hard-rock-indiana\",\n    \"hardrockindiana\"\n]);\n/**\n * Get the book IDs that should be excluded based on the current sharp preset\n * Only exclude books that are actually being used as the sharp reference\n */ function getExcludedBooksForPreset(preset) {\n    const excluded = new Set();\n    switch(preset){\n        case \"pinnacle\":\n            excluded.add(\"pinnacle\");\n            break;\n        case \"pinnacle_circa\":\n            excluded.add(\"pinnacle\");\n            excluded.add(\"circa\");\n            break;\n        case \"hardrock_thescore\":\n            excluded.add(\"hardrock\");\n            excluded.add(\"hard-rock\");\n            excluded.add(\"thescore\");\n            break;\n        case \"market_average\":\n            break;\n        case \"custom\":\n            break;\n    }\n    return excluded;\n}\n/**\n * Normalize book IDs to match canonical sportsbook IDs\n */ function normalizeBookId(id) {\n    const lower = id.toLowerCase();\n    switch(lower){\n        case \"hardrock\":\n            return \"hard-rock\";\n        case \"hardrockindiana\":\n        case \"hardrock-indiana\":\n            return \"hard-rock-indiana\";\n        case \"ballybet\":\n            return \"bally-bet\";\n        case \"sportsinteraction\":\n            return \"sports-interaction\";\n        case \"fanduel-yourway\":\n        case \"fanduel_yourway\":\n            return \"fanduelyourway\";\n        case \"betmgm-michigan\":\n        case \"betmgm_michigan\":\n            return \"betmgm\";\n        default:\n            return lower;\n    }\n}\n/**\n * Format position strings\n */ function formatPosition(position) {\n    if (!position) return null;\n    const multiPosPatterns = [\n        \"GF\",\n        \"FG\",\n        \"FC\",\n        \"CF\",\n        \"SF\",\n        \"FS\",\n        \"PG\",\n        \"SG\",\n        \"PF\"\n    ];\n    const upper = position.toUpperCase();\n    if (position.length === 2 && multiPosPatterns.includes(upper)) {\n        return `${position[0]}/${position[1]}`;\n    }\n    return position;\n}\n/**\n * Format American odds as string\n */ function formatAmericanOdds(price) {\n    return price > 0 ? `+${price}` : String(price);\n}\n/**\n * GET /api/v2/positive-ev\n * \n * True +EV tool using proper de-vigging methods\n * \n * Query params:\n *   sports      - Comma-separated sports (default: \"nba\")\n *   markets     - Comma-separated markets (optional)\n *   sharpPreset - Sharp reference preset (default: \"pinnacle\")\n *   devigMethods - Comma-separated methods (default: \"power,multiplicative\")\n *   minEV       - Minimum EV% threshold (default: 0)\n *   maxEV       - Maximum EV% to show (default: 20)\n *   books       - Filter to specific sportsbooks (optional)\n *   limit       - Max results (default: 100)\n *   mode        - Filter mode: \"pregame\" (default), \"live\", or \"all\"\n */ async function GET(req) {\n    const startTime = Date.now();\n    const origin = req.headers.get(\"origin\");\n    try {\n        const params = new URL(req.url).searchParams;\n        // Parse mode first (needed for cache check)\n        const modeParam = params.get(\"mode\")?.toLowerCase();\n        const mode = modeParam === \"live\" ? \"live\" : modeParam === \"all\" ? \"all\" : \"pregame\";\n        // Cache bypass: ?fresh=true skips cache (use after SSE updates)\n        const bypassCache = params.get(\"fresh\") === \"true\";\n        // Check Redis response cache first (fast path)\n        const cacheKey = buildResponseCacheKey(params);\n        if (!bypassCache) {\n            const cachedResponse = await getFromResponseCache(cacheKey);\n            if (cachedResponse) {\n                console.log(`[positive-ev] Cache HIT (Redis, ${Date.now() - startTime}ms)`);\n                return jsonWithHeaders(cachedResponse, 200, origin, {\n                    \"Cache-Control\": \"private, max-age=15\",\n                    \"X-Cache\": \"HIT\",\n                    \"X-Cache-Source\": \"redis\",\n                    \"X-Mode\": mode\n                });\n            }\n        } else {\n            console.log(`[positive-ev] Cache BYPASS requested (SSE triggered refresh)`);\n        }\n        // Parse parameters\n        const sportsParam = params.get(\"sports\")?.toLowerCase().split(\",\").filter(Boolean) || [\n            \"nba\"\n        ];\n        const sports = sportsParam.filter((s)=>VALID_SPORTS.has(s));\n        if (sports.length === 0) {\n            return jsonWithHeaders({\n                error: \"No valid sports provided\"\n            }, 400, origin);\n        }\n        const markets = params.get(\"markets\")?.toLowerCase().split(\",\").filter(Boolean) || null;\n        const sharpPreset = params.get(\"sharpPreset\") || \"pinnacle\";\n        const devigMethodsParam = params.get(\"devigMethods\")?.toLowerCase().split(\",\").filter(Boolean) || null;\n        const devigMethods = devigMethodsParam ? devigMethodsParam.filter((m)=>[\n                \"power\",\n                \"multiplicative\",\n                \"additive\",\n                \"probit\"\n            ].includes(m)) : _lib_ev_constants__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_DEVIG_METHODS;\n        const minEV = parseFloat(params.get(\"minEV\") || \"0\");\n        const maxEV = parseFloat(params.get(\"maxEV\") || String(_lib_ev_constants__WEBPACK_IMPORTED_MODULE_4__.EV_THRESHOLDS.maximum));\n        const booksFilter = params.get(\"books\")?.toLowerCase().split(\",\").filter(Boolean) || null;\n        const limit = Math.min(parseInt(params.get(\"limit\") || \"100\"), 500);\n        const minBooksPerSide = parseInt(params.get(\"minBooksPerSide\") || \"2\");\n        // Custom sharp books (for user's custom models) - Elite only\n        const customSharpBooksParam = params.get(\"customSharpBooks\")?.toLowerCase().split(\",\").filter(Boolean) || null;\n        const customBookWeightsParam = params.get(\"customBookWeights\");\n        let customSharpConfig = null;\n        if (customSharpBooksParam && customSharpBooksParam.length > 0) {\n            const supabase = await (0,_libs_supabase_server__WEBPACK_IMPORTED_MODULE_5__.createClient)();\n            const { data: { user } } = await supabase.auth.getUser();\n            const userPlan = await (0,_lib_plans_server__WEBPACK_IMPORTED_MODULE_6__.getUserPlan)(user);\n            if (!(0,_lib_plans__WEBPACK_IMPORTED_MODULE_7__.hasEliteAccess)(userPlan)) {\n                return jsonWithHeaders({\n                    error: \"Custom models require Elite plan\",\n                    code: \"elite_required\"\n                }, 403, origin);\n            }\n            let weights = null;\n            if (customBookWeightsParam) {\n                try {\n                    weights = JSON.parse(customBookWeightsParam);\n                } catch (e) {\n                    console.warn(\"[positive-ev] Failed to parse customBookWeights, using equal weights\");\n                }\n            }\n            customSharpConfig = {\n                books: customSharpBooksParam,\n                weights\n            };\n            console.log(`[positive-ev] Using custom sharp config: ${customSharpBooksParam.join(\", \")}`, weights ? `with weights` : `equal weights`);\n        }\n        // Note: mode is already parsed above for cache check\n        // Validate sharp preset (only if not using custom config)\n        if (!customSharpConfig && !_lib_ev_constants__WEBPACK_IMPORTED_MODULE_4__.SHARP_PRESETS[sharpPreset]) {\n            return jsonWithHeaders({\n                error: `Invalid sharpPreset: ${sharpPreset}`\n            }, 400, origin);\n        }\n        // Fetch opportunities for all sports IN PARALLEL (much faster!)\n        console.log(`[positive-ev] Fetching ${sports.length} sports in parallel...`);\n        const sportPromises = sports.map(async (sport)=>{\n            try {\n                const startTime = Date.now();\n                const sportOpps = await fetchPositiveEVOpportunities(sport, markets, sharpPreset, devigMethods, minEV, maxEV, booksFilter, mode, minBooksPerSide, customSharpConfig);\n                console.log(`[positive-ev]  ${sport}: ${sportOpps.length} opps in ${Date.now() - startTime}ms`);\n                return sportOpps;\n            } catch (error) {\n                console.error(`[positive-ev]  ${sport} failed:`, error instanceof Error ? error.message : error);\n                return []; // Return empty array on error, don't fail entire request\n            }\n        });\n        const sportResults = await Promise.all(sportPromises);\n        const allOpportunities = sportResults.flat();\n        // Sort by worst-case EV (conservative) descending\n        allOpportunities.sort((a, b)=>b.evCalculations.evWorst - a.evCalculations.evWorst);\n        // Apply limit\n        const opportunities = allOpportunities.slice(0, limit);\n        const response = {\n            opportunities,\n            meta: {\n                totalFound: allOpportunities.length,\n                returned: opportunities.length,\n                sharpPreset: customSharpConfig ? \"custom\" : sharpPreset,\n                customSharpConfig: customSharpConfig || undefined,\n                devigMethods,\n                minEV,\n                minBooksPerSide,\n                mode,\n                timestamp: new Date().toISOString()\n            }\n        };\n        // Log response size for debugging\n        const responseSize = JSON.stringify(response).length;\n        console.log(`[positive-ev] Response size: ${(responseSize / 1024).toFixed(2)} KB`);\n        if (responseSize > 500000) {\n            console.warn(`[positive-ev]   Large response (${(responseSize / 1024 / 1024).toFixed(2)} MB)`);\n        }\n        // Store in Redis response cache for quick subsequent requests\n        // Fire and forget - don't await to avoid slowing down response\n        const isCustom = isCustomModelRequest(params);\n        setInResponseCache(cacheKey, response, isCustom).catch((err)=>{\n            console.error(\"[positive-ev] Failed to cache response:\", err);\n        });\n        const ttlUsed = isCustom ? RESPONSE_CACHE_TTL_CUSTOM : RESPONSE_CACHE_TTL_PRESET;\n        console.log(`[positive-ev] Cache MISS - storing in Redis (TTL: ${ttlUsed}s, total time: ${Date.now() - startTime}ms)`);\n        return jsonWithHeaders(response, 200, origin, {\n            \"Cache-Control\": \"private, max-age=15\",\n            \"Content-Type\": \"application/json\",\n            \"X-Cache\": \"MISS\",\n            \"X-Cache-Source\": \"redis\",\n            \"X-Mode\": mode\n        });\n    } catch (error) {\n        console.error(\"[/api/v2/positive-ev] Error:\", error);\n        return jsonWithHeaders({\n            error: \"Internal server error\",\n            timing_ms: Date.now() - startTime\n        }, 500, origin);\n    }\n}\nasync function OPTIONS(request) {\n    return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(null, {\n        status: 204,\n        headers: getCorsHeaders(request.headers.get(\"origin\"))\n    });\n}\n/**\n * Fetch +EV opportunities for a single sport\n */ async function fetchPositiveEVOpportunities(sport, markets, sharpPreset, devigMethods, minEV, maxEV, booksFilter, mode, minBooksPerSide, customSharpConfig = null) {\n    const opportunities = [];\n    const pairMap = new Map();\n    try {\n        // Step 1: Get active events\n        const eventIds = await getActiveEventIds(sport);\n        if (eventIds.length === 0) return [];\n        // Step 2: Get odds keys\n        const allOddsKeys = await getOddsKeysForEvents(sport, eventIds);\n        if (allOddsKeys.length === 0) return [];\n        // Filter keys by event and market\n        const eventIdSet = new Set(eventIds);\n        const filteredKeys = [];\n        // Helper to check if market is allowed (supports composite keys like \"nba:player_points\")\n        const isMarketAllowed = (market)=>{\n            if (!markets) return true; // No filter = all allowed\n            // Check composite key (sport-specific)\n            if (markets.includes(`${sport}:${market}`)) return true;\n            // Check plain key (global / backwards compat)\n            if (markets.includes(market)) return true;\n            return false;\n        };\n        for (const key of allOddsKeys){\n            const parts = key.split(\":\");\n            const eventId = parts[2];\n            const market = parts[3];\n            const book = parts[4];\n            if (!eventId || !market || !book) continue;\n            if (!eventIdSet.has(eventId)) continue;\n            if (!isMarketAllowed(market)) continue;\n            filteredKeys.push(key);\n        }\n        if (filteredKeys.length === 0) return [];\n        // Step 3: Batch fetch all odds data\n        const chunks = [];\n        for(let i = 0; i < filteredKeys.length; i += MGET_CHUNK_SIZE){\n            chunks.push(filteredKeys.slice(i, i + MGET_CHUNK_SIZE));\n        }\n        const chunkResults = await Promise.all(chunks.map((chunk)=>redis.mget(...chunk)));\n        const allOddsData = chunkResults.flat();\n        // Build key -> data map\n        const oddsDataMap = new Map();\n        filteredKeys.forEach((key, i)=>{\n            const data = allOddsData[i];\n            if (data) {\n                oddsDataMap.set(key, typeof data === \"string\" ? JSON.parse(data) : data);\n            }\n        });\n        // Step 4: Fetch event details\n        const eventKeys = eventIds.map((id)=>`events:${sport}:${id}`);\n        const eventsRaw = await redis.mget(...eventKeys);\n        // Build event map with robust filtering\n        const now = new Date();\n        const SIX_HOURS_MS = 6 * 60 * 60 * 1000; // 6 hours in milliseconds\n        const eventMap = new Map();\n        const pregameEventIds = new Set();\n        const liveEventIds = new Set();\n        const excludedEventIds = new Set(); // Track events to exclude completely\n        eventIds.forEach((id, i)=>{\n            const event = eventsRaw[i];\n            if (!event) {\n                // No event data - exclude\n                excludedEventIds.add(id);\n                return;\n            }\n            const startTime = event.commence_time || event.start_time || \"\";\n            const isLiveFlag = event.is_live === true;\n            const homeTeam = event.home_team || \"\";\n            const awayTeam = event.away_team || \"\";\n            // Skip events without valid team data\n            if (!homeTeam || !awayTeam) {\n                excludedEventIds.add(id);\n                return;\n            }\n            // Robust time validation\n            if (!startTime) {\n                // No start time - exclude (likely stale data / TBD issue)\n                excludedEventIds.add(id);\n                return;\n            }\n            const gameStart = new Date(startTime);\n            if (isNaN(gameStart.getTime())) {\n                // Invalid date - exclude\n                excludedEventIds.add(id);\n                return;\n            }\n            // Check if game started more than 6 hours ago (definitely finished)\n            const msSinceStart = now.getTime() - gameStart.getTime();\n            if (msSinceStart > SIX_HOURS_MS) {\n                // Game is likely over - exclude\n                excludedEventIds.add(id);\n                return;\n            }\n            // Determine if live or pregame\n            const isLive = isLiveFlag || gameStart <= now;\n            if (isLive) {\n                liveEventIds.add(id);\n            } else {\n                pregameEventIds.add(id);\n            }\n            eventMap.set(id, {\n                home_team: homeTeam,\n                away_team: awayTeam,\n                start_time: startTime,\n                isLive\n            });\n        });\n        // Step 5: Build selection pairs\n        const keysByEventMarket = new Map();\n        for (const key of filteredKeys){\n            const parts = key.split(\":\");\n            const eventId = parts[2];\n            const market = parts[3];\n            const groupKey = `${eventId}:${market}`;\n            if (!keysByEventMarket.has(groupKey)) {\n                keysByEventMarket.set(groupKey, []);\n            }\n            keysByEventMarket.get(groupKey).push(key);\n        }\n        for (const [groupKey, marketKeys] of keysByEventMarket){\n            const [eventId, market] = groupKey.split(\":\");\n            // Skip excluded events (no data, invalid time, or finished games)\n            if (excludedEventIds.has(eventId)) continue;\n            // Apply mode filter\n            if (mode === \"pregame\" && liveEventIds.has(eventId)) continue; // Skip live in pregame mode\n            if (mode === \"live\" && pregameEventIds.has(eventId)) continue; // Skip pregame in live mode\n            // mode === \"all\" shows both\n            const eventData = eventMap.get(eventId);\n            const event = eventData ? {\n                home_team: eventData.home_team,\n                away_team: eventData.away_team,\n                start_time: eventData.start_time\n            } : null;\n            // Build book selections\n            const bookSelections = {};\n            for (const key of marketKeys){\n                const rawBook = key.split(\":\").pop();\n                const book = normalizeBookId(rawBook);\n                const data = oddsDataMap.get(key);\n                if (data) {\n                    bookSelections[book] = data;\n                }\n            }\n            // Get unique base selection keys\n            // For team_total market, we need to differentiate home vs away teams\n            const baseSelectionKeys = new Set();\n            for (const selections of Object.values(bookSelections)){\n                for (const [key, sel] of Object.entries(selections)){\n                    const [playerRaw, , lineStr] = key.split(\"|\");\n                    if (playerRaw && lineStr) {\n                        // For team_total markets, include home/away designation from raw_market\n                        if (market === \"team_total\" && sel && typeof sel === \"object\" && \"raw_market\" in sel) {\n                            const rawMarket = sel.raw_market || \"\";\n                            const teamSide = rawMarket.toLowerCase().includes(\"home\") ? \"home\" : rawMarket.toLowerCase().includes(\"away\") ? \"away\" : \"\";\n                            if (teamSide) {\n                                baseSelectionKeys.add(`${playerRaw}|${lineStr}|${teamSide}`);\n                            } else {\n                                baseSelectionKeys.add(`${playerRaw}|${lineStr}|`);\n                            }\n                        } else {\n                            baseSelectionKeys.add(`${playerRaw}|${lineStr}|`);\n                        }\n                    }\n                }\n            }\n            // Process each player/line pair\n            for (const baseKey of baseSelectionKeys){\n                const [playerRaw, lineStr, teamSide] = baseKey.split(\"|\");\n                const player = (0,_lib_odds_types__WEBPACK_IMPORTED_MODULE_2__.normalizePlayerName)(playerRaw);\n                const line = parseFloat(lineStr);\n                // Include teamSide in pair key for team_total markets to separate home/away\n                const pairKey = teamSide ? `${eventId}:${market}:${player}:${line}:${teamSide}` : `${eventId}:${market}:${player}:${line}`;\n                let pair = pairMap.get(pairKey);\n                if (!pair) {\n                    pair = {\n                        sport,\n                        eventId,\n                        event,\n                        player,\n                        playerDisplay: \"\",\n                        playerId: null,\n                        team: null,\n                        position: null,\n                        market,\n                        marketDisplay: \"\",\n                        line,\n                        over: {\n                            books: [],\n                            best: null\n                        },\n                        under: {\n                            books: [],\n                            best: null\n                        }\n                    };\n                    pairMap.set(pairKey, pair);\n                }\n                // Helper to check if a selection matches the expected team side (for team_total markets)\n                const matchesTeamSide = (sel)=>{\n                    if (!teamSide || market !== \"team_total\") return true; // No filtering needed\n                    if (!sel?.raw_market) return false;\n                    const rawMarket = sel.raw_market.toLowerCase();\n                    if (teamSide === \"home\") return rawMarket.includes(\"home\");\n                    if (teamSide === \"away\") return rawMarket.includes(\"away\");\n                    return true;\n                };\n                // Gather prices from all books\n                for (const [book, selections] of Object.entries(bookSelections)){\n                    if (EXCLUDED_BOOKS.has(book.toLowerCase())) continue;\n                    // Check over/yes/ml\n                    const overKey = `${playerRaw}|over|${lineStr}`;\n                    const yesKey = `${playerRaw}|yes|${lineStr}`;\n                    const mlKey = `${playerRaw}|ml|${lineStr}`;\n                    const overSel = selections[overKey] || selections[yesKey] || selections[mlKey];\n                    // For team_total markets, only include selections that match the team side\n                    if (overSel && !overSel.locked && matchesTeamSide(overSel)) {\n                        const overPrice = parseInt(String(overSel.price), 10);\n                        // Debug: Log when limits data is present\n                        if (overSel.limits?.max) {\n                            console.log(`[positive-ev] Limits found: ${book} - Max $${overSel.limits.max}`);\n                        }\n                        const bookOffer = {\n                            bookId: book,\n                            bookName: book,\n                            price: overPrice,\n                            priceDecimal: overSel.price_decimal,\n                            link: overSel.link || null,\n                            mobileLink: overSel.mobile_link || null,\n                            sgp: overSel.sgp || null,\n                            limits: overSel.limits || null,\n                            updated: overSel.updated || undefined\n                        };\n                        pair.over.books.push(bookOffer);\n                        if (!pair.over.best || overSel.price_decimal > pair.over.best.priceDecimal) {\n                            pair.over.best = bookOffer;\n                        }\n                        if (overSel.player && !pair.playerDisplay) pair.playerDisplay = overSel.player;\n                        if (overSel.player_id && !pair.playerId) pair.playerId = overSel.player_id;\n                        if (overSel.team && !pair.team) pair.team = overSel.team;\n                        if (overSel.position && !pair.position) pair.position = formatPosition(overSel.position);\n                        if (overSel.raw_market && !pair.marketDisplay) pair.marketDisplay = (0,_lib_odds_types__WEBPACK_IMPORTED_MODULE_2__.normalizeRawMarket)(overSel.raw_market);\n                    }\n                    // Check under/no\n                    const underKey = `${playerRaw}|under|${lineStr}`;\n                    const noKey = `${playerRaw}|no|${lineStr}`;\n                    const underSel = selections[underKey] || selections[noKey];\n                    // For team_total markets, only include selections that match the team side\n                    if (underSel && !underSel.locked && matchesTeamSide(underSel)) {\n                        const underPrice = parseInt(String(underSel.price), 10);\n                        // Debug: Log when limits data is present\n                        if (underSel.limits?.max) {\n                            console.log(`[positive-ev] Limits found: ${book} - Max $${underSel.limits.max}`);\n                        }\n                        const bookOffer = {\n                            bookId: book,\n                            bookName: book,\n                            price: underPrice,\n                            priceDecimal: underSel.price_decimal,\n                            link: underSel.link || null,\n                            mobileLink: underSel.mobile_link || null,\n                            sgp: underSel.sgp || null,\n                            limits: underSel.limits || null,\n                            updated: underSel.updated || undefined\n                        };\n                        pair.under.books.push(bookOffer);\n                        if (!pair.under.best || underSel.price_decimal > pair.under.best.priceDecimal) {\n                            pair.under.best = bookOffer;\n                        }\n                        if (underSel.player && !pair.playerDisplay) pair.playerDisplay = underSel.player;\n                        if (underSel.player_id && !pair.playerId) pair.playerId = underSel.player_id;\n                        if (underSel.team && !pair.team) pair.team = underSel.team;\n                        if (underSel.position && !pair.position) pair.position = formatPosition(underSel.position);\n                        if (underSel.raw_market && !pair.marketDisplay) pair.marketDisplay = (0,_lib_odds_types__WEBPACK_IMPORTED_MODULE_2__.normalizeRawMarket)(underSel.raw_market);\n                    }\n                }\n            }\n        }\n        // Step 6: Calculate +EV for each pair\n        for (const pair of pairMap.values()){\n            // Need minimum books on both sides for proper de-vigging (width filter)\n            if (pair.over.books.length < minBooksPerSide || pair.under.books.length < minBooksPerSide) continue;\n            // Get sharp reference odds (use custom config if provided, otherwise use preset)\n            const sharpOver = customSharpConfig ? getSharpOddsForCustomConfig(pair.over.books, customSharpConfig) : getSharpOddsForPreset(pair.over.books, sharpPreset);\n            const sharpUnder = customSharpConfig ? getSharpOddsForCustomConfig(pair.under.books, customSharpConfig) : getSharpOddsForPreset(pair.under.books, sharpPreset);\n            if (!sharpOver || !sharpUnder) continue;\n            // In custom model mode, enforce min-books against the actual\n            // reference books that contributed on BOTH sides after exclusions.\n            // This ensures we only surface rows with enough true paired refs.\n            if (customSharpConfig) {\n                const sharpOverRefs = new Set(sharpOver.blendedFrom ?? [\n                    sharpOver.source.toLowerCase()\n                ]);\n                const sharpUnderRefs = new Set(sharpUnder.blendedFrom ?? [\n                    sharpUnder.source.toLowerCase()\n                ]);\n                const sharedRefCount = Array.from(sharpOverRefs).filter((book)=>sharpUnderRefs.has(book)).length;\n                if (sharedRefCount < minBooksPerSide) {\n                    continue;\n                }\n            }\n            // De-vig using the sharp reference\n            const devigResults = (0,_lib_ev__WEBPACK_IMPORTED_MODULE_3__.devigMultiple)(sharpOver.price, sharpUnder.price, devigMethods);\n            // Determine the effective preset name for display\n            const effectivePreset = customSharpConfig ? \"custom\" : sharpPreset;\n            // Create sharp reference object\n            // Only include books that contributed to BOTH sides in blendedFrom\n            const bothSidesBooks = sharpOver.blendedFrom && sharpUnder.blendedFrom ? sharpOver.blendedFrom.filter((b)=>sharpUnder.blendedFrom.includes(b)) : sharpOver.blendedFrom;\n            const sharpReference = (0,_lib_ev__WEBPACK_IMPORTED_MODULE_3__.createSharpReference)(sharpOver.price, sharpUnder.price, effectivePreset, sharpOver.source, bothSidesBooks);\n            // Check each book for +EV opportunities on both sides\n            const sides = [\n                \"over\",\n                \"under\"\n            ];\n            // Get books to exclude based on the sharp reference\n            // When using custom config, exclude the custom sharp books\n            const excludedBooks = customSharpConfig ? new Set(customSharpConfig.books.map((b)=>b.toLowerCase())) : getExcludedBooksForPreset(sharpPreset);\n            for (const side of sides){\n                const sideData = pair[side];\n                const oppositeSide = side === \"over\" ? \"under\" : \"over\";\n                const oppositeData = pair[oppositeSide];\n                // Calculate EV for ALL books first (for comparison display)\n                const booksWithEV = [];\n                for (const bookOffer of sideData.books){\n                    const evCalc = (0,_lib_ev__WEBPACK_IMPORTED_MODULE_3__.calculateMultiEV)(devigResults, bookOffer, side);\n                    const isExcluded = excludedBooks.has(bookOffer.bookId.toLowerCase());\n                    booksWithEV.push({\n                        book: bookOffer,\n                        evCalc,\n                        isExcluded\n                    });\n                }\n                // Sort by EV (highest first)\n                booksWithEV.sort((a, b)=>b.evCalc.evWorst - a.evCalc.evWorst);\n                // Filter to books that can be bet on (not excluded, passes user filter)\n                let bettableBooks = booksWithEV.filter((b)=>!b.isExcluded);\n                if (booksFilter) {\n                    bettableBooks = bettableBooks.filter((b)=>booksFilter.includes(b.book.bookId));\n                }\n                // Find the best EV book that meets threshold\n                const bestBook = bettableBooks.find((b)=>b.evCalc.evWorst >= minEV && b.evCalc.evWorst <= maxEV);\n                // Skip if no book meets threshold\n                if (!bestBook) continue;\n                // Create allBooks array with EV% for each book\n                const allBooksWithEV = booksWithEV.map((b)=>({\n                        bookId: b.book.bookId,\n                        bookName: b.book.bookName,\n                        price: b.book.price,\n                        priceDecimal: b.book.priceDecimal,\n                        link: b.book.link || null,\n                        mobileLink: b.book.mobileLink || null,\n                        sgp: b.book.sgp || null,\n                        limits: b.book.limits || null,\n                        evPercent: b.evCalc.evWorst,\n                        isSharpRef: b.isExcluded\n                    }));\n                // Sort allBooks by EV (best first) for display\n                allBooksWithEV.sort((a, b)=>(b.evPercent ?? 0) - (a.evPercent ?? 0));\n                // Create ONE opportunity per market (deduplicated to best EV)\n                const marketKey = `${pair.eventId}:${pair.market}:${pair.player}:${pair.line}:${side}`;\n                const opp = {\n                    id: marketKey,\n                    sport: pair.sport,\n                    eventId: pair.eventId,\n                    market: pair.market,\n                    marketDisplay: pair.marketDisplay || (0,_lib_odds_types__WEBPACK_IMPORTED_MODULE_2__.getMarketDisplay)(pair.market),\n                    homeTeam: pair.event?.home_team,\n                    awayTeam: pair.event?.away_team,\n                    startTime: pair.event?.start_time,\n                    playerId: pair.playerId || undefined,\n                    playerName: pair.playerDisplay || pair.player,\n                    playerTeam: pair.team || undefined,\n                    playerPosition: pair.position || undefined,\n                    line: pair.line,\n                    side,\n                    sharpPreset: effectivePreset,\n                    sharpReference: {\n                        ...sharpReference,\n                        blendedFrom: undefined\n                    },\n                    devigResults: {\n                        [devigMethods[0]]: devigResults[devigMethods[0]]\n                    },\n                    book: {\n                        bookId: bestBook.book.bookId,\n                        price: bestBook.book.price,\n                        priceDecimal: bestBook.book.priceDecimal,\n                        link: bestBook.book.link,\n                        mobileLink: bestBook.book.mobileLink || null,\n                        limits: bestBook.book.limits || null,\n                        evPercent: bestBook.evCalc.evWorst\n                    },\n                    evCalculations: bestBook.evCalc,\n                    // All books with their EV% for comparison\n                    allBooks: allBooksWithEV,\n                    oppositeBooks: oppositeData.books.map((b)=>({\n                            bookId: b.bookId,\n                            bookName: b.bookName,\n                            price: b.price,\n                            priceDecimal: b.priceDecimal,\n                            link: b.link || null,\n                            mobileLink: b.mobileLink || null,\n                            sgp: b.sgp || null,\n                            limits: b.limits || null\n                        })),\n                    createdAt: new Date().toISOString(),\n                    updatedAt: new Date().toISOString()\n                };\n                opportunities.push(opp);\n            }\n        }\n        return opportunities;\n    } catch (error) {\n        console.error(`[positive-ev] Error fetching ${sport}:`, error);\n        return [];\n    }\n}\n/**\n * Books to exclude from market average calculations entirely.\n * Prediction markets (Polymarket, Kalshi) use exchange-style pricing\n * that can skew traditional sportsbook averages.\n */ const EXCLUDED_FROM_AVERAGE = new Set([\n    \"polymarket\",\n    \"kalshi\"\n]);\n/**\n * RSI (Rush Street Interactive) books that often share the same odds feed.\n * When all have identical odds, we should only count them once in averages.\n */ const RSI_BOOKS = new Set([\n    \"betrivers\",\n    \"bally-bet\",\n    \"betparx\"\n]);\n/**\n * Filter and deduplicate books for market average calculation.\n * - Excludes prediction markets (Polymarket, Kalshi) entirely\n * - RSI books with identical odds are counted once to avoid skewing\n */ function filterBooksForAverage(books) {\n    // Step 1: Exclude prediction markets entirely\n    const filtered = books.filter((b)=>!EXCLUDED_FROM_AVERAGE.has(b.bookId.toLowerCase()));\n    // Step 2: Deduplicate RSI books with identical odds\n    const rsiBooks = [];\n    const otherBooks = [];\n    for (const b of filtered){\n        if (RSI_BOOKS.has(b.bookId.toLowerCase())) {\n            rsiBooks.push(b);\n        } else {\n            otherBooks.push(b);\n        }\n    }\n    if (rsiBooks.length === 0) return filtered;\n    // Keep only unique RSI prices\n    const rsiByPrice = new Map();\n    for (const b of rsiBooks){\n        const rounded = Math.round(b.price * 100) / 100;\n        if (!rsiByPrice.has(rounded)) {\n            rsiByPrice.set(rounded, b);\n        }\n    }\n    return [\n        ...otherBooks,\n        ...rsiByPrice.values()\n    ];\n}\n/**\n * Get sharp odds for a preset from available books\n */ function getSharpOddsForPreset(books, preset) {\n    const presetConfig = _lib_ev_constants__WEBPACK_IMPORTED_MODULE_4__.SHARP_PRESETS[preset];\n    if (!presetConfig) return null;\n    if (preset === \"custom\") {\n        // Custom preset - would need user-defined weights\n        return null;\n    }\n    // Market Average: Use available sportsbooks (excluding prediction markets & deduplicating RSI)\n    if (preset === \"market_average\") {\n        const filteredBooks = filterBooksForAverage(books);\n        if (filteredBooks.length === 0) return null;\n        // Equal weight for all books\n        const blendInputs = filteredBooks.map((b)=>({\n                bookId: b.bookId,\n                odds: b.price,\n                weight: 1.0\n            }));\n        const blendedOdds = (0,_lib_ev__WEBPACK_IMPORTED_MODULE_3__.blendSharpOdds)(blendInputs);\n        if (blendedOdds === 0) return null;\n        return {\n            price: blendedOdds,\n            source: `Market Avg (${filteredBooks.length} books)`,\n            blendedFrom: filteredBooks.map((b)=>b.bookId)\n        };\n    }\n    const presetBooks = presetConfig.books;\n    // Build lookup map for O(1) lookups instead of O(n) .find() calls\n    const bookMap = buildBookLookupMap(books);\n    if (presetBooks.length === 1) {\n        // Single book preset - O(1) lookup\n        const targetBook = presetBooks[0].bookId;\n        const match = bookMap.get(targetBook.toLowerCase()) || bookMap.get(normalizeBookIdForSharp(targetBook.toLowerCase()));\n        if (match) {\n            return {\n                price: match.price,\n                source: targetBook\n            };\n        }\n        return null;\n    }\n    // Blended preset - REQUIRES ALL BOOKS to be present\n    const blendInputs = [];\n    const blendedFrom = [];\n    for (const { bookId, weight } of presetBooks){\n        // O(1) lookup instead of O(n) .find()\n        const match = bookMap.get(bookId.toLowerCase()) || bookMap.get(normalizeBookIdForSharp(bookId.toLowerCase()));\n        if (match) {\n            blendInputs.push({\n                bookId,\n                odds: match.price,\n                weight\n            });\n            blendedFrom.push(bookId);\n        }\n    }\n    // For blended presets, require ALL books to be available\n    // This ensures pinnacle_circa only works when BOTH Pinnacle AND Circa have odds\n    if (blendInputs.length !== presetBooks.length) {\n        return null;\n    }\n    // All books are present, so weights are already properly normalized from the preset config\n    const blendedOdds = (0,_lib_ev__WEBPACK_IMPORTED_MODULE_3__.blendSharpOdds)(blendInputs);\n    if (blendedOdds === 0) return null;\n    return {\n        price: blendedOdds,\n        source: `${preset} (${blendedFrom.join(\", \")})`,\n        blendedFrom\n    };\n}\n/**\n * Get sharp odds using a custom configuration (user's custom EV model)\n * Supports weighted blending of multiple sharp books\n */ /**\n * Build a lookup map for fast book matching\n * Maps all possible book ID variations to the BookOffer\n */ function buildBookLookupMap(books) {\n    const map = new Map();\n    for (const book of books){\n        const lower = book.bookId.toLowerCase();\n        // Add the original lowercased ID\n        map.set(lower, book);\n        // Add the normalized version too\n        const normalized = normalizeBookIdForSharp(lower);\n        if (normalized !== lower) {\n            map.set(normalized, book);\n        }\n    }\n    return map;\n}\nfunction getSharpOddsForCustomConfig(books, config) {\n    if (!config.books || config.books.length === 0) {\n        return null;\n    }\n    // For custom blends, exclude prediction markets entirely to avoid skewing\n    const filteredBooks = books.filter((b)=>!EXCLUDED_FROM_AVERAGE.has(b.bookId.toLowerCase()));\n    // Build lookup map once for O(1) lookups instead of O(n) .find() calls\n    const bookMap = buildBookLookupMap(filteredBooks);\n    // Single book in custom config\n    if (config.books.length === 1) {\n        const targetBook = config.books[0].toLowerCase();\n        const match = bookMap.get(targetBook) || bookMap.get(normalizeBookIdForSharp(targetBook));\n        if (match) {\n            return {\n                price: match.price,\n                source: targetBook\n            };\n        }\n        return null;\n    }\n    // Multiple books - use weighted blending\n    const blendInputs = [];\n    const blendedFrom = [];\n    // Calculate total weight from available books for normalization\n    let totalAvailableWeight = 0;\n    for (const bookId of config.books){\n        const normalizedBookId = bookId.toLowerCase();\n        // O(1) lookup instead of O(n) .find()\n        const match = bookMap.get(normalizedBookId) || bookMap.get(normalizeBookIdForSharp(normalizedBookId));\n        if (match) {\n            // Get weight from config, default to equal weight if not specified\n            const weight = config.weights?.[bookId] ?? config.weights?.[normalizedBookId] ?? 100 / config.books.length;\n            blendInputs.push({\n                bookId: normalizedBookId,\n                odds: match.price,\n                weight\n            });\n            blendedFrom.push(normalizedBookId);\n            totalAvailableWeight += weight;\n        }\n    }\n    // Require at least one book to be available\n    if (blendInputs.length === 0) {\n        return null;\n    }\n    // If not all books are available, normalize weights to sum to 100%\n    if (blendInputs.length < config.books.length && totalAvailableWeight > 0) {\n        const normalizationFactor = 100 / totalAvailableWeight;\n        blendInputs.forEach((input)=>{\n            input.weight = input.weight * normalizationFactor;\n        });\n    }\n    const blendedOdds = (0,_lib_ev__WEBPACK_IMPORTED_MODULE_3__.blendSharpOdds)(blendInputs);\n    if (blendedOdds === 0) return null;\n    const sourceBooks = blendedFrom.map((b)=>b.charAt(0).toUpperCase() + b.slice(1)).join(\", \");\n    return {\n        price: blendedOdds,\n        source: `Custom (${sourceBooks})`,\n        blendedFrom\n    };\n}\n/**\n * Normalize book ID for sharp book matching\n */ function normalizeBookIdForSharp(id) {\n    const lower = id.toLowerCase();\n    switch(lower){\n        case \"hardrock\":\n            return \"hard-rock\";\n        case \"hard-rock\":\n            return \"hardrock\";\n        default:\n            return lower;\n    }\n}\n// =============================================================================\n// Redis Helpers (reused from opportunities API)\n// =============================================================================\nasync function getActiveEventIds(sport) {\n    const activeSet = await redis.smembers(`active_events:${sport}`);\n    if (activeSet && activeSet.length > 0) {\n        return activeSet.map(String);\n    }\n    // Fallback to scanning\n    const eventKeys = await scanKeys(`events:${sport}:*`);\n    return eventKeys.map((k)=>k.split(\":\")[2]).filter(Boolean);\n}\nasync function getOddsKeysForEvents(sport, eventIds) {\n    const allKeys = [];\n    const BATCH_SIZE = 10;\n    for(let i = 0; i < eventIds.length; i += BATCH_SIZE){\n        const batch = eventIds.slice(i, i + BATCH_SIZE);\n        const batchResults = await Promise.all(batch.map((eventId)=>scanKeys(`odds:${sport}:${eventId}:*`)));\n        allKeys.push(...batchResults.flat());\n    }\n    return allKeys;\n}\nasync function scanKeys(pattern) {\n    const keys = [];\n    let cursor = \"0\";\n    let iterations = 0;\n    const MAX_ITERATIONS = 50;\n    do {\n        iterations++;\n        const result = await redis.scan(cursor, {\n            match: pattern,\n            count: SCAN_COUNT\n        });\n        cursor = result[0];\n        keys.push(...result[1]);\n        if (iterations >= MAX_ITERATIONS) {\n            console.warn(`[scanKeys] Hit iteration limit for pattern: ${pattern}`);\n            break;\n        }\n    }while (cursor !== \"0\");\n    return keys;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMxRGxCLE9BQU9pQjtZQUNQTSxPQUFPdlU7UUFDVDtRQUNBa1UsU0FBU0csTUFBTSxDQUFDLEVBQUU7UUFDbEJqVCxLQUFLK0ksSUFBSSxJQUFJa0ssTUFBTSxDQUFDLEVBQUU7UUFFdEIsSUFBSUYsY0FBY0MsZ0JBQWdCO1lBQ2hDN1IsUUFBUTJFLElBQUksQ0FBQyxDQUFDLDRDQUE0QyxFQUFFK00sU0FBUztZQUNyRTtRQUNGO0lBQ0YsUUFBU0MsV0FBVyxLQUFLO0lBRXpCLE9BQU85UztBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvZHJld21hc2Nob2ZmL2Rldi91bmp1aWNlZC9hcHBzL3dlYi9hcHAvYXBpL3YyL3Bvc2l0aXZlLWV2L3JvdXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVzZSBOb2RlLmpzIHJ1bnRpbWUgZm9yIGxvbmdlciB0aW1lb3V0cyBhbmQgYmV0dGVyIHBlcmZvcm1hbmNlXG5leHBvcnQgY29uc3QgcnVudGltZSA9IFwibm9kZWpzXCI7XG5leHBvcnQgY29uc3QgbWF4RHVyYXRpb24gPSA2MDsgLy8gQWxsb3cgdXAgdG8gNjAgc2Vjb25kc1xuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSBcIm5leHQvc2VydmVyXCI7XG5pbXBvcnQgeyBSZWRpcyB9IGZyb20gXCJAdXBzdGFzaC9yZWRpc1wiO1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplUGxheWVyTmFtZSxcbiAgZ2V0TWFya2V0RGlzcGxheSxcbiAgbm9ybWFsaXplUmF3TWFya2V0LFxuICBTU0VTZWxlY3Rpb24sXG4gIFNTRUJvb2tTZWxlY3Rpb25zLFxufSBmcm9tIFwiQC9saWIvb2Rkcy90eXBlc1wiO1xuaW1wb3J0IHtcbiAgZGV2aWdNdWx0aXBsZSxcbiAgY2FsY3VsYXRlTXVsdGlFVixcbiAgYW1lcmljYW5Ub0RlY2ltYWwsXG4gIGFtZXJpY2FuVG9JbXBsaWVkUHJvYixcbiAgY3JlYXRlU2hhcnBSZWZlcmVuY2UsXG4gIGJsZW5kU2hhcnBPZGRzLFxuICBmb3JtYXRFVixcbiAgZm9ybWF0S2VsbHksXG4gIHR5cGUgRGV2aWdNZXRob2QsXG4gIHR5cGUgU2hhcnBQcmVzZXQsXG4gIHR5cGUgUG9zaXRpdmVFVk9wcG9ydHVuaXR5LFxuICB0eXBlIFBvc2l0aXZlRVZSZXNwb25zZSxcbiAgdHlwZSBCb29rT2ZmZXIsXG4gIHR5cGUgTXVsdGlEZXZpZ1Jlc3VsdCxcbiAgdHlwZSBFVk1vZGUsXG4gIHR5cGUgQ3VzdG9tU2hhcnBDb25maWcsXG59IGZyb20gXCJAL2xpYi9ldlwiO1xuaW1wb3J0IHtcbiAgU0hBUlBfUFJFU0VUUyxcbiAgREVGQVVMVF9ERVZJR19NRVRIT0RTLFxuICBQT1NJVElWRV9FVl9ERUZBVUxUUyxcbiAgRVZfVEhSRVNIT0xEUyxcbn0gZnJvbSBcIkAvbGliL2V2L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSBcIkAvbGlicy9zdXBhYmFzZS9zZXJ2ZXJcIjtcbmltcG9ydCB7IGdldFVzZXJQbGFuIH0gZnJvbSBcIkAvbGliL3BsYW5zLXNlcnZlclwiO1xuaW1wb3J0IHsgaGFzRWxpdGVBY2Nlc3MgfSBmcm9tIFwiQC9saWIvcGxhbnNcIjtcblxuY29uc3QgcmVkaXMgPSBuZXcgUmVkaXMoe1xuICB1cmw6IHByb2Nlc3MuZW52LlVQU1RBU0hfUkVESVNfUkVTVF9VUkwhLFxuICB0b2tlbjogcHJvY2Vzcy5lbnYuVVBTVEFTSF9SRURJU19SRVNUX1RPS0VOISxcbn0pO1xuXG4vLyBDb25maWd1cmF0aW9uIC0gb3B0aW1pemVkIGZvciBzcGVlZFxuY29uc3QgU0NBTl9DT1VOVCA9IDIwMDA7ICAgICAgLy8gTGFyZ2VyIHNjYW4gYmF0Y2hlc1xuY29uc3QgTUdFVF9DSFVOS19TSVpFID0gNTAwOyAgLy8gUmVkdWNlZCB0byBwcmV2ZW50IGNvbm5lY3Rpb24gaXNzdWVzXG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSZWRpcyBSZXNwb25zZSBDYWNoZSAoc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzKVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgUkVTUE9OU0VfQ0FDSEVfUFJFRklYID0gXCJldjpyZXNwb25zZTpcIjtcbmNvbnN0IFJFU1BPTlNFX0NBQ0hFX1RUTF9QUkVTRVQgPSAxNTsgIC8vIDE1IHNlY29uZHMgZm9yIHN0YW5kYXJkIHByZXNldHNcbmNvbnN0IFJFU1BPTlNFX0NBQ0hFX1RUTF9DVVNUT00gPSAzMDsgIC8vIDMwIHNlY29uZHMgZm9yIGN1c3RvbSBtb2RlbHMgKGNvbmZpZ3MgcmFyZWx5IGNoYW5nZSlcblxuZnVuY3Rpb24gcmVzb2x2ZUFsbG93ZWRPcmlnaW4ob3JpZ2luOiBzdHJpbmcgfCBudWxsKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICghb3JpZ2luKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCBpc0xvY2FsaG9zdCA9IC9eaHR0cDpcXC9cXC9sb2NhbGhvc3Q6XFxkKyQvLnRlc3Qob3JpZ2luKSB8fCAvXmh0dHA6XFwvXFwvMTI3XFwuMFxcLjBcXC4xOlxcZCskLy50ZXN0KG9yaWdpbik7XG4gIGlmIChpc0xvY2FsaG9zdCkgcmV0dXJuIG9yaWdpbjtcbiAgaWYgKG9yaWdpbiA9PT0gXCJodHRwczovL2FwcC51bmp1aWNlZC5iZXRcIikgcmV0dXJuIG9yaWdpbjtcbiAgaWYgKG9yaWdpbiA9PT0gXCJodHRwczovL3d3dy51bmp1aWNlZC5iZXRcIikgcmV0dXJuIG9yaWdpbjtcbiAgaWYgKG9yaWdpbiA9PT0gXCJodHRwczovL3VuanVpY2VkLmJldFwiKSByZXR1cm4gb3JpZ2luO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDb3JzSGVhZGVycyhvcmlnaW46IHN0cmluZyB8IG51bGwpOiBIZWFkZXJzSW5pdCB7XG4gIGNvbnN0IGFsbG93ZWRPcmlnaW4gPSByZXNvbHZlQWxsb3dlZE9yaWdpbihvcmlnaW4pO1xuXG4gIHJldHVybiB7XG4gICAgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIjogYWxsb3dlZE9yaWdpbiA/PyBcIm51bGxcIixcbiAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHNcIjogXCJHRVQsIE9QVElPTlNcIixcbiAgICBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIjogXCJBdXRob3JpemF0aW9uLCBDb250ZW50LVR5cGUsIENhY2hlLUNvbnRyb2wsIFByYWdtYVwiLFxuICAgIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcIjogXCJ0cnVlXCIsXG4gICAgXCJBY2Nlc3MtQ29udHJvbC1NYXgtQWdlXCI6IFwiODY0MDBcIixcbiAgICBWYXJ5OiBcIk9yaWdpblwiXG4gIH07XG59XG5cbmZ1bmN0aW9uIGpzb25XaXRoSGVhZGVycyhcbiAgYm9keTogdW5rbm93bixcbiAgc3RhdHVzOiBudW1iZXIsXG4gIG9yaWdpbjogc3RyaW5nIHwgbnVsbCxcbiAgZXh0cmFIZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKSB7XG4gIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihib2R5LCB7XG4gICAgc3RhdHVzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmdldENvcnNIZWFkZXJzKG9yaWdpbiksXG4gICAgICAuLi4oZXh0cmFIZWFkZXJzID8/IHt9KVxuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQnVpbGQgY2FjaGUga2V5IGZyb20gcmVxdWVzdCBwYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUmVzcG9uc2VDYWNoZUtleShwYXJhbXM6IFVSTFNlYXJjaFBhcmFtcyk6IHN0cmluZyB7XG4gIGNvbnN0IGtleXMgPSBbJ3Nwb3J0cycsICdzaGFycFByZXNldCcsICdkZXZpZ01ldGhvZHMnLCAnbWluRVYnLCAnbWF4RVYnLCAnYm9va3MnLCAnbGltaXQnLCAnbW9kZScsICdtaW5Cb29rc1BlclNpZGUnLCAnY3VzdG9tU2hhcnBCb29rcycsICdjdXN0b21Cb29rV2VpZ2h0cyddO1xuICByZXR1cm4ga2V5cy5tYXAoayA9PiBgJHtrfToke3BhcmFtcy5nZXQoaykgfHwgJyd9YCkuam9pbignfCcpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHJlcXVlc3QgaXMgdXNpbmcgYSBjdXN0b20gbW9kZWwgKGhhcyBjdXN0b21TaGFycEJvb2tzKVxuICovXG5mdW5jdGlvbiBpc0N1c3RvbU1vZGVsUmVxdWVzdChwYXJhbXM6IFVSTFNlYXJjaFBhcmFtcyk6IGJvb2xlYW4ge1xuICBjb25zdCBjdXN0b21Cb29rcyA9IHBhcmFtcy5nZXQoXCJjdXN0b21TaGFycEJvb2tzXCIpO1xuICByZXR1cm4gISFjdXN0b21Cb29rcyAmJiBjdXN0b21Cb29rcy5sZW5ndGggPiAwO1xufVxuXG4vKipcbiAqIEdldCBoYXNoIG9mIGNhY2hlIGtleSBmb3Igc2hvcnRlciBSZWRpcyBrZXlzXG4gKi9cbmZ1bmN0aW9uIGhhc2hDYWNoZUtleShrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFNpbXBsZSBoYXNoIGZ1bmN0aW9uIGZvciBzaG9ydGVyIGtleXNcbiAgbGV0IGhhc2ggPSA1MzgxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgKyBoYXNoKSBeIGtleS5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiAoaGFzaCA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsICcwJyk7XG59XG5cbi8qKlxuICogQ2hlY2sgUmVkaXMgcmVzcG9uc2UgY2FjaGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RnJvbVJlc3BvbnNlQ2FjaGUoa2V5OiBzdHJpbmcpOiBQcm9taXNlPHVua25vd24gfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVkaXNLZXkgPSBgJHtSRVNQT05TRV9DQUNIRV9QUkVGSVh9JHtoYXNoQ2FjaGVLZXkoa2V5KX1gO1xuICAgIGNvbnN0IGNhY2hlZCA9IGF3YWl0IHJlZGlzLmdldChyZWRpc0tleSk7XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3Bvc2l0aXZlLWV2XSBSZWRpcyBjYWNoZSByZWFkIGVycm9yOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTdG9yZSBpbiBSZWRpcyByZXNwb25zZSBjYWNoZSB3aXRoIHRpZXJlZCBUVExcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2V0SW5SZXNwb25zZUNhY2hlKGtleTogc3RyaW5nLCBkYXRhOiB1bmtub3duLCBpc0N1c3RvbTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHR0bCA9IGlzQ3VzdG9tID8gUkVTUE9OU0VfQ0FDSEVfVFRMX0NVU1RPTSA6IFJFU1BPTlNFX0NBQ0hFX1RUTF9QUkVTRVQ7XG4gICAgY29uc3QgcmVkaXNLZXkgPSBgJHtSRVNQT05TRV9DQUNIRV9QUkVGSVh9JHtoYXNoQ2FjaGVLZXkoa2V5KX1gO1xuICAgIGF3YWl0IHJlZGlzLnNldChyZWRpc0tleSwgZGF0YSwgeyBleDogdHRsIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbcG9zaXRpdmUtZXZdIFJlZGlzIGNhY2hlIHdyaXRlIGVycm9yOlwiLCBlcnJvcik7XG4gIH1cbn1cblxuLy8gU3VwcG9ydGVkIHNwb3J0c1xuY29uc3QgVkFMSURfU1BPUlRTID0gbmV3IFNldChbXCJuYmFcIiwgXCJuZmxcIiwgXCJuaGxcIiwgXCJuY2FhYlwiLCBcIm5jYWFmXCIsIFwibWxiXCIsIFwid25iYVwiLCBcInNvY2Nlcl9lcGxcIl0pO1xuXG4vLyBCb29rcyB0byBleGNsdWRlIChyZWdpb25hbCB2YXJpYW50cylcbmNvbnN0IEVYQ0xVREVEX0JPT0tTID0gbmV3IFNldChbXG4gIFwiaGFyZC1yb2NrLWluZGlhbmFcIixcbiAgXCJoYXJkcm9ja2luZGlhbmFcIixcbl0pO1xuXG4vKipcbiAqIEdldCB0aGUgYm9vayBJRHMgdGhhdCBzaG91bGQgYmUgZXhjbHVkZWQgYmFzZWQgb24gdGhlIGN1cnJlbnQgc2hhcnAgcHJlc2V0XG4gKiBPbmx5IGV4Y2x1ZGUgYm9va3MgdGhhdCBhcmUgYWN0dWFsbHkgYmVpbmcgdXNlZCBhcyB0aGUgc2hhcnAgcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIGdldEV4Y2x1ZGVkQm9va3NGb3JQcmVzZXQocHJlc2V0OiBTaGFycFByZXNldCk6IFNldDxzdHJpbmc+IHtcbiAgY29uc3QgZXhjbHVkZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgXG4gIHN3aXRjaCAocHJlc2V0KSB7XG4gICAgY2FzZSBcInBpbm5hY2xlXCI6XG4gICAgICBleGNsdWRlZC5hZGQoXCJwaW5uYWNsZVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwaW5uYWNsZV9jaXJjYVwiOlxuICAgICAgZXhjbHVkZWQuYWRkKFwicGlubmFjbGVcIik7XG4gICAgICBleGNsdWRlZC5hZGQoXCJjaXJjYVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJoYXJkcm9ja190aGVzY29yZVwiOlxuICAgICAgZXhjbHVkZWQuYWRkKFwiaGFyZHJvY2tcIik7XG4gICAgICBleGNsdWRlZC5hZGQoXCJoYXJkLXJvY2tcIik7XG4gICAgICBleGNsdWRlZC5hZGQoXCJ0aGVzY29yZVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtYXJrZXRfYXZlcmFnZVwiOlxuICAgICAgLy8gTWFya2V0IGF2ZXJhZ2UgdXNlcyBBTEwgYm9va3MgdG8gY2FsY3VsYXRlIGZhaXIgdmFsdWVcbiAgICAgIC8vIEFueSBpbmRpdmlkdWFsIGJvb2sgY2FuIHN0aWxsIGJlICtFViBpZiBiZXR0ZXIgdGhhbiB0aGUgYXZlcmFnZVxuICAgICAgLy8gU28gd2UgZG9uJ3QgZXhjbHVkZSBhbnkgYm9va3NcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjdXN0b21cIjpcbiAgICAgIC8vIEN1c3RvbSBwcmVzZXRzIHdvdWxkIG5lZWQgdG8gYmUgaGFuZGxlZCBiYXNlZCBvbiB1c2VyIGNvbmZpZ1xuICAgICAgLy8gRm9yIG5vdywgZG9uJ3QgZXhjbHVkZSBhbnl0aGluZ1xuICAgICAgYnJlYWs7XG4gIH1cbiAgXG4gIHJldHVybiBleGNsdWRlZDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYm9vayBJRHMgdG8gbWF0Y2ggY2Fub25pY2FsIHNwb3J0c2Jvb2sgSURzXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJvb2tJZChpZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgbG93ZXIgPSBpZC50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKGxvd2VyKSB7XG4gICAgY2FzZSBcImhhcmRyb2NrXCI6XG4gICAgICByZXR1cm4gXCJoYXJkLXJvY2tcIjtcbiAgICBjYXNlIFwiaGFyZHJvY2tpbmRpYW5hXCI6XG4gICAgY2FzZSBcImhhcmRyb2NrLWluZGlhbmFcIjpcbiAgICAgIHJldHVybiBcImhhcmQtcm9jay1pbmRpYW5hXCI7XG4gICAgY2FzZSBcImJhbGx5YmV0XCI6XG4gICAgICByZXR1cm4gXCJiYWxseS1iZXRcIjtcbiAgICBjYXNlIFwic3BvcnRzaW50ZXJhY3Rpb25cIjpcbiAgICAgIHJldHVybiBcInNwb3J0cy1pbnRlcmFjdGlvblwiO1xuICAgIGNhc2UgXCJmYW5kdWVsLXlvdXJ3YXlcIjpcbiAgICBjYXNlIFwiZmFuZHVlbF95b3Vyd2F5XCI6XG4gICAgICByZXR1cm4gXCJmYW5kdWVseW91cndheVwiO1xuICAgIGNhc2UgXCJiZXRtZ20tbWljaGlnYW5cIjpcbiAgICBjYXNlIFwiYmV0bWdtX21pY2hpZ2FuXCI6XG4gICAgICByZXR1cm4gXCJiZXRtZ21cIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGxvd2VyO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IHBvc2l0aW9uIHN0cmluZ3NcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyB8IG51bGwpOiBzdHJpbmcgfCBudWxsIHtcbiAgaWYgKCFwb3NpdGlvbikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG11bHRpUG9zUGF0dGVybnMgPSBbXCJHRlwiLCBcIkZHXCIsIFwiRkNcIiwgXCJDRlwiLCBcIlNGXCIsIFwiRlNcIiwgXCJQR1wiLCBcIlNHXCIsIFwiUEZcIl07XG4gIGNvbnN0IHVwcGVyID0gcG9zaXRpb24udG9VcHBlckNhc2UoKTtcbiAgaWYgKHBvc2l0aW9uLmxlbmd0aCA9PT0gMiAmJiBtdWx0aVBvc1BhdHRlcm5zLmluY2x1ZGVzKHVwcGVyKSkge1xuICAgIHJldHVybiBgJHtwb3NpdGlvblswXX0vJHtwb3NpdGlvblsxXX1gO1xuICB9XG4gIHJldHVybiBwb3NpdGlvbjtcbn1cblxuLyoqXG4gKiBGb3JtYXQgQW1lcmljYW4gb2RkcyBhcyBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZm9ybWF0QW1lcmljYW5PZGRzKHByaWNlOiBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gcHJpY2UgPiAwID8gYCske3ByaWNlfWAgOiBTdHJpbmcocHJpY2UpO1xufVxuXG4vLyBUeXBlcyBmb3IgcGFpcmluZ1xuaW50ZXJmYWNlIFNlbGVjdGlvblBhaXIge1xuICBzcG9ydDogc3RyaW5nO1xuICBldmVudElkOiBzdHJpbmc7XG4gIGV2ZW50OiB7IGhvbWVfdGVhbTogc3RyaW5nOyBhd2F5X3RlYW06IHN0cmluZzsgc3RhcnRfdGltZTogc3RyaW5nIH0gfCBudWxsO1xuICBwbGF5ZXI6IHN0cmluZztcbiAgcGxheWVyRGlzcGxheTogc3RyaW5nO1xuICBwbGF5ZXJJZDogc3RyaW5nIHwgbnVsbDtcbiAgdGVhbTogc3RyaW5nIHwgbnVsbDtcbiAgcG9zaXRpb246IHN0cmluZyB8IG51bGw7XG4gIG1hcmtldDogc3RyaW5nO1xuICBtYXJrZXREaXNwbGF5OiBzdHJpbmc7XG4gIGxpbmU6IG51bWJlcjtcbiAgb3Zlcjoge1xuICAgIGJvb2tzOiBCb29rT2ZmZXJbXTtcbiAgICBiZXN0OiBCb29rT2ZmZXIgfCBudWxsO1xuICB9O1xuICB1bmRlcjoge1xuICAgIGJvb2tzOiBCb29rT2ZmZXJbXTtcbiAgICBiZXN0OiBCb29rT2ZmZXIgfCBudWxsO1xuICB9O1xufVxuXG4vKipcbiAqIEdFVCAvYXBpL3YyL3Bvc2l0aXZlLWV2XG4gKiBcbiAqIFRydWUgK0VWIHRvb2wgdXNpbmcgcHJvcGVyIGRlLXZpZ2dpbmcgbWV0aG9kc1xuICogXG4gKiBRdWVyeSBwYXJhbXM6XG4gKiAgIHNwb3J0cyAgICAgIC0gQ29tbWEtc2VwYXJhdGVkIHNwb3J0cyAoZGVmYXVsdDogXCJuYmFcIilcbiAqICAgbWFya2V0cyAgICAgLSBDb21tYS1zZXBhcmF0ZWQgbWFya2V0cyAob3B0aW9uYWwpXG4gKiAgIHNoYXJwUHJlc2V0IC0gU2hhcnAgcmVmZXJlbmNlIHByZXNldCAoZGVmYXVsdDogXCJwaW5uYWNsZVwiKVxuICogICBkZXZpZ01ldGhvZHMgLSBDb21tYS1zZXBhcmF0ZWQgbWV0aG9kcyAoZGVmYXVsdDogXCJwb3dlcixtdWx0aXBsaWNhdGl2ZVwiKVxuICogICBtaW5FViAgICAgICAtIE1pbmltdW0gRVYlIHRocmVzaG9sZCAoZGVmYXVsdDogMClcbiAqICAgbWF4RVYgICAgICAgLSBNYXhpbXVtIEVWJSB0byBzaG93IChkZWZhdWx0OiAyMClcbiAqICAgYm9va3MgICAgICAgLSBGaWx0ZXIgdG8gc3BlY2lmaWMgc3BvcnRzYm9va3MgKG9wdGlvbmFsKVxuICogICBsaW1pdCAgICAgICAtIE1heCByZXN1bHRzIChkZWZhdWx0OiAxMDApXG4gKiAgIG1vZGUgICAgICAgIC0gRmlsdGVyIG1vZGU6IFwicHJlZ2FtZVwiIChkZWZhdWx0KSwgXCJsaXZlXCIsIG9yIFwiYWxsXCJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXE6IE5leHRSZXF1ZXN0KSB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIGNvbnN0IG9yaWdpbiA9IHJlcS5oZWFkZXJzLmdldChcIm9yaWdpblwiKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkwocmVxLnVybCkuc2VhcmNoUGFyYW1zO1xuICAgIFxuICAgIC8vIFBhcnNlIG1vZGUgZmlyc3QgKG5lZWRlZCBmb3IgY2FjaGUgY2hlY2spXG4gICAgY29uc3QgbW9kZVBhcmFtID0gcGFyYW1zLmdldChcIm1vZGVcIik/LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgbW9kZTogRVZNb2RlID0gbW9kZVBhcmFtID09PSBcImxpdmVcIiA/IFwibGl2ZVwiIDogbW9kZVBhcmFtID09PSBcImFsbFwiID8gXCJhbGxcIiA6IFwicHJlZ2FtZVwiO1xuICAgIFxuICAgIC8vIENhY2hlIGJ5cGFzczogP2ZyZXNoPXRydWUgc2tpcHMgY2FjaGUgKHVzZSBhZnRlciBTU0UgdXBkYXRlcylcbiAgICBjb25zdCBieXBhc3NDYWNoZSA9IHBhcmFtcy5nZXQoXCJmcmVzaFwiKSA9PT0gXCJ0cnVlXCI7XG4gICAgXG4gICAgLy8gQ2hlY2sgUmVkaXMgcmVzcG9uc2UgY2FjaGUgZmlyc3QgKGZhc3QgcGF0aClcbiAgICBjb25zdCBjYWNoZUtleSA9IGJ1aWxkUmVzcG9uc2VDYWNoZUtleShwYXJhbXMpO1xuICAgIGlmICghYnlwYXNzQ2FjaGUpIHtcbiAgICAgIGNvbnN0IGNhY2hlZFJlc3BvbnNlID0gYXdhaXQgZ2V0RnJvbVJlc3BvbnNlQ2FjaGUoY2FjaGVLZXkpO1xuICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbcG9zaXRpdmUtZXZdIENhY2hlIEhJVCAoUmVkaXMsICR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tcylgKTtcbiAgICAgICAgcmV0dXJuIGpzb25XaXRoSGVhZGVycyhjYWNoZWRSZXNwb25zZSwgMjAwLCBvcmlnaW4sIHtcbiAgICAgICAgICBcIkNhY2hlLUNvbnRyb2xcIjogXCJwcml2YXRlLCBtYXgtYWdlPTE1XCIsXG4gICAgICAgICAgXCJYLUNhY2hlXCI6IFwiSElUXCIsXG4gICAgICAgICAgXCJYLUNhY2hlLVNvdXJjZVwiOiBcInJlZGlzXCIsXG4gICAgICAgICAgXCJYLU1vZGVcIjogbW9kZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYFtwb3NpdGl2ZS1ldl0gQ2FjaGUgQllQQVNTIHJlcXVlc3RlZCAoU1NFIHRyaWdnZXJlZCByZWZyZXNoKWApO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHBhcmFtZXRlcnNcbiAgICBjb25zdCBzcG9ydHNQYXJhbSA9IHBhcmFtcy5nZXQoXCJzcG9ydHNcIik/LnRvTG93ZXJDYXNlKCkuc3BsaXQoXCIsXCIpLmZpbHRlcihCb29sZWFuKSB8fCBbXCJuYmFcIl07XG4gICAgY29uc3Qgc3BvcnRzID0gc3BvcnRzUGFyYW0uZmlsdGVyKChzKSA9PiBWQUxJRF9TUE9SVFMuaGFzKHMpKTtcblxuICAgIGlmIChzcG9ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ganNvbldpdGhIZWFkZXJzKHsgZXJyb3I6IFwiTm8gdmFsaWQgc3BvcnRzIHByb3ZpZGVkXCIgfSwgNDAwLCBvcmlnaW4pO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcmtldHMgPSBwYXJhbXMuZ2V0KFwibWFya2V0c1wiKT8udG9Mb3dlckNhc2UoKS5zcGxpdChcIixcIikuZmlsdGVyKEJvb2xlYW4pIHx8IG51bGw7XG4gICAgY29uc3Qgc2hhcnBQcmVzZXQgPSAocGFyYW1zLmdldChcInNoYXJwUHJlc2V0XCIpIHx8IFwicGlubmFjbGVcIikgYXMgU2hhcnBQcmVzZXQ7XG4gICAgY29uc3QgZGV2aWdNZXRob2RzUGFyYW0gPSBwYXJhbXMuZ2V0KFwiZGV2aWdNZXRob2RzXCIpPy50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiLFwiKS5maWx0ZXIoQm9vbGVhbikgfHwgbnVsbDtcbiAgICBjb25zdCBkZXZpZ01ldGhvZHM6IERldmlnTWV0aG9kW10gPSBkZXZpZ01ldGhvZHNQYXJhbSBcbiAgICAgID8gKGRldmlnTWV0aG9kc1BhcmFtLmZpbHRlcihtID0+IFtcInBvd2VyXCIsIFwibXVsdGlwbGljYXRpdmVcIiwgXCJhZGRpdGl2ZVwiLCBcInByb2JpdFwiXS5pbmNsdWRlcyhtKSkgYXMgRGV2aWdNZXRob2RbXSlcbiAgICAgIDogREVGQVVMVF9ERVZJR19NRVRIT0RTO1xuICAgIGNvbnN0IG1pbkVWID0gcGFyc2VGbG9hdChwYXJhbXMuZ2V0KFwibWluRVZcIikgfHwgXCIwXCIpO1xuICAgIGNvbnN0IG1heEVWID0gcGFyc2VGbG9hdChwYXJhbXMuZ2V0KFwibWF4RVZcIikgfHwgU3RyaW5nKEVWX1RIUkVTSE9MRFMubWF4aW11bSkpO1xuICAgIGNvbnN0IGJvb2tzRmlsdGVyID0gcGFyYW1zLmdldChcImJvb2tzXCIpPy50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiLFwiKS5maWx0ZXIoQm9vbGVhbikgfHwgbnVsbDtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKHBhcnNlSW50KHBhcmFtcy5nZXQoXCJsaW1pdFwiKSB8fCBcIjEwMFwiKSwgNTAwKTtcbiAgICBjb25zdCBtaW5Cb29rc1BlclNpZGUgPSBwYXJzZUludChwYXJhbXMuZ2V0KFwibWluQm9va3NQZXJTaWRlXCIpIHx8IFwiMlwiKTtcbiAgICBcbiAgICAvLyBDdXN0b20gc2hhcnAgYm9va3MgKGZvciB1c2VyJ3MgY3VzdG9tIG1vZGVscykgLSBFbGl0ZSBvbmx5XG4gICAgY29uc3QgY3VzdG9tU2hhcnBCb29rc1BhcmFtID0gcGFyYW1zLmdldChcImN1c3RvbVNoYXJwQm9va3NcIik/LnRvTG93ZXJDYXNlKCkuc3BsaXQoXCIsXCIpLmZpbHRlcihCb29sZWFuKSB8fCBudWxsO1xuICAgIGNvbnN0IGN1c3RvbUJvb2tXZWlnaHRzUGFyYW0gPSBwYXJhbXMuZ2V0KFwiY3VzdG9tQm9va1dlaWdodHNcIik7XG4gICAgbGV0IGN1c3RvbVNoYXJwQ29uZmlnOiBDdXN0b21TaGFycENvbmZpZyB8IG51bGwgPSBudWxsO1xuICAgIFxuICAgIGlmIChjdXN0b21TaGFycEJvb2tzUGFyYW0gJiYgY3VzdG9tU2hhcnBCb29rc1BhcmFtLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlQ2xpZW50KCk7XG4gICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICAgIGNvbnN0IHVzZXJQbGFuID0gYXdhaXQgZ2V0VXNlclBsYW4odXNlcik7XG4gICAgICBpZiAoIWhhc0VsaXRlQWNjZXNzKHVzZXJQbGFuKSkge1xuICAgICAgICByZXR1cm4ganNvbldpdGhIZWFkZXJzKFxuICAgICAgICAgIHsgZXJyb3I6IFwiQ3VzdG9tIG1vZGVscyByZXF1aXJlIEVsaXRlIHBsYW5cIiwgY29kZTogXCJlbGl0ZV9yZXF1aXJlZFwiIH0sXG4gICAgICAgICAgNDAzLFxuICAgICAgICAgIG9yaWdpblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbGV0IHdlaWdodHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gfCBudWxsID0gbnVsbDtcbiAgICAgIGlmIChjdXN0b21Cb29rV2VpZ2h0c1BhcmFtKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgd2VpZ2h0cyA9IEpTT04ucGFyc2UoY3VzdG9tQm9va1dlaWdodHNQYXJhbSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJbcG9zaXRpdmUtZXZdIEZhaWxlZCB0byBwYXJzZSBjdXN0b21Cb29rV2VpZ2h0cywgdXNpbmcgZXF1YWwgd2VpZ2h0c1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VzdG9tU2hhcnBDb25maWcgPSB7XG4gICAgICAgIGJvb2tzOiBjdXN0b21TaGFycEJvb2tzUGFyYW0sXG4gICAgICAgIHdlaWdodHMsXG4gICAgICB9O1xuICAgICAgY29uc29sZS5sb2coYFtwb3NpdGl2ZS1ldl0gVXNpbmcgY3VzdG9tIHNoYXJwIGNvbmZpZzogJHtjdXN0b21TaGFycEJvb2tzUGFyYW0uam9pbihcIiwgXCIpfWAsIHdlaWdodHMgPyBgd2l0aCB3ZWlnaHRzYCA6IGBlcXVhbCB3ZWlnaHRzYCk7XG4gICAgfVxuICAgIFxuICAgIC8vIE5vdGU6IG1vZGUgaXMgYWxyZWFkeSBwYXJzZWQgYWJvdmUgZm9yIGNhY2hlIGNoZWNrXG5cbiAgICAvLyBWYWxpZGF0ZSBzaGFycCBwcmVzZXQgKG9ubHkgaWYgbm90IHVzaW5nIGN1c3RvbSBjb25maWcpXG4gICAgaWYgKCFjdXN0b21TaGFycENvbmZpZyAmJiAhU0hBUlBfUFJFU0VUU1tzaGFycFByZXNldF0pIHtcbiAgICAgIHJldHVybiBqc29uV2l0aEhlYWRlcnMoeyBlcnJvcjogYEludmFsaWQgc2hhcnBQcmVzZXQ6ICR7c2hhcnBQcmVzZXR9YCB9LCA0MDAsIG9yaWdpbik7XG4gICAgfVxuXG4gICAgLy8gRmV0Y2ggb3Bwb3J0dW5pdGllcyBmb3IgYWxsIHNwb3J0cyBJTiBQQVJBTExFTCAobXVjaCBmYXN0ZXIhKVxuICAgIGNvbnNvbGUubG9nKGBbcG9zaXRpdmUtZXZdIEZldGNoaW5nICR7c3BvcnRzLmxlbmd0aH0gc3BvcnRzIGluIHBhcmFsbGVsLi4uYCk7XG4gICAgXG4gICAgY29uc3Qgc3BvcnRQcm9taXNlcyA9IHNwb3J0cy5tYXAoYXN5bmMgKHNwb3J0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBzcG9ydE9wcHMgPSBhd2FpdCBmZXRjaFBvc2l0aXZlRVZPcHBvcnR1bml0aWVzKFxuICAgICAgICAgIHNwb3J0LFxuICAgICAgICAgIG1hcmtldHMsXG4gICAgICAgICAgc2hhcnBQcmVzZXQsXG4gICAgICAgICAgZGV2aWdNZXRob2RzLFxuICAgICAgICAgIG1pbkVWLFxuICAgICAgICAgIG1heEVWLFxuICAgICAgICAgIGJvb2tzRmlsdGVyLFxuICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgbWluQm9va3NQZXJTaWRlLFxuICAgICAgICAgIGN1c3RvbVNoYXJwQ29uZmlnXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbcG9zaXRpdmUtZXZdIOKchSAke3Nwb3J0fTogJHtzcG9ydE9wcHMubGVuZ3RofSBvcHBzIGluICR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2ApO1xuICAgICAgICByZXR1cm4gc3BvcnRPcHBzO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW3Bvc2l0aXZlLWV2XSDinYwgJHtzcG9ydH0gZmFpbGVkOmAsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IpO1xuICAgICAgICByZXR1cm4gW107IC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvciwgZG9uJ3QgZmFpbCBlbnRpcmUgcmVxdWVzdFxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IHNwb3J0UmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHNwb3J0UHJvbWlzZXMpO1xuICAgIGNvbnN0IGFsbE9wcG9ydHVuaXRpZXMgPSBzcG9ydFJlc3VsdHMuZmxhdCgpO1xuXG4gICAgLy8gU29ydCBieSB3b3JzdC1jYXNlIEVWIChjb25zZXJ2YXRpdmUpIGRlc2NlbmRpbmdcbiAgICBhbGxPcHBvcnR1bml0aWVzLnNvcnQoKGEsIGIpID0+IGIuZXZDYWxjdWxhdGlvbnMuZXZXb3JzdCAtIGEuZXZDYWxjdWxhdGlvbnMuZXZXb3JzdCk7XG5cbiAgICAvLyBBcHBseSBsaW1pdFxuICAgIGNvbnN0IG9wcG9ydHVuaXRpZXMgPSBhbGxPcHBvcnR1bml0aWVzLnNsaWNlKDAsIGxpbWl0KTtcblxuICAgIGNvbnN0IHJlc3BvbnNlOiBQb3NpdGl2ZUVWUmVzcG9uc2UgPSB7XG4gICAgICBvcHBvcnR1bml0aWVzLFxuICAgICAgbWV0YToge1xuICAgICAgICB0b3RhbEZvdW5kOiBhbGxPcHBvcnR1bml0aWVzLmxlbmd0aCxcbiAgICAgICAgcmV0dXJuZWQ6IG9wcG9ydHVuaXRpZXMubGVuZ3RoLFxuICAgICAgICBzaGFycFByZXNldDogY3VzdG9tU2hhcnBDb25maWcgPyBcImN1c3RvbVwiIDogc2hhcnBQcmVzZXQsXG4gICAgICAgIGN1c3RvbVNoYXJwQ29uZmlnOiBjdXN0b21TaGFycENvbmZpZyB8fCB1bmRlZmluZWQsXG4gICAgICAgIGRldmlnTWV0aG9kcyxcbiAgICAgICAgbWluRVYsXG4gICAgICAgIG1pbkJvb2tzUGVyU2lkZSxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9LFxuICAgIH07XG5cbiAgICAvLyBMb2cgcmVzcG9uc2Ugc2l6ZSBmb3IgZGVidWdnaW5nXG4gICAgY29uc3QgcmVzcG9uc2VTaXplID0gSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpLmxlbmd0aDtcbiAgICBjb25zb2xlLmxvZyhgW3Bvc2l0aXZlLWV2XSBSZXNwb25zZSBzaXplOiAkeyhyZXNwb25zZVNpemUgLyAxMDI0KS50b0ZpeGVkKDIpfSBLQmApO1xuICAgIGlmIChyZXNwb25zZVNpemUgPiA1MDAwMDApIHsgLy8gNTAwS0Igd2FybmluZ1xuICAgICAgY29uc29sZS53YXJuKGBbcG9zaXRpdmUtZXZdIOKaoO+4jyAgTGFyZ2UgcmVzcG9uc2UgKCR7KHJlc3BvbnNlU2l6ZSAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpfSBNQilgKTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBpbiBSZWRpcyByZXNwb25zZSBjYWNoZSBmb3IgcXVpY2sgc3Vic2VxdWVudCByZXF1ZXN0c1xuICAgIC8vIEZpcmUgYW5kIGZvcmdldCAtIGRvbid0IGF3YWl0IHRvIGF2b2lkIHNsb3dpbmcgZG93biByZXNwb25zZVxuICAgIGNvbnN0IGlzQ3VzdG9tID0gaXNDdXN0b21Nb2RlbFJlcXVlc3QocGFyYW1zKTtcbiAgICBzZXRJblJlc3BvbnNlQ2FjaGUoY2FjaGVLZXksIHJlc3BvbnNlLCBpc0N1c3RvbSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbcG9zaXRpdmUtZXZdIEZhaWxlZCB0byBjYWNoZSByZXNwb25zZTpcIiwgZXJyKTtcbiAgICB9KTtcbiAgICBjb25zdCB0dGxVc2VkID0gaXNDdXN0b20gPyBSRVNQT05TRV9DQUNIRV9UVExfQ1VTVE9NIDogUkVTUE9OU0VfQ0FDSEVfVFRMX1BSRVNFVDtcbiAgICBjb25zb2xlLmxvZyhgW3Bvc2l0aXZlLWV2XSBDYWNoZSBNSVNTIC0gc3RvcmluZyBpbiBSZWRpcyAoVFRMOiAke3R0bFVzZWR9cywgdG90YWwgdGltZTogJHtEYXRlLm5vdygpIC0gc3RhcnRUaW1lfW1zKWApO1xuXG4gICAgcmV0dXJuIGpzb25XaXRoSGVhZGVycyhyZXNwb25zZSwgMjAwLCBvcmlnaW4sIHtcbiAgICAgIFwiQ2FjaGUtQ29udHJvbFwiOiBcInByaXZhdGUsIG1heC1hZ2U9MTVcIixcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgXCJYLUNhY2hlXCI6IFwiTUlTU1wiLFxuICAgICAgXCJYLUNhY2hlLVNvdXJjZVwiOiBcInJlZGlzXCIsXG4gICAgICBcIlgtTW9kZVwiOiBtb2RlXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlsvYXBpL3YyL3Bvc2l0aXZlLWV2XSBFcnJvcjpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBqc29uV2l0aEhlYWRlcnMoXG4gICAgICB7IGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiLCB0aW1pbmdfbXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUgfSxcbiAgICAgIDUwMCxcbiAgICAgIG9yaWdpblxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIE9QVElPTlMocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgcmV0dXJuIG5ldyBOZXh0UmVzcG9uc2UobnVsbCwge1xuICAgIHN0YXR1czogMjA0LFxuICAgIGhlYWRlcnM6IGdldENvcnNIZWFkZXJzKHJlcXVlc3QuaGVhZGVycy5nZXQoXCJvcmlnaW5cIikpXG4gIH0pO1xufVxuXG4vKipcbiAqIEZldGNoICtFViBvcHBvcnR1bml0aWVzIGZvciBhIHNpbmdsZSBzcG9ydFxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFBvc2l0aXZlRVZPcHBvcnR1bml0aWVzKFxuICBzcG9ydDogc3RyaW5nLFxuICBtYXJrZXRzOiBzdHJpbmdbXSB8IG51bGwsXG4gIHNoYXJwUHJlc2V0OiBTaGFycFByZXNldCxcbiAgZGV2aWdNZXRob2RzOiBEZXZpZ01ldGhvZFtdLFxuICBtaW5FVjogbnVtYmVyLFxuICBtYXhFVjogbnVtYmVyLFxuICBib29rc0ZpbHRlcjogc3RyaW5nW10gfCBudWxsLFxuICBtb2RlOiBFVk1vZGUsXG4gIG1pbkJvb2tzUGVyU2lkZTogbnVtYmVyLFxuICBjdXN0b21TaGFycENvbmZpZzogQ3VzdG9tU2hhcnBDb25maWcgfCBudWxsID0gbnVsbFxuKTogUHJvbWlzZTxQb3NpdGl2ZUVWT3Bwb3J0dW5pdHlbXT4ge1xuICBjb25zdCBvcHBvcnR1bml0aWVzOiBQb3NpdGl2ZUVWT3Bwb3J0dW5pdHlbXSA9IFtdO1xuICBjb25zdCBwYWlyTWFwID0gbmV3IE1hcDxzdHJpbmcsIFNlbGVjdGlvblBhaXI+KCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBTdGVwIDE6IEdldCBhY3RpdmUgZXZlbnRzXG4gICAgY29uc3QgZXZlbnRJZHMgPSBhd2FpdCBnZXRBY3RpdmVFdmVudElkcyhzcG9ydCk7XG4gICAgaWYgKGV2ZW50SWRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuXG4gICAgLy8gU3RlcCAyOiBHZXQgb2RkcyBrZXlzXG4gICAgY29uc3QgYWxsT2Rkc0tleXMgPSBhd2FpdCBnZXRPZGRzS2V5c0ZvckV2ZW50cyhzcG9ydCwgZXZlbnRJZHMpO1xuICAgIGlmIChhbGxPZGRzS2V5cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICAgIC8vIEZpbHRlciBrZXlzIGJ5IGV2ZW50IGFuZCBtYXJrZXRcbiAgICBjb25zdCBldmVudElkU2V0ID0gbmV3IFNldChldmVudElkcyk7XG4gICAgY29uc3QgZmlsdGVyZWRLZXlzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gSGVscGVyIHRvIGNoZWNrIGlmIG1hcmtldCBpcyBhbGxvd2VkIChzdXBwb3J0cyBjb21wb3NpdGUga2V5cyBsaWtlIFwibmJhOnBsYXllcl9wb2ludHNcIilcbiAgICBjb25zdCBpc01hcmtldEFsbG93ZWQgPSAobWFya2V0OiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgIGlmICghbWFya2V0cykgcmV0dXJuIHRydWU7IC8vIE5vIGZpbHRlciA9IGFsbCBhbGxvd2VkXG4gICAgICAvLyBDaGVjayBjb21wb3NpdGUga2V5IChzcG9ydC1zcGVjaWZpYylcbiAgICAgIGlmIChtYXJrZXRzLmluY2x1ZGVzKGAke3Nwb3J0fToke21hcmtldH1gKSkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBDaGVjayBwbGFpbiBrZXkgKGdsb2JhbCAvIGJhY2t3YXJkcyBjb21wYXQpXG4gICAgICBpZiAobWFya2V0cy5pbmNsdWRlcyhtYXJrZXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgYWxsT2Rkc0tleXMpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KFwiOlwiKTtcbiAgICAgIGNvbnN0IGV2ZW50SWQgPSBwYXJ0c1syXTtcbiAgICAgIGNvbnN0IG1hcmtldCA9IHBhcnRzWzNdO1xuICAgICAgY29uc3QgYm9vayA9IHBhcnRzWzRdO1xuXG4gICAgICBpZiAoIWV2ZW50SWQgfHwgIW1hcmtldCB8fCAhYm9vaykgY29udGludWU7XG4gICAgICBpZiAoIWV2ZW50SWRTZXQuaGFzKGV2ZW50SWQpKSBjb250aW51ZTtcbiAgICAgIGlmICghaXNNYXJrZXRBbGxvd2VkKG1hcmtldCkpIGNvbnRpbnVlO1xuXG4gICAgICBmaWx0ZXJlZEtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGlmIChmaWx0ZXJlZEtleXMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG5cbiAgICAvLyBTdGVwIDM6IEJhdGNoIGZldGNoIGFsbCBvZGRzIGRhdGFcbiAgICBjb25zdCBjaHVua3M6IHN0cmluZ1tdW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmVkS2V5cy5sZW5ndGg7IGkgKz0gTUdFVF9DSFVOS19TSVpFKSB7XG4gICAgICBjaHVua3MucHVzaChmaWx0ZXJlZEtleXMuc2xpY2UoaSwgaSArIE1HRVRfQ0hVTktfU0laRSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGNodW5rUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgY2h1bmtzLm1hcCgoY2h1bmspID0+IHJlZGlzLm1nZXQ8KFNTRUJvb2tTZWxlY3Rpb25zIHwgc3RyaW5nIHwgbnVsbClbXT4oLi4uY2h1bmspKVxuICAgICk7XG4gICAgY29uc3QgYWxsT2Rkc0RhdGEgPSBjaHVua1Jlc3VsdHMuZmxhdCgpO1xuXG4gICAgLy8gQnVpbGQga2V5IC0+IGRhdGEgbWFwXG4gICAgY29uc3Qgb2Rkc0RhdGFNYXAgPSBuZXcgTWFwPHN0cmluZywgU1NFQm9va1NlbGVjdGlvbnM+KCk7XG4gICAgZmlsdGVyZWRLZXlzLmZvckVhY2goKGtleSwgaSkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IGFsbE9kZHNEYXRhW2ldO1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgb2Rkc0RhdGFNYXAuc2V0KGtleSwgdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGRhdGEpIDogZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTdGVwIDQ6IEZldGNoIGV2ZW50IGRldGFpbHNcbiAgICBjb25zdCBldmVudEtleXMgPSBldmVudElkcy5tYXAoKGlkKSA9PiBgZXZlbnRzOiR7c3BvcnR9OiR7aWR9YCk7XG4gICAgY29uc3QgZXZlbnRzUmF3ID0gYXdhaXQgcmVkaXMubWdldDwoUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsKVtdPiguLi5ldmVudEtleXMpO1xuXG4gICAgLy8gQnVpbGQgZXZlbnQgbWFwIHdpdGggcm9idXN0IGZpbHRlcmluZ1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgU0lYX0hPVVJTX01TID0gNiAqIDYwICogNjAgKiAxMDAwOyAvLyA2IGhvdXJzIGluIG1pbGxpc2Vjb25kc1xuICAgIGNvbnN0IGV2ZW50TWFwID0gbmV3IE1hcDxzdHJpbmcsIHsgaG9tZV90ZWFtOiBzdHJpbmc7IGF3YXlfdGVhbTogc3RyaW5nOyBzdGFydF90aW1lOiBzdHJpbmc7IGlzTGl2ZTogYm9vbGVhbiB9PigpO1xuICAgIGNvbnN0IHByZWdhbWVFdmVudElkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGxpdmVFdmVudElkcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGV4Y2x1ZGVkRXZlbnRJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTsgLy8gVHJhY2sgZXZlbnRzIHRvIGV4Y2x1ZGUgY29tcGxldGVseVxuXG4gICAgZXZlbnRJZHMuZm9yRWFjaCgoaWQsIGkpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRzUmF3W2ldO1xuICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAvLyBObyBldmVudCBkYXRhIC0gZXhjbHVkZVxuICAgICAgICBleGNsdWRlZEV2ZW50SWRzLmFkZChpZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gKGV2ZW50LmNvbW1lbmNlX3RpbWUgYXMgc3RyaW5nKSB8fCAoZXZlbnQuc3RhcnRfdGltZSBhcyBzdHJpbmcpIHx8IFwiXCI7XG4gICAgICBjb25zdCBpc0xpdmVGbGFnID0gZXZlbnQuaXNfbGl2ZSA9PT0gdHJ1ZTtcbiAgICAgIGNvbnN0IGhvbWVUZWFtID0gKGV2ZW50LmhvbWVfdGVhbSBhcyBzdHJpbmcpIHx8IFwiXCI7XG4gICAgICBjb25zdCBhd2F5VGVhbSA9IChldmVudC5hd2F5X3RlYW0gYXMgc3RyaW5nKSB8fCBcIlwiO1xuICAgICAgXG4gICAgICAvLyBTa2lwIGV2ZW50cyB3aXRob3V0IHZhbGlkIHRlYW0gZGF0YVxuICAgICAgaWYgKCFob21lVGVhbSB8fCAhYXdheVRlYW0pIHtcbiAgICAgICAgZXhjbHVkZWRFdmVudElkcy5hZGQoaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJvYnVzdCB0aW1lIHZhbGlkYXRpb25cbiAgICAgIGlmICghc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIE5vIHN0YXJ0IHRpbWUgLSBleGNsdWRlIChsaWtlbHkgc3RhbGUgZGF0YSAvIFRCRCBpc3N1ZSlcbiAgICAgICAgZXhjbHVkZWRFdmVudElkcy5hZGQoaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdhbWVTdGFydCA9IG5ldyBEYXRlKHN0YXJ0VGltZSk7XG4gICAgICBpZiAoaXNOYU4oZ2FtZVN0YXJ0LmdldFRpbWUoKSkpIHtcbiAgICAgICAgLy8gSW52YWxpZCBkYXRlIC0gZXhjbHVkZVxuICAgICAgICBleGNsdWRlZEV2ZW50SWRzLmFkZChpZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgZ2FtZSBzdGFydGVkIG1vcmUgdGhhbiA2IGhvdXJzIGFnbyAoZGVmaW5pdGVseSBmaW5pc2hlZClcbiAgICAgIGNvbnN0IG1zU2luY2VTdGFydCA9IG5vdy5nZXRUaW1lKCkgLSBnYW1lU3RhcnQuZ2V0VGltZSgpO1xuICAgICAgaWYgKG1zU2luY2VTdGFydCA+IFNJWF9IT1VSU19NUykge1xuICAgICAgICAvLyBHYW1lIGlzIGxpa2VseSBvdmVyIC0gZXhjbHVkZVxuICAgICAgICBleGNsdWRlZEV2ZW50SWRzLmFkZChpZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIGxpdmUgb3IgcHJlZ2FtZVxuICAgICAgY29uc3QgaXNMaXZlID0gaXNMaXZlRmxhZyB8fCBnYW1lU3RhcnQgPD0gbm93O1xuICAgICAgXG4gICAgICBpZiAoaXNMaXZlKSB7XG4gICAgICAgIGxpdmVFdmVudElkcy5hZGQoaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZ2FtZUV2ZW50SWRzLmFkZChpZCk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50TWFwLnNldChpZCwgeyBcbiAgICAgICAgaG9tZV90ZWFtOiBob21lVGVhbSwgXG4gICAgICAgIGF3YXlfdGVhbTogYXdheVRlYW0sIFxuICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUsXG4gICAgICAgIGlzTGl2ZSBcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gU3RlcCA1OiBCdWlsZCBzZWxlY3Rpb24gcGFpcnNcbiAgICBjb25zdCBrZXlzQnlFdmVudE1hcmtldCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmdbXT4oKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBmaWx0ZXJlZEtleXMpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KFwiOlwiKTtcbiAgICAgIGNvbnN0IGV2ZW50SWQgPSBwYXJ0c1syXTtcbiAgICAgIGNvbnN0IG1hcmtldCA9IHBhcnRzWzNdO1xuICAgICAgY29uc3QgZ3JvdXBLZXkgPSBgJHtldmVudElkfToke21hcmtldH1gO1xuICAgICAgaWYgKCFrZXlzQnlFdmVudE1hcmtldC5oYXMoZ3JvdXBLZXkpKSB7XG4gICAgICAgIGtleXNCeUV2ZW50TWFya2V0LnNldChncm91cEtleSwgW10pO1xuICAgICAgfVxuICAgICAga2V5c0J5RXZlbnRNYXJrZXQuZ2V0KGdyb3VwS2V5KSEucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2dyb3VwS2V5LCBtYXJrZXRLZXlzXSBvZiBrZXlzQnlFdmVudE1hcmtldCkge1xuICAgICAgY29uc3QgW2V2ZW50SWQsIG1hcmtldF0gPSBncm91cEtleS5zcGxpdChcIjpcIik7XG4gICAgICBcbiAgICAgIC8vIFNraXAgZXhjbHVkZWQgZXZlbnRzIChubyBkYXRhLCBpbnZhbGlkIHRpbWUsIG9yIGZpbmlzaGVkIGdhbWVzKVxuICAgICAgaWYgKGV4Y2x1ZGVkRXZlbnRJZHMuaGFzKGV2ZW50SWQpKSBjb250aW51ZTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgbW9kZSBmaWx0ZXJcbiAgICAgIGlmIChtb2RlID09PSBcInByZWdhbWVcIiAmJiBsaXZlRXZlbnRJZHMuaGFzKGV2ZW50SWQpKSBjb250aW51ZTsgLy8gU2tpcCBsaXZlIGluIHByZWdhbWUgbW9kZVxuICAgICAgaWYgKG1vZGUgPT09IFwibGl2ZVwiICYmIHByZWdhbWVFdmVudElkcy5oYXMoZXZlbnRJZCkpIGNvbnRpbnVlOyAvLyBTa2lwIHByZWdhbWUgaW4gbGl2ZSBtb2RlXG4gICAgICAvLyBtb2RlID09PSBcImFsbFwiIHNob3dzIGJvdGhcblxuICAgICAgY29uc3QgZXZlbnREYXRhID0gZXZlbnRNYXAuZ2V0KGV2ZW50SWQpO1xuICAgICAgY29uc3QgZXZlbnQgPSBldmVudERhdGEgPyB7IFxuICAgICAgICBob21lX3RlYW06IGV2ZW50RGF0YS5ob21lX3RlYW0sIFxuICAgICAgICBhd2F5X3RlYW06IGV2ZW50RGF0YS5hd2F5X3RlYW0sIFxuICAgICAgICBzdGFydF90aW1lOiBldmVudERhdGEuc3RhcnRfdGltZSBcbiAgICAgIH0gOiBudWxsO1xuXG4gICAgICAvLyBCdWlsZCBib29rIHNlbGVjdGlvbnNcbiAgICAgIGNvbnN0IGJvb2tTZWxlY3Rpb25zOiBSZWNvcmQ8c3RyaW5nLCBTU0VCb29rU2VsZWN0aW9ucz4gPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIG1hcmtldEtleXMpIHtcbiAgICAgICAgY29uc3QgcmF3Qm9vayA9IGtleS5zcGxpdChcIjpcIikucG9wKCkhO1xuICAgICAgICBjb25zdCBib29rID0gbm9ybWFsaXplQm9va0lkKHJhd0Jvb2spO1xuICAgICAgICBjb25zdCBkYXRhID0gb2Rkc0RhdGFNYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgYm9va1NlbGVjdGlvbnNbYm9va10gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB1bmlxdWUgYmFzZSBzZWxlY3Rpb24ga2V5c1xuICAgICAgLy8gRm9yIHRlYW1fdG90YWwgbWFya2V0LCB3ZSBuZWVkIHRvIGRpZmZlcmVudGlhdGUgaG9tZSB2cyBhd2F5IHRlYW1zXG4gICAgICBjb25zdCBiYXNlU2VsZWN0aW9uS2V5cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgZm9yIChjb25zdCBzZWxlY3Rpb25zIG9mIE9iamVjdC52YWx1ZXMoYm9va1NlbGVjdGlvbnMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgc2VsXSBvZiBPYmplY3QuZW50cmllcyhzZWxlY3Rpb25zKSkge1xuICAgICAgICAgIGNvbnN0IFtwbGF5ZXJSYXcsICwgbGluZVN0cl0gPSBrZXkuc3BsaXQoXCJ8XCIpO1xuICAgICAgICAgIGlmIChwbGF5ZXJSYXcgJiYgbGluZVN0cikge1xuICAgICAgICAgICAgLy8gRm9yIHRlYW1fdG90YWwgbWFya2V0cywgaW5jbHVkZSBob21lL2F3YXkgZGVzaWduYXRpb24gZnJvbSByYXdfbWFya2V0XG4gICAgICAgICAgICBpZiAobWFya2V0ID09PSBcInRlYW1fdG90YWxcIiAmJiBzZWwgJiYgdHlwZW9mIHNlbCA9PT0gXCJvYmplY3RcIiAmJiBcInJhd19tYXJrZXRcIiBpbiBzZWwpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmF3TWFya2V0ID0gKHNlbCBhcyBTU0VTZWxlY3Rpb24pLnJhd19tYXJrZXQgfHwgXCJcIjtcbiAgICAgICAgICAgICAgY29uc3QgdGVhbVNpZGUgPSByYXdNYXJrZXQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcImhvbWVcIikgPyBcImhvbWVcIiBcbiAgICAgICAgICAgICAgICA6IHJhd01hcmtldC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiYXdheVwiKSA/IFwiYXdheVwiIFxuICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgICAgaWYgKHRlYW1TaWRlKSB7XG4gICAgICAgICAgICAgICAgYmFzZVNlbGVjdGlvbktleXMuYWRkKGAke3BsYXllclJhd318JHtsaW5lU3RyfXwke3RlYW1TaWRlfWApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhc2VTZWxlY3Rpb25LZXlzLmFkZChgJHtwbGF5ZXJSYXd9fCR7bGluZVN0cn18YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJhc2VTZWxlY3Rpb25LZXlzLmFkZChgJHtwbGF5ZXJSYXd9fCR7bGluZVN0cn18YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBwbGF5ZXIvbGluZSBwYWlyXG4gICAgICBmb3IgKGNvbnN0IGJhc2VLZXkgb2YgYmFzZVNlbGVjdGlvbktleXMpIHtcbiAgICAgICAgY29uc3QgW3BsYXllclJhdywgbGluZVN0ciwgdGVhbVNpZGVdID0gYmFzZUtleS5zcGxpdChcInxcIik7XG4gICAgICAgIGNvbnN0IHBsYXllciA9IG5vcm1hbGl6ZVBsYXllck5hbWUocGxheWVyUmF3KTtcbiAgICAgICAgY29uc3QgbGluZSA9IHBhcnNlRmxvYXQobGluZVN0cik7XG4gICAgICAgIC8vIEluY2x1ZGUgdGVhbVNpZGUgaW4gcGFpciBrZXkgZm9yIHRlYW1fdG90YWwgbWFya2V0cyB0byBzZXBhcmF0ZSBob21lL2F3YXlcbiAgICAgICAgY29uc3QgcGFpcktleSA9IHRlYW1TaWRlIFxuICAgICAgICAgID8gYCR7ZXZlbnRJZH06JHttYXJrZXR9OiR7cGxheWVyfToke2xpbmV9OiR7dGVhbVNpZGV9YFxuICAgICAgICAgIDogYCR7ZXZlbnRJZH06JHttYXJrZXR9OiR7cGxheWVyfToke2xpbmV9YDtcblxuICAgICAgICBsZXQgcGFpciA9IHBhaXJNYXAuZ2V0KHBhaXJLZXkpO1xuICAgICAgICBpZiAoIXBhaXIpIHtcbiAgICAgICAgICBwYWlyID0ge1xuICAgICAgICAgICAgc3BvcnQsXG4gICAgICAgICAgICBldmVudElkLFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBwbGF5ZXIsXG4gICAgICAgICAgICBwbGF5ZXJEaXNwbGF5OiBcIlwiLFxuICAgICAgICAgICAgcGxheWVySWQ6IG51bGwsXG4gICAgICAgICAgICB0ZWFtOiBudWxsLFxuICAgICAgICAgICAgcG9zaXRpb246IG51bGwsXG4gICAgICAgICAgICBtYXJrZXQsXG4gICAgICAgICAgICBtYXJrZXREaXNwbGF5OiBcIlwiLFxuICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgIG92ZXI6IHsgYm9va3M6IFtdLCBiZXN0OiBudWxsIH0sXG4gICAgICAgICAgICB1bmRlcjogeyBib29rczogW10sIGJlc3Q6IG51bGwgfSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHBhaXJNYXAuc2V0KHBhaXJLZXksIHBhaXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVscGVyIHRvIGNoZWNrIGlmIGEgc2VsZWN0aW9uIG1hdGNoZXMgdGhlIGV4cGVjdGVkIHRlYW0gc2lkZSAoZm9yIHRlYW1fdG90YWwgbWFya2V0cylcbiAgICAgICAgY29uc3QgbWF0Y2hlc1RlYW1TaWRlID0gKHNlbDogU1NFU2VsZWN0aW9uIHwgdW5kZWZpbmVkKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgaWYgKCF0ZWFtU2lkZSB8fCBtYXJrZXQgIT09IFwidGVhbV90b3RhbFwiKSByZXR1cm4gdHJ1ZTsgLy8gTm8gZmlsdGVyaW5nIG5lZWRlZFxuICAgICAgICAgIGlmICghc2VsPy5yYXdfbWFya2V0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcmF3TWFya2V0ID0gc2VsLnJhd19tYXJrZXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAodGVhbVNpZGUgPT09IFwiaG9tZVwiKSByZXR1cm4gcmF3TWFya2V0LmluY2x1ZGVzKFwiaG9tZVwiKTtcbiAgICAgICAgICBpZiAodGVhbVNpZGUgPT09IFwiYXdheVwiKSByZXR1cm4gcmF3TWFya2V0LmluY2x1ZGVzKFwiYXdheVwiKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHYXRoZXIgcHJpY2VzIGZyb20gYWxsIGJvb2tzXG4gICAgICAgIGZvciAoY29uc3QgW2Jvb2ssIHNlbGVjdGlvbnNdIG9mIE9iamVjdC5lbnRyaWVzKGJvb2tTZWxlY3Rpb25zKSkge1xuICAgICAgICAgIGlmIChFWENMVURFRF9CT09LUy5oYXMoYm9vay50b0xvd2VyQ2FzZSgpKSkgY29udGludWU7XG5cbiAgICAgICAgICAvLyBDaGVjayBvdmVyL3llcy9tbFxuICAgICAgICAgIGNvbnN0IG92ZXJLZXkgPSBgJHtwbGF5ZXJSYXd9fG92ZXJ8JHtsaW5lU3RyfWA7XG4gICAgICAgICAgY29uc3QgeWVzS2V5ID0gYCR7cGxheWVyUmF3fXx5ZXN8JHtsaW5lU3RyfWA7XG4gICAgICAgICAgY29uc3QgbWxLZXkgPSBgJHtwbGF5ZXJSYXd9fG1sfCR7bGluZVN0cn1gO1xuICAgICAgICAgIGNvbnN0IG92ZXJTZWwgPSAoc2VsZWN0aW9uc1tvdmVyS2V5XSB8fCBzZWxlY3Rpb25zW3llc0tleV0gfHwgc2VsZWN0aW9uc1ttbEtleV0pIGFzIFNTRVNlbGVjdGlvbiB8IHVuZGVmaW5lZDtcblxuICAgICAgICAgIC8vIEZvciB0ZWFtX3RvdGFsIG1hcmtldHMsIG9ubHkgaW5jbHVkZSBzZWxlY3Rpb25zIHRoYXQgbWF0Y2ggdGhlIHRlYW0gc2lkZVxuICAgICAgICAgIGlmIChvdmVyU2VsICYmICFvdmVyU2VsLmxvY2tlZCAmJiBtYXRjaGVzVGVhbVNpZGUob3ZlclNlbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJQcmljZSA9IHBhcnNlSW50KFN0cmluZyhvdmVyU2VsLnByaWNlKSwgMTApO1xuICAgICAgICAgICAgLy8gRGVidWc6IExvZyB3aGVuIGxpbWl0cyBkYXRhIGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChvdmVyU2VsLmxpbWl0cz8ubWF4KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbcG9zaXRpdmUtZXZdIExpbWl0cyBmb3VuZDogJHtib29rfSAtIE1heCAkJHtvdmVyU2VsLmxpbWl0cy5tYXh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBib29rT2ZmZXI6IEJvb2tPZmZlciA9IHtcbiAgICAgICAgICAgICAgYm9va0lkOiBib29rLFxuICAgICAgICAgICAgICBib29rTmFtZTogYm9vayxcbiAgICAgICAgICAgICAgcHJpY2U6IG92ZXJQcmljZSxcbiAgICAgICAgICAgICAgcHJpY2VEZWNpbWFsOiBvdmVyU2VsLnByaWNlX2RlY2ltYWwsXG4gICAgICAgICAgICAgIGxpbms6IG92ZXJTZWwubGluayB8fCBudWxsLFxuICAgICAgICAgICAgICBtb2JpbGVMaW5rOiBvdmVyU2VsLm1vYmlsZV9saW5rIHx8IG51bGwsXG4gICAgICAgICAgICAgIHNncDogb3ZlclNlbC5zZ3AgfHwgbnVsbCxcbiAgICAgICAgICAgICAgbGltaXRzOiBvdmVyU2VsLmxpbWl0cyB8fCBudWxsLFxuICAgICAgICAgICAgICB1cGRhdGVkOiBvdmVyU2VsLnVwZGF0ZWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhaXIub3Zlci5ib29rcy5wdXNoKGJvb2tPZmZlcik7XG4gICAgICAgICAgICBpZiAoIXBhaXIub3Zlci5iZXN0IHx8IG92ZXJTZWwucHJpY2VfZGVjaW1hbCA+IHBhaXIub3Zlci5iZXN0LnByaWNlRGVjaW1hbCkge1xuICAgICAgICAgICAgICBwYWlyLm92ZXIuYmVzdCA9IGJvb2tPZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdmVyU2VsLnBsYXllciAmJiAhcGFpci5wbGF5ZXJEaXNwbGF5KSBwYWlyLnBsYXllckRpc3BsYXkgPSBvdmVyU2VsLnBsYXllcjtcbiAgICAgICAgICAgIGlmIChvdmVyU2VsLnBsYXllcl9pZCAmJiAhcGFpci5wbGF5ZXJJZCkgcGFpci5wbGF5ZXJJZCA9IG92ZXJTZWwucGxheWVyX2lkO1xuICAgICAgICAgICAgaWYgKG92ZXJTZWwudGVhbSAmJiAhcGFpci50ZWFtKSBwYWlyLnRlYW0gPSBvdmVyU2VsLnRlYW07XG4gICAgICAgICAgICBpZiAob3ZlclNlbC5wb3NpdGlvbiAmJiAhcGFpci5wb3NpdGlvbikgcGFpci5wb3NpdGlvbiA9IGZvcm1hdFBvc2l0aW9uKG92ZXJTZWwucG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKG92ZXJTZWwucmF3X21hcmtldCAmJiAhcGFpci5tYXJrZXREaXNwbGF5KSBwYWlyLm1hcmtldERpc3BsYXkgPSBub3JtYWxpemVSYXdNYXJrZXQob3ZlclNlbC5yYXdfbWFya2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDaGVjayB1bmRlci9ub1xuICAgICAgICAgIGNvbnN0IHVuZGVyS2V5ID0gYCR7cGxheWVyUmF3fXx1bmRlcnwke2xpbmVTdHJ9YDtcbiAgICAgICAgICBjb25zdCBub0tleSA9IGAke3BsYXllclJhd318bm98JHtsaW5lU3RyfWA7XG4gICAgICAgICAgY29uc3QgdW5kZXJTZWwgPSAoc2VsZWN0aW9uc1t1bmRlcktleV0gfHwgc2VsZWN0aW9uc1tub0tleV0pIGFzIFNTRVNlbGVjdGlvbiB8IHVuZGVmaW5lZDtcblxuICAgICAgICAgIC8vIEZvciB0ZWFtX3RvdGFsIG1hcmtldHMsIG9ubHkgaW5jbHVkZSBzZWxlY3Rpb25zIHRoYXQgbWF0Y2ggdGhlIHRlYW0gc2lkZVxuICAgICAgICAgIGlmICh1bmRlclNlbCAmJiAhdW5kZXJTZWwubG9ja2VkICYmIG1hdGNoZXNUZWFtU2lkZSh1bmRlclNlbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuZGVyUHJpY2UgPSBwYXJzZUludChTdHJpbmcodW5kZXJTZWwucHJpY2UpLCAxMCk7XG4gICAgICAgICAgICAvLyBEZWJ1ZzogTG9nIHdoZW4gbGltaXRzIGRhdGEgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHVuZGVyU2VsLmxpbWl0cz8ubWF4KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbcG9zaXRpdmUtZXZdIExpbWl0cyBmb3VuZDogJHtib29rfSAtIE1heCAkJHt1bmRlclNlbC5saW1pdHMubWF4fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm9va09mZmVyOiBCb29rT2ZmZXIgPSB7XG4gICAgICAgICAgICAgIGJvb2tJZDogYm9vayxcbiAgICAgICAgICAgICAgYm9va05hbWU6IGJvb2ssXG4gICAgICAgICAgICAgIHByaWNlOiB1bmRlclByaWNlLFxuICAgICAgICAgICAgICBwcmljZURlY2ltYWw6IHVuZGVyU2VsLnByaWNlX2RlY2ltYWwsXG4gICAgICAgICAgICAgIGxpbms6IHVuZGVyU2VsLmxpbmsgfHwgbnVsbCxcbiAgICAgICAgICAgICAgbW9iaWxlTGluazogdW5kZXJTZWwubW9iaWxlX2xpbmsgfHwgbnVsbCxcbiAgICAgICAgICAgICAgc2dwOiB1bmRlclNlbC5zZ3AgfHwgbnVsbCxcbiAgICAgICAgICAgICAgbGltaXRzOiB1bmRlclNlbC5saW1pdHMgfHwgbnVsbCxcbiAgICAgICAgICAgICAgdXBkYXRlZDogdW5kZXJTZWwudXBkYXRlZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcGFpci51bmRlci5ib29rcy5wdXNoKGJvb2tPZmZlcik7XG4gICAgICAgICAgICBpZiAoIXBhaXIudW5kZXIuYmVzdCB8fCB1bmRlclNlbC5wcmljZV9kZWNpbWFsID4gcGFpci51bmRlci5iZXN0LnByaWNlRGVjaW1hbCkge1xuICAgICAgICAgICAgICBwYWlyLnVuZGVyLmJlc3QgPSBib29rT2ZmZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZXJTZWwucGxheWVyICYmICFwYWlyLnBsYXllckRpc3BsYXkpIHBhaXIucGxheWVyRGlzcGxheSA9IHVuZGVyU2VsLnBsYXllcjtcbiAgICAgICAgICAgIGlmICh1bmRlclNlbC5wbGF5ZXJfaWQgJiYgIXBhaXIucGxheWVySWQpIHBhaXIucGxheWVySWQgPSB1bmRlclNlbC5wbGF5ZXJfaWQ7XG4gICAgICAgICAgICBpZiAodW5kZXJTZWwudGVhbSAmJiAhcGFpci50ZWFtKSBwYWlyLnRlYW0gPSB1bmRlclNlbC50ZWFtO1xuICAgICAgICAgICAgaWYgKHVuZGVyU2VsLnBvc2l0aW9uICYmICFwYWlyLnBvc2l0aW9uKSBwYWlyLnBvc2l0aW9uID0gZm9ybWF0UG9zaXRpb24odW5kZXJTZWwucG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHVuZGVyU2VsLnJhd19tYXJrZXQgJiYgIXBhaXIubWFya2V0RGlzcGxheSkgcGFpci5tYXJrZXREaXNwbGF5ID0gbm9ybWFsaXplUmF3TWFya2V0KHVuZGVyU2VsLnJhd19tYXJrZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgNjogQ2FsY3VsYXRlICtFViBmb3IgZWFjaCBwYWlyXG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJNYXAudmFsdWVzKCkpIHtcbiAgICAgIC8vIE5lZWQgbWluaW11bSBib29rcyBvbiBib3RoIHNpZGVzIGZvciBwcm9wZXIgZGUtdmlnZ2luZyAod2lkdGggZmlsdGVyKVxuICAgICAgaWYgKHBhaXIub3Zlci5ib29rcy5sZW5ndGggPCBtaW5Cb29rc1BlclNpZGUgfHwgcGFpci51bmRlci5ib29rcy5sZW5ndGggPCBtaW5Cb29rc1BlclNpZGUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBHZXQgc2hhcnAgcmVmZXJlbmNlIG9kZHMgKHVzZSBjdXN0b20gY29uZmlnIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgdXNlIHByZXNldClcbiAgICAgIGNvbnN0IHNoYXJwT3ZlciA9IGN1c3RvbVNoYXJwQ29uZmlnIFxuICAgICAgICA/IGdldFNoYXJwT2Rkc0ZvckN1c3RvbUNvbmZpZyhwYWlyLm92ZXIuYm9va3MsIGN1c3RvbVNoYXJwQ29uZmlnKVxuICAgICAgICA6IGdldFNoYXJwT2Rkc0ZvclByZXNldChwYWlyLm92ZXIuYm9va3MsIHNoYXJwUHJlc2V0KTtcbiAgICAgIGNvbnN0IHNoYXJwVW5kZXIgPSBjdXN0b21TaGFycENvbmZpZ1xuICAgICAgICA/IGdldFNoYXJwT2Rkc0ZvckN1c3RvbUNvbmZpZyhwYWlyLnVuZGVyLmJvb2tzLCBjdXN0b21TaGFycENvbmZpZylcbiAgICAgICAgOiBnZXRTaGFycE9kZHNGb3JQcmVzZXQocGFpci51bmRlci5ib29rcywgc2hhcnBQcmVzZXQpO1xuXG4gICAgICBpZiAoIXNoYXJwT3ZlciB8fCAhc2hhcnBVbmRlcikgY29udGludWU7XG5cbiAgICAgIC8vIEluIGN1c3RvbSBtb2RlbCBtb2RlLCBlbmZvcmNlIG1pbi1ib29rcyBhZ2FpbnN0IHRoZSBhY3R1YWxcbiAgICAgIC8vIHJlZmVyZW5jZSBib29rcyB0aGF0IGNvbnRyaWJ1dGVkIG9uIEJPVEggc2lkZXMgYWZ0ZXIgZXhjbHVzaW9ucy5cbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBvbmx5IHN1cmZhY2Ugcm93cyB3aXRoIGVub3VnaCB0cnVlIHBhaXJlZCByZWZzLlxuICAgICAgaWYgKGN1c3RvbVNoYXJwQ29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHNoYXJwT3ZlclJlZnMgPSBuZXcgU2V0KHNoYXJwT3Zlci5ibGVuZGVkRnJvbSA/PyBbc2hhcnBPdmVyLnNvdXJjZS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgIGNvbnN0IHNoYXJwVW5kZXJSZWZzID0gbmV3IFNldChzaGFycFVuZGVyLmJsZW5kZWRGcm9tID8/IFtzaGFycFVuZGVyLnNvdXJjZS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgIGNvbnN0IHNoYXJlZFJlZkNvdW50ID0gQXJyYXkuZnJvbShzaGFycE92ZXJSZWZzKS5maWx0ZXIoKGJvb2spID0+IHNoYXJwVW5kZXJSZWZzLmhhcyhib29rKSkubGVuZ3RoO1xuXG4gICAgICAgIGlmIChzaGFyZWRSZWZDb3VudCA8IG1pbkJvb2tzUGVyU2lkZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERlLXZpZyB1c2luZyB0aGUgc2hhcnAgcmVmZXJlbmNlXG4gICAgICBjb25zdCBkZXZpZ1Jlc3VsdHMgPSBkZXZpZ011bHRpcGxlKHNoYXJwT3Zlci5wcmljZSwgc2hhcnBVbmRlci5wcmljZSwgZGV2aWdNZXRob2RzKTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBlZmZlY3RpdmUgcHJlc2V0IG5hbWUgZm9yIGRpc3BsYXlcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZVByZXNldCA9IGN1c3RvbVNoYXJwQ29uZmlnID8gXCJjdXN0b21cIiA6IHNoYXJwUHJlc2V0O1xuXG4gICAgICAvLyBDcmVhdGUgc2hhcnAgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgLy8gT25seSBpbmNsdWRlIGJvb2tzIHRoYXQgY29udHJpYnV0ZWQgdG8gQk9USCBzaWRlcyBpbiBibGVuZGVkRnJvbVxuICAgICAgY29uc3QgYm90aFNpZGVzQm9va3MgPSBzaGFycE92ZXIuYmxlbmRlZEZyb20gJiYgc2hhcnBVbmRlci5ibGVuZGVkRnJvbVxuICAgICAgICA/IHNoYXJwT3Zlci5ibGVuZGVkRnJvbS5maWx0ZXIoYiA9PiBzaGFycFVuZGVyLmJsZW5kZWRGcm9tIS5pbmNsdWRlcyhiKSlcbiAgICAgICAgOiBzaGFycE92ZXIuYmxlbmRlZEZyb207XG4gICAgICBcbiAgICAgIGNvbnN0IHNoYXJwUmVmZXJlbmNlID0gY3JlYXRlU2hhcnBSZWZlcmVuY2UoXG4gICAgICAgIHNoYXJwT3Zlci5wcmljZSxcbiAgICAgICAgc2hhcnBVbmRlci5wcmljZSxcbiAgICAgICAgZWZmZWN0aXZlUHJlc2V0LFxuICAgICAgICBzaGFycE92ZXIuc291cmNlLFxuICAgICAgICBib3RoU2lkZXNCb29rc1xuICAgICAgKTtcblxuICAgICAgLy8gQ2hlY2sgZWFjaCBib29rIGZvciArRVYgb3Bwb3J0dW5pdGllcyBvbiBib3RoIHNpZGVzXG4gICAgICBjb25zdCBzaWRlczogKFwib3ZlclwiIHwgXCJ1bmRlclwiKVtdID0gW1wib3ZlclwiLCBcInVuZGVyXCJdO1xuICAgICAgXG4gICAgICAvLyBHZXQgYm9va3MgdG8gZXhjbHVkZSBiYXNlZCBvbiB0aGUgc2hhcnAgcmVmZXJlbmNlXG4gICAgICAvLyBXaGVuIHVzaW5nIGN1c3RvbSBjb25maWcsIGV4Y2x1ZGUgdGhlIGN1c3RvbSBzaGFycCBib29rc1xuICAgICAgY29uc3QgZXhjbHVkZWRCb29rcyA9IGN1c3RvbVNoYXJwQ29uZmlnXG4gICAgICAgID8gbmV3IFNldChjdXN0b21TaGFycENvbmZpZy5ib29rcy5tYXAoYiA9PiBiLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICA6IGdldEV4Y2x1ZGVkQm9va3NGb3JQcmVzZXQoc2hhcnBQcmVzZXQpO1xuXG4gICAgICBmb3IgKGNvbnN0IHNpZGUgb2Ygc2lkZXMpIHtcbiAgICAgICAgY29uc3Qgc2lkZURhdGEgPSBwYWlyW3NpZGVdO1xuICAgICAgICBjb25zdCBvcHBvc2l0ZVNpZGUgPSBzaWRlID09PSBcIm92ZXJcIiA/IFwidW5kZXJcIiA6IFwib3ZlclwiO1xuICAgICAgICBjb25zdCBvcHBvc2l0ZURhdGEgPSBwYWlyW29wcG9zaXRlU2lkZV07XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIEVWIGZvciBBTEwgYm9va3MgZmlyc3QgKGZvciBjb21wYXJpc29uIGRpc3BsYXkpXG4gICAgICAgIGNvbnN0IGJvb2tzV2l0aEVWOiBBcnJheTx7XG4gICAgICAgICAgYm9vazogdHlwZW9mIHNpZGVEYXRhLmJvb2tzWzBdO1xuICAgICAgICAgIGV2Q2FsYzogUmV0dXJuVHlwZTx0eXBlb2YgY2FsY3VsYXRlTXVsdGlFVj47XG4gICAgICAgICAgaXNFeGNsdWRlZDogYm9vbGVhbjtcbiAgICAgICAgfT4gPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgYm9va09mZmVyIG9mIHNpZGVEYXRhLmJvb2tzKSB7XG4gICAgICAgICAgY29uc3QgZXZDYWxjID0gY2FsY3VsYXRlTXVsdGlFVihkZXZpZ1Jlc3VsdHMsIGJvb2tPZmZlciwgc2lkZSk7XG4gICAgICAgICAgY29uc3QgaXNFeGNsdWRlZCA9IGV4Y2x1ZGVkQm9va3MuaGFzKGJvb2tPZmZlci5ib29rSWQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgYm9va3NXaXRoRVYucHVzaCh7IGJvb2s6IGJvb2tPZmZlciwgZXZDYWxjLCBpc0V4Y2x1ZGVkIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTb3J0IGJ5IEVWIChoaWdoZXN0IGZpcnN0KVxuICAgICAgICBib29rc1dpdGhFVi5zb3J0KChhLCBiKSA9PiBiLmV2Q2FsYy5ldldvcnN0IC0gYS5ldkNhbGMuZXZXb3JzdCk7XG5cbiAgICAgICAgLy8gRmlsdGVyIHRvIGJvb2tzIHRoYXQgY2FuIGJlIGJldCBvbiAobm90IGV4Y2x1ZGVkLCBwYXNzZXMgdXNlciBmaWx0ZXIpXG4gICAgICAgIGxldCBiZXR0YWJsZUJvb2tzID0gYm9va3NXaXRoRVYuZmlsdGVyKGIgPT4gIWIuaXNFeGNsdWRlZCk7XG4gICAgICAgIGlmIChib29rc0ZpbHRlcikge1xuICAgICAgICAgIGJldHRhYmxlQm9va3MgPSBiZXR0YWJsZUJvb2tzLmZpbHRlcihiID0+IGJvb2tzRmlsdGVyLmluY2x1ZGVzKGIuYm9vay5ib29rSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRmluZCB0aGUgYmVzdCBFViBib29rIHRoYXQgbWVldHMgdGhyZXNob2xkXG4gICAgICAgIGNvbnN0IGJlc3RCb29rID0gYmV0dGFibGVCb29rcy5maW5kKGIgPT4gXG4gICAgICAgICAgYi5ldkNhbGMuZXZXb3JzdCA+PSBtaW5FViAmJiBiLmV2Q2FsYy5ldldvcnN0IDw9IG1heEVWXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBTa2lwIGlmIG5vIGJvb2sgbWVldHMgdGhyZXNob2xkXG4gICAgICAgIGlmICghYmVzdEJvb2spIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGFsbEJvb2tzIGFycmF5IHdpdGggRVYlIGZvciBlYWNoIGJvb2tcbiAgICAgICAgY29uc3QgYWxsQm9va3NXaXRoRVY6IEJvb2tPZmZlcltdID0gYm9va3NXaXRoRVYubWFwKGIgPT4gKHtcbiAgICAgICAgICBib29rSWQ6IGIuYm9vay5ib29rSWQsXG4gICAgICAgICAgYm9va05hbWU6IGIuYm9vay5ib29rTmFtZSxcbiAgICAgICAgICBwcmljZTogYi5ib29rLnByaWNlLFxuICAgICAgICAgIHByaWNlRGVjaW1hbDogYi5ib29rLnByaWNlRGVjaW1hbCxcbiAgICAgICAgICBsaW5rOiBiLmJvb2subGluayB8fCBudWxsLFxuICAgICAgICAgIG1vYmlsZUxpbms6IGIuYm9vay5tb2JpbGVMaW5rIHx8IG51bGwsXG4gICAgICAgICAgc2dwOiBiLmJvb2suc2dwIHx8IG51bGwsXG4gICAgICAgICAgbGltaXRzOiBiLmJvb2subGltaXRzIHx8IG51bGwsXG4gICAgICAgICAgZXZQZXJjZW50OiBiLmV2Q2FsYy5ldldvcnN0LCAvLyBFViUgZm9yIHRoaXMgYm9va1xuICAgICAgICAgIGlzU2hhcnBSZWY6IGIuaXNFeGNsdWRlZCwgLy8gTWFyayBpZiB1c2VkIGFzIHNoYXJwIHJlZmVyZW5jZVxuICAgICAgICB9KSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTb3J0IGFsbEJvb2tzIGJ5IEVWIChiZXN0IGZpcnN0KSBmb3IgZGlzcGxheVxuICAgICAgICBhbGxCb29rc1dpdGhFVi5zb3J0KChhLCBiKSA9PiAoYi5ldlBlcmNlbnQgPz8gMCkgLSAoYS5ldlBlcmNlbnQgPz8gMCkpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBPTkUgb3Bwb3J0dW5pdHkgcGVyIG1hcmtldCAoZGVkdXBsaWNhdGVkIHRvIGJlc3QgRVYpXG4gICAgICAgIGNvbnN0IG1hcmtldEtleSA9IGAke3BhaXIuZXZlbnRJZH06JHtwYWlyLm1hcmtldH06JHtwYWlyLnBsYXllcn06JHtwYWlyLmxpbmV9OiR7c2lkZX1gO1xuICAgICAgICBjb25zdCBvcHA6IFBvc2l0aXZlRVZPcHBvcnR1bml0eSA9IHtcbiAgICAgICAgICBpZDogbWFya2V0S2V5LFxuICAgICAgICAgIHNwb3J0OiBwYWlyLnNwb3J0LFxuICAgICAgICAgIGV2ZW50SWQ6IHBhaXIuZXZlbnRJZCxcbiAgICAgICAgICBtYXJrZXQ6IHBhaXIubWFya2V0LFxuICAgICAgICAgIG1hcmtldERpc3BsYXk6IHBhaXIubWFya2V0RGlzcGxheSB8fCBnZXRNYXJrZXREaXNwbGF5KHBhaXIubWFya2V0KSxcbiAgICAgICAgICBob21lVGVhbTogcGFpci5ldmVudD8uaG9tZV90ZWFtLFxuICAgICAgICAgIGF3YXlUZWFtOiBwYWlyLmV2ZW50Py5hd2F5X3RlYW0sXG4gICAgICAgICAgc3RhcnRUaW1lOiBwYWlyLmV2ZW50Py5zdGFydF90aW1lLFxuICAgICAgICAgIHBsYXllcklkOiBwYWlyLnBsYXllcklkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBwbGF5ZXJOYW1lOiBwYWlyLnBsYXllckRpc3BsYXkgfHwgcGFpci5wbGF5ZXIsXG4gICAgICAgICAgcGxheWVyVGVhbTogcGFpci50ZWFtIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBwbGF5ZXJQb3NpdGlvbjogcGFpci5wb3NpdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgbGluZTogcGFpci5saW5lLFxuICAgICAgICAgIHNpZGUsXG4gICAgICAgICAgc2hhcnBQcmVzZXQ6IGVmZmVjdGl2ZVByZXNldCxcbiAgICAgICAgICBzaGFycFJlZmVyZW5jZToge1xuICAgICAgICAgICAgLi4uc2hhcnBSZWZlcmVuY2UsXG4gICAgICAgICAgICBibGVuZGVkRnJvbTogdW5kZWZpbmVkLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGV2aWdSZXN1bHRzOiB7XG4gICAgICAgICAgICBbZGV2aWdNZXRob2RzWzBdXTogZGV2aWdSZXN1bHRzW2RldmlnTWV0aG9kc1swXV0sXG4gICAgICAgICAgfSBhcyBNdWx0aURldmlnUmVzdWx0LFxuICAgICAgICAgIGJvb2s6IHtcbiAgICAgICAgICAgIGJvb2tJZDogYmVzdEJvb2suYm9vay5ib29rSWQsXG4gICAgICAgICAgICBwcmljZTogYmVzdEJvb2suYm9vay5wcmljZSxcbiAgICAgICAgICAgIHByaWNlRGVjaW1hbDogYmVzdEJvb2suYm9vay5wcmljZURlY2ltYWwsXG4gICAgICAgICAgICBsaW5rOiBiZXN0Qm9vay5ib29rLmxpbmssXG4gICAgICAgICAgICBtb2JpbGVMaW5rOiBiZXN0Qm9vay5ib29rLm1vYmlsZUxpbmsgfHwgbnVsbCxcbiAgICAgICAgICAgIGxpbWl0czogYmVzdEJvb2suYm9vay5saW1pdHMgfHwgbnVsbCxcbiAgICAgICAgICAgIGV2UGVyY2VudDogYmVzdEJvb2suZXZDYWxjLmV2V29yc3QsXG4gICAgICAgICAgfSBhcyBCb29rT2ZmZXIsXG4gICAgICAgICAgZXZDYWxjdWxhdGlvbnM6IGJlc3RCb29rLmV2Q2FsYyxcbiAgICAgICAgICAvLyBBbGwgYm9va3Mgd2l0aCB0aGVpciBFViUgZm9yIGNvbXBhcmlzb25cbiAgICAgICAgICBhbGxCb29rczogYWxsQm9va3NXaXRoRVYsXG4gICAgICAgICAgb3Bwb3NpdGVCb29rczogb3Bwb3NpdGVEYXRhLmJvb2tzLm1hcChiID0+ICh7XG4gICAgICAgICAgICBib29rSWQ6IGIuYm9va0lkLFxuICAgICAgICAgICAgYm9va05hbWU6IGIuYm9va05hbWUsXG4gICAgICAgICAgICBwcmljZTogYi5wcmljZSxcbiAgICAgICAgICAgIHByaWNlRGVjaW1hbDogYi5wcmljZURlY2ltYWwsXG4gICAgICAgICAgICBsaW5rOiBiLmxpbmsgfHwgbnVsbCxcbiAgICAgICAgICAgIG1vYmlsZUxpbms6IGIubW9iaWxlTGluayB8fCBudWxsLFxuICAgICAgICAgICAgc2dwOiBiLnNncCB8fCBudWxsLFxuICAgICAgICAgICAgbGltaXRzOiBiLmxpbWl0cyB8fCBudWxsLFxuICAgICAgICAgIH0pKSBhcyBCb29rT2ZmZXJbXSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfTtcblxuICAgICAgICBvcHBvcnR1bml0aWVzLnB1c2gob3BwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3Bwb3J0dW5pdGllcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBbcG9zaXRpdmUtZXZdIEVycm9yIGZldGNoaW5nICR7c3BvcnR9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBCb29rcyB0byBleGNsdWRlIGZyb20gbWFya2V0IGF2ZXJhZ2UgY2FsY3VsYXRpb25zIGVudGlyZWx5LlxuICogUHJlZGljdGlvbiBtYXJrZXRzIChQb2x5bWFya2V0LCBLYWxzaGkpIHVzZSBleGNoYW5nZS1zdHlsZSBwcmljaW5nXG4gKiB0aGF0IGNhbiBza2V3IHRyYWRpdGlvbmFsIHNwb3J0c2Jvb2sgYXZlcmFnZXMuXG4gKi9cbmNvbnN0IEVYQ0xVREVEX0ZST01fQVZFUkFHRSA9IG5ldyBTZXQoW1wicG9seW1hcmtldFwiLCBcImthbHNoaVwiXSk7XG5cbi8qKlxuICogUlNJIChSdXNoIFN0cmVldCBJbnRlcmFjdGl2ZSkgYm9va3MgdGhhdCBvZnRlbiBzaGFyZSB0aGUgc2FtZSBvZGRzIGZlZWQuXG4gKiBXaGVuIGFsbCBoYXZlIGlkZW50aWNhbCBvZGRzLCB3ZSBzaG91bGQgb25seSBjb3VudCB0aGVtIG9uY2UgaW4gYXZlcmFnZXMuXG4gKi9cbmNvbnN0IFJTSV9CT09LUyA9IG5ldyBTZXQoW1wiYmV0cml2ZXJzXCIsIFwiYmFsbHktYmV0XCIsIFwiYmV0cGFyeFwiXSk7XG5cbi8qKlxuICogRmlsdGVyIGFuZCBkZWR1cGxpY2F0ZSBib29rcyBmb3IgbWFya2V0IGF2ZXJhZ2UgY2FsY3VsYXRpb24uXG4gKiAtIEV4Y2x1ZGVzIHByZWRpY3Rpb24gbWFya2V0cyAoUG9seW1hcmtldCwgS2Fsc2hpKSBlbnRpcmVseVxuICogLSBSU0kgYm9va3Mgd2l0aCBpZGVudGljYWwgb2RkcyBhcmUgY291bnRlZCBvbmNlIHRvIGF2b2lkIHNrZXdpbmdcbiAqL1xuZnVuY3Rpb24gZmlsdGVyQm9va3NGb3JBdmVyYWdlKGJvb2tzOiBCb29rT2ZmZXJbXSk6IEJvb2tPZmZlcltdIHtcbiAgLy8gU3RlcCAxOiBFeGNsdWRlIHByZWRpY3Rpb24gbWFya2V0cyBlbnRpcmVseVxuICBjb25zdCBmaWx0ZXJlZCA9IGJvb2tzLmZpbHRlcigoYikgPT4gIUVYQ0xVREVEX0ZST01fQVZFUkFHRS5oYXMoYi5ib29rSWQudG9Mb3dlckNhc2UoKSkpO1xuXG4gIC8vIFN0ZXAgMjogRGVkdXBsaWNhdGUgUlNJIGJvb2tzIHdpdGggaWRlbnRpY2FsIG9kZHNcbiAgY29uc3QgcnNpQm9va3M6IEJvb2tPZmZlcltdID0gW107XG4gIGNvbnN0IG90aGVyQm9va3M6IEJvb2tPZmZlcltdID0gW107XG5cbiAgZm9yIChjb25zdCBiIG9mIGZpbHRlcmVkKSB7XG4gICAgaWYgKFJTSV9CT09LUy5oYXMoYi5ib29rSWQudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHJzaUJvb2tzLnB1c2goYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyQm9va3MucHVzaChiKTtcbiAgICB9XG4gIH1cblxuICBpZiAocnNpQm9va3MubGVuZ3RoID09PSAwKSByZXR1cm4gZmlsdGVyZWQ7XG5cbiAgLy8gS2VlcCBvbmx5IHVuaXF1ZSBSU0kgcHJpY2VzXG4gIGNvbnN0IHJzaUJ5UHJpY2UgPSBuZXcgTWFwPG51bWJlciwgQm9va09mZmVyPigpO1xuICBmb3IgKGNvbnN0IGIgb2YgcnNpQm9va3MpIHtcbiAgICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZChiLnByaWNlICogMTAwKSAvIDEwMDtcbiAgICBpZiAoIXJzaUJ5UHJpY2UuaGFzKHJvdW5kZWQpKSB7XG4gICAgICByc2lCeVByaWNlLnNldChyb3VuZGVkLCBiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gWy4uLm90aGVyQm9va3MsIC4uLnJzaUJ5UHJpY2UudmFsdWVzKCldO1xufVxuXG4vKipcbiAqIEdldCBzaGFycCBvZGRzIGZvciBhIHByZXNldCBmcm9tIGF2YWlsYWJsZSBib29rc1xuICovXG5mdW5jdGlvbiBnZXRTaGFycE9kZHNGb3JQcmVzZXQoXG4gIGJvb2tzOiBCb29rT2ZmZXJbXSxcbiAgcHJlc2V0OiBTaGFycFByZXNldFxuKTogeyBwcmljZTogbnVtYmVyOyBzb3VyY2U6IHN0cmluZzsgYmxlbmRlZEZyb20/OiBzdHJpbmdbXSB9IHwgbnVsbCB7XG4gIGNvbnN0IHByZXNldENvbmZpZyA9IFNIQVJQX1BSRVNFVFNbcHJlc2V0XTtcbiAgaWYgKCFwcmVzZXRDb25maWcpIHJldHVybiBudWxsO1xuXG4gIGlmIChwcmVzZXQgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAvLyBDdXN0b20gcHJlc2V0IC0gd291bGQgbmVlZCB1c2VyLWRlZmluZWQgd2VpZ2h0c1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTWFya2V0IEF2ZXJhZ2U6IFVzZSBhdmFpbGFibGUgc3BvcnRzYm9va3MgKGV4Y2x1ZGluZyBwcmVkaWN0aW9uIG1hcmtldHMgJiBkZWR1cGxpY2F0aW5nIFJTSSlcbiAgaWYgKHByZXNldCA9PT0gXCJtYXJrZXRfYXZlcmFnZVwiKSB7XG4gICAgY29uc3QgZmlsdGVyZWRCb29rcyA9IGZpbHRlckJvb2tzRm9yQXZlcmFnZShib29rcyk7XG4gICAgXG4gICAgaWYgKGZpbHRlcmVkQm9va3MubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICAvLyBFcXVhbCB3ZWlnaHQgZm9yIGFsbCBib29rc1xuICAgIGNvbnN0IGJsZW5kSW5wdXRzID0gZmlsdGVyZWRCb29rcy5tYXAoKGIpID0+ICh7XG4gICAgICBib29rSWQ6IGIuYm9va0lkLFxuICAgICAgb2RkczogYi5wcmljZSxcbiAgICAgIHdlaWdodDogMS4wLFxuICAgIH0pKTtcbiAgICBcbiAgICBjb25zdCBibGVuZGVkT2RkcyA9IGJsZW5kU2hhcnBPZGRzKGJsZW5kSW5wdXRzKTtcbiAgICBpZiAoYmxlbmRlZE9kZHMgPT09IDApIHJldHVybiBudWxsO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBwcmljZTogYmxlbmRlZE9kZHMsXG4gICAgICBzb3VyY2U6IGBNYXJrZXQgQXZnICgke2ZpbHRlcmVkQm9va3MubGVuZ3RofSBib29rcylgLFxuICAgICAgYmxlbmRlZEZyb206IGZpbHRlcmVkQm9va3MubWFwKChiKSA9PiBiLmJvb2tJZCksXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHByZXNldEJvb2tzID0gcHJlc2V0Q29uZmlnLmJvb2tzO1xuICBcbiAgLy8gQnVpbGQgbG9va3VwIG1hcCBmb3IgTygxKSBsb29rdXBzIGluc3RlYWQgb2YgTyhuKSAuZmluZCgpIGNhbGxzXG4gIGNvbnN0IGJvb2tNYXAgPSBidWlsZEJvb2tMb29rdXBNYXAoYm9va3MpO1xuXG4gIGlmIChwcmVzZXRCb29rcy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBTaW5nbGUgYm9vayBwcmVzZXQgLSBPKDEpIGxvb2t1cFxuICAgIGNvbnN0IHRhcmdldEJvb2sgPSBwcmVzZXRCb29rc1swXS5ib29rSWQ7XG4gICAgY29uc3QgbWF0Y2ggPSBib29rTWFwLmdldCh0YXJnZXRCb29rLnRvTG93ZXJDYXNlKCkpIHx8IGJvb2tNYXAuZ2V0KG5vcm1hbGl6ZUJvb2tJZEZvclNoYXJwKHRhcmdldEJvb2sudG9Mb3dlckNhc2UoKSkpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIHsgcHJpY2U6IG1hdGNoLnByaWNlLCBzb3VyY2U6IHRhcmdldEJvb2sgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBCbGVuZGVkIHByZXNldCAtIFJFUVVJUkVTIEFMTCBCT09LUyB0byBiZSBwcmVzZW50XG4gIGNvbnN0IGJsZW5kSW5wdXRzOiB7IGJvb2tJZDogc3RyaW5nOyBvZGRzOiBudW1iZXI7IHdlaWdodDogbnVtYmVyIH1bXSA9IFtdO1xuICBjb25zdCBibGVuZGVkRnJvbTogc3RyaW5nW10gPSBbXTtcblxuICBmb3IgKGNvbnN0IHsgYm9va0lkLCB3ZWlnaHQgfSBvZiBwcmVzZXRCb29rcykge1xuICAgIC8vIE8oMSkgbG9va3VwIGluc3RlYWQgb2YgTyhuKSAuZmluZCgpXG4gICAgY29uc3QgbWF0Y2ggPSBib29rTWFwLmdldChib29rSWQudG9Mb3dlckNhc2UoKSkgfHwgYm9va01hcC5nZXQobm9ybWFsaXplQm9va0lkRm9yU2hhcnAoYm9va0lkLnRvTG93ZXJDYXNlKCkpKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGJsZW5kSW5wdXRzLnB1c2goeyBib29rSWQsIG9kZHM6IG1hdGNoLnByaWNlLCB3ZWlnaHQgfSk7XG4gICAgICBibGVuZGVkRnJvbS5wdXNoKGJvb2tJZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRm9yIGJsZW5kZWQgcHJlc2V0cywgcmVxdWlyZSBBTEwgYm9va3MgdG8gYmUgYXZhaWxhYmxlXG4gIC8vIFRoaXMgZW5zdXJlcyBwaW5uYWNsZV9jaXJjYSBvbmx5IHdvcmtzIHdoZW4gQk9USCBQaW5uYWNsZSBBTkQgQ2lyY2EgaGF2ZSBvZGRzXG4gIGlmIChibGVuZElucHV0cy5sZW5ndGggIT09IHByZXNldEJvb2tzLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIGJvb2tzIGFyZSBwcmVzZW50LCBzbyB3ZWlnaHRzIGFyZSBhbHJlYWR5IHByb3Blcmx5IG5vcm1hbGl6ZWQgZnJvbSB0aGUgcHJlc2V0IGNvbmZpZ1xuICBjb25zdCBibGVuZGVkT2RkcyA9IGJsZW5kU2hhcnBPZGRzKGJsZW5kSW5wdXRzKTtcbiAgaWYgKGJsZW5kZWRPZGRzID09PSAwKSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4ge1xuICAgIHByaWNlOiBibGVuZGVkT2RkcyxcbiAgICBzb3VyY2U6IGAke3ByZXNldH0gKCR7YmxlbmRlZEZyb20uam9pbihcIiwgXCIpfSlgLFxuICAgIGJsZW5kZWRGcm9tLFxuICB9O1xufVxuXG4vKipcbiAqIEdldCBzaGFycCBvZGRzIHVzaW5nIGEgY3VzdG9tIGNvbmZpZ3VyYXRpb24gKHVzZXIncyBjdXN0b20gRVYgbW9kZWwpXG4gKiBTdXBwb3J0cyB3ZWlnaHRlZCBibGVuZGluZyBvZiBtdWx0aXBsZSBzaGFycCBib29rc1xuICovXG4vKipcbiAqIEJ1aWxkIGEgbG9va3VwIG1hcCBmb3IgZmFzdCBib29rIG1hdGNoaW5nXG4gKiBNYXBzIGFsbCBwb3NzaWJsZSBib29rIElEIHZhcmlhdGlvbnMgdG8gdGhlIEJvb2tPZmZlclxuICovXG5mdW5jdGlvbiBidWlsZEJvb2tMb29rdXBNYXAoYm9va3M6IEJvb2tPZmZlcltdKTogTWFwPHN0cmluZywgQm9va09mZmVyPiB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXA8c3RyaW5nLCBCb29rT2ZmZXI+KCk7XG4gIGZvciAoY29uc3QgYm9vayBvZiBib29rcykge1xuICAgIGNvbnN0IGxvd2VyID0gYm9vay5ib29rSWQudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBBZGQgdGhlIG9yaWdpbmFsIGxvd2VyY2FzZWQgSURcbiAgICBtYXAuc2V0KGxvd2VyLCBib29rKTtcbiAgICAvLyBBZGQgdGhlIG5vcm1hbGl6ZWQgdmVyc2lvbiB0b29cbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplQm9va0lkRm9yU2hhcnAobG93ZXIpO1xuICAgIGlmIChub3JtYWxpemVkICE9PSBsb3dlcikge1xuICAgICAgbWFwLnNldChub3JtYWxpemVkLCBib29rKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gZ2V0U2hhcnBPZGRzRm9yQ3VzdG9tQ29uZmlnKFxuICBib29rczogQm9va09mZmVyW10sXG4gIGNvbmZpZzogQ3VzdG9tU2hhcnBDb25maWdcbik6IHsgcHJpY2U6IG51bWJlcjsgc291cmNlOiBzdHJpbmc7IGJsZW5kZWRGcm9tPzogc3RyaW5nW10gfSB8IG51bGwge1xuICBpZiAoIWNvbmZpZy5ib29rcyB8fCBjb25maWcuYm9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBGb3IgY3VzdG9tIGJsZW5kcywgZXhjbHVkZSBwcmVkaWN0aW9uIG1hcmtldHMgZW50aXJlbHkgdG8gYXZvaWQgc2tld2luZ1xuICBjb25zdCBmaWx0ZXJlZEJvb2tzID0gYm9va3MuZmlsdGVyKChiKSA9PiAhRVhDTFVERURfRlJPTV9BVkVSQUdFLmhhcyhiLmJvb2tJZC50b0xvd2VyQ2FzZSgpKSk7XG4gIFxuICAvLyBCdWlsZCBsb29rdXAgbWFwIG9uY2UgZm9yIE8oMSkgbG9va3VwcyBpbnN0ZWFkIG9mIE8obikgLmZpbmQoKSBjYWxsc1xuICBjb25zdCBib29rTWFwID0gYnVpbGRCb29rTG9va3VwTWFwKGZpbHRlcmVkQm9va3MpO1xuXG4gIC8vIFNpbmdsZSBib29rIGluIGN1c3RvbSBjb25maWdcbiAgaWYgKGNvbmZpZy5ib29rcy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCB0YXJnZXRCb29rID0gY29uZmlnLmJvb2tzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgbWF0Y2ggPSBib29rTWFwLmdldCh0YXJnZXRCb29rKSB8fCBib29rTWFwLmdldChub3JtYWxpemVCb29rSWRGb3JTaGFycCh0YXJnZXRCb29rKSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4geyBwcmljZTogbWF0Y2gucHJpY2UsIHNvdXJjZTogdGFyZ2V0Qm9vayB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE11bHRpcGxlIGJvb2tzIC0gdXNlIHdlaWdodGVkIGJsZW5kaW5nXG4gIGNvbnN0IGJsZW5kSW5wdXRzOiB7IGJvb2tJZDogc3RyaW5nOyBvZGRzOiBudW1iZXI7IHdlaWdodDogbnVtYmVyIH1bXSA9IFtdO1xuICBjb25zdCBibGVuZGVkRnJvbTogc3RyaW5nW10gPSBbXTtcbiAgXG4gIC8vIENhbGN1bGF0ZSB0b3RhbCB3ZWlnaHQgZnJvbSBhdmFpbGFibGUgYm9va3MgZm9yIG5vcm1hbGl6YXRpb25cbiAgbGV0IHRvdGFsQXZhaWxhYmxlV2VpZ2h0ID0gMDtcblxuICBmb3IgKGNvbnN0IGJvb2tJZCBvZiBjb25maWcuYm9va3MpIHtcbiAgICBjb25zdCBub3JtYWxpemVkQm9va0lkID0gYm9va0lkLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gTygxKSBsb29rdXAgaW5zdGVhZCBvZiBPKG4pIC5maW5kKClcbiAgICBjb25zdCBtYXRjaCA9IGJvb2tNYXAuZ2V0KG5vcm1hbGl6ZWRCb29rSWQpIHx8IGJvb2tNYXAuZ2V0KG5vcm1hbGl6ZUJvb2tJZEZvclNoYXJwKG5vcm1hbGl6ZWRCb29rSWQpKTtcbiAgICBcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIC8vIEdldCB3ZWlnaHQgZnJvbSBjb25maWcsIGRlZmF1bHQgdG8gZXF1YWwgd2VpZ2h0IGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgIGNvbnN0IHdlaWdodCA9IGNvbmZpZy53ZWlnaHRzPy5bYm9va0lkXSA/PyBjb25maWcud2VpZ2h0cz8uW25vcm1hbGl6ZWRCb29rSWRdID8/ICgxMDAgLyBjb25maWcuYm9va3MubGVuZ3RoKTtcbiAgICAgIGJsZW5kSW5wdXRzLnB1c2goeyBib29rSWQ6IG5vcm1hbGl6ZWRCb29rSWQsIG9kZHM6IG1hdGNoLnByaWNlLCB3ZWlnaHQgfSk7XG4gICAgICBibGVuZGVkRnJvbS5wdXNoKG5vcm1hbGl6ZWRCb29rSWQpO1xuICAgICAgdG90YWxBdmFpbGFibGVXZWlnaHQgKz0gd2VpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlcXVpcmUgYXQgbGVhc3Qgb25lIGJvb2sgdG8gYmUgYXZhaWxhYmxlXG4gIGlmIChibGVuZElucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIElmIG5vdCBhbGwgYm9va3MgYXJlIGF2YWlsYWJsZSwgbm9ybWFsaXplIHdlaWdodHMgdG8gc3VtIHRvIDEwMCVcbiAgaWYgKGJsZW5kSW5wdXRzLmxlbmd0aCA8IGNvbmZpZy5ib29rcy5sZW5ndGggJiYgdG90YWxBdmFpbGFibGVXZWlnaHQgPiAwKSB7XG4gICAgY29uc3Qgbm9ybWFsaXphdGlvbkZhY3RvciA9IDEwMCAvIHRvdGFsQXZhaWxhYmxlV2VpZ2h0O1xuICAgIGJsZW5kSW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgaW5wdXQud2VpZ2h0ID0gaW5wdXQud2VpZ2h0ICogbm9ybWFsaXphdGlvbkZhY3RvcjtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IGJsZW5kZWRPZGRzID0gYmxlbmRTaGFycE9kZHMoYmxlbmRJbnB1dHMpO1xuICBpZiAoYmxlbmRlZE9kZHMgPT09IDApIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IHNvdXJjZUJvb2tzID0gYmxlbmRlZEZyb20ubWFwKGIgPT4gYi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGIuc2xpY2UoMSkpLmpvaW4oXCIsIFwiKTtcbiAgcmV0dXJuIHtcbiAgICBwcmljZTogYmxlbmRlZE9kZHMsXG4gICAgc291cmNlOiBgQ3VzdG9tICgke3NvdXJjZUJvb2tzfSlgLFxuICAgIGJsZW5kZWRGcm9tLFxuICB9O1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBib29rIElEIGZvciBzaGFycCBib29rIG1hdGNoaW5nXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJvb2tJZEZvclNoYXJwKGlkOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBsb3dlciA9IGlkLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAobG93ZXIpIHtcbiAgICBjYXNlIFwiaGFyZHJvY2tcIjpcbiAgICAgIHJldHVybiBcImhhcmQtcm9ja1wiO1xuICAgIGNhc2UgXCJoYXJkLXJvY2tcIjpcbiAgICAgIHJldHVybiBcImhhcmRyb2NrXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBsb3dlcjtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUmVkaXMgSGVscGVycyAocmV1c2VkIGZyb20gb3Bwb3J0dW5pdGllcyBBUEkpXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5hc3luYyBmdW5jdGlvbiBnZXRBY3RpdmVFdmVudElkcyhzcG9ydDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBjb25zdCBhY3RpdmVTZXQgPSBhd2FpdCByZWRpcy5zbWVtYmVycyhgYWN0aXZlX2V2ZW50czoke3Nwb3J0fWApO1xuICBpZiAoYWN0aXZlU2V0ICYmIGFjdGl2ZVNldC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGFjdGl2ZVNldC5tYXAoU3RyaW5nKTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIHRvIHNjYW5uaW5nXG4gIGNvbnN0IGV2ZW50S2V5cyA9IGF3YWl0IHNjYW5LZXlzKGBldmVudHM6JHtzcG9ydH06KmApO1xuICByZXR1cm4gZXZlbnRLZXlzLm1hcCgoaykgPT4gay5zcGxpdChcIjpcIilbMl0pLmZpbHRlcihCb29sZWFuKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0T2Rkc0tleXNGb3JFdmVudHMoc3BvcnQ6IHN0cmluZywgZXZlbnRJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBjb25zdCBhbGxLZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCBCQVRDSF9TSVpFID0gMTA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudElkcy5sZW5ndGg7IGkgKz0gQkFUQ0hfU0laRSkge1xuICAgIGNvbnN0IGJhdGNoID0gZXZlbnRJZHMuc2xpY2UoaSwgaSArIEJBVENIX1NJWkUpO1xuICAgIGNvbnN0IGJhdGNoUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgYmF0Y2gubWFwKChldmVudElkKSA9PiBzY2FuS2V5cyhgb2Rkczoke3Nwb3J0fToke2V2ZW50SWR9OipgKSlcbiAgICApO1xuICAgIGFsbEtleXMucHVzaCguLi5iYXRjaFJlc3VsdHMuZmxhdCgpKTtcbiAgfVxuXG4gIHJldHVybiBhbGxLZXlzO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzY2FuS2V5cyhwYXR0ZXJuOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XG4gIGxldCBjdXJzb3IgPSBcIjBcIjtcbiAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuICBjb25zdCBNQVhfSVRFUkFUSU9OUyA9IDUwO1xuXG4gIGRvIHtcbiAgICBpdGVyYXRpb25zKys7XG4gICAgY29uc3QgcmVzdWx0OiBbc3RyaW5nLCBzdHJpbmdbXV0gPSBhd2FpdCByZWRpcy5zY2FuKGN1cnNvciwge1xuICAgICAgbWF0Y2g6IHBhdHRlcm4sXG4gICAgICBjb3VudDogU0NBTl9DT1VOVCxcbiAgICB9KTtcbiAgICBjdXJzb3IgPSByZXN1bHRbMF07XG4gICAga2V5cy5wdXNoKC4uLnJlc3VsdFsxXSk7XG5cbiAgICBpZiAoaXRlcmF0aW9ucyA+PSBNQVhfSVRFUkFUSU9OUykge1xuICAgICAgY29uc29sZS53YXJuKGBbc2NhbktleXNdIEhpdCBpdGVyYXRpb24gbGltaXQgZm9yIHBhdHRlcm46ICR7cGF0dGVybn1gKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSB3aGlsZSAoY3Vyc29yICE9PSBcIjBcIik7XG5cbiAgcmV0dXJuIGtleXM7XG59XG4iXSwibmFtZXMiOlsicnVudGltZSIsIm1heER1cmF0aW9uIiwiTmV4dFJlc3BvbnNlIiwiUmVkaXMiLCJub3JtYWxpemVQbGF5ZXJOYW1lIiwiZ2V0TWFya2V0RGlzcGxheSIsIm5vcm1hbGl6ZVJhd01hcmtldCIsImRldmlnTXVsdGlwbGUiLCJjYWxjdWxhdGVNdWx0aUVWIiwiY3JlYXRlU2hhcnBSZWZlcmVuY2UiLCJibGVuZFNoYXJwT2RkcyIsIlNIQVJQX1BSRVNFVFMiLCJERUZBVUxUX0RFVklHX01FVEhPRFMiLCJFVl9USFJFU0hPTERTIiwiY3JlYXRlQ2xpZW50IiwiZ2V0VXNlclBsYW4iLCJoYXNFbGl0ZUFjY2VzcyIsInJlZGlzIiwidXJsIiwicHJvY2VzcyIsImVudiIsIlVQU1RBU0hfUkVESVNfUkVTVF9VUkwiLCJ0b2tlbiIsIlVQU1RBU0hfUkVESVNfUkVTVF9UT0tFTiIsIlNDQU5fQ09VTlQiLCJNR0VUX0NIVU5LX1NJWkUiLCJSRVNQT05TRV9DQUNIRV9QUkVGSVgiLCJSRVNQT05TRV9DQUNIRV9UVExfUFJFU0VUIiwiUkVTUE9OU0VfQ0FDSEVfVFRMX0NVU1RPTSIsInJlc29sdmVBbGxvd2VkT3JpZ2luIiwib3JpZ2luIiwiaXNMb2NhbGhvc3QiLCJ0ZXN0IiwiZ2V0Q29yc0hlYWRlcnMiLCJhbGxvd2VkT3JpZ2luIiwiVmFyeSIsImpzb25XaXRoSGVhZGVycyIsImJvZHkiLCJzdGF0dXMiLCJleHRyYUhlYWRlcnMiLCJqc29uIiwiaGVhZGVycyIsImJ1aWxkUmVzcG9uc2VDYWNoZUtleSIsInBhcmFtcyIsImtleXMiLCJtYXAiLCJrIiwiZ2V0Iiwiam9pbiIsImlzQ3VzdG9tTW9kZWxSZXF1ZXN0IiwiY3VzdG9tQm9va3MiLCJsZW5ndGgiLCJoYXNoQ2FjaGVLZXkiLCJrZXkiLCJoYXNoIiwiaSIsImNoYXJDb2RlQXQiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiZ2V0RnJvbVJlc3BvbnNlQ2FjaGUiLCJyZWRpc0tleSIsImNhY2hlZCIsImVycm9yIiwiY29uc29sZSIsInNldEluUmVzcG9uc2VDYWNoZSIsImRhdGEiLCJpc0N1c3RvbSIsInR0bCIsInNldCIsImV4IiwiVkFMSURfU1BPUlRTIiwiU2V0IiwiRVhDTFVERURfQk9PS1MiLCJnZXRFeGNsdWRlZEJvb2tzRm9yUHJlc2V0IiwicHJlc2V0IiwiZXhjbHVkZWQiLCJhZGQiLCJub3JtYWxpemVCb29rSWQiLCJpZCIsImxvd2VyIiwidG9Mb3dlckNhc2UiLCJmb3JtYXRQb3NpdGlvbiIsInBvc2l0aW9uIiwibXVsdGlQb3NQYXR0ZXJucyIsInVwcGVyIiwidG9VcHBlckNhc2UiLCJpbmNsdWRlcyIsImZvcm1hdEFtZXJpY2FuT2RkcyIsInByaWNlIiwiU3RyaW5nIiwiR0VUIiwicmVxIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsIm1vZGVQYXJhbSIsIm1vZGUiLCJieXBhc3NDYWNoZSIsImNhY2hlS2V5IiwiY2FjaGVkUmVzcG9uc2UiLCJsb2ciLCJzcG9ydHNQYXJhbSIsInNwbGl0IiwiZmlsdGVyIiwiQm9vbGVhbiIsInNwb3J0cyIsInMiLCJoYXMiLCJtYXJrZXRzIiwic2hhcnBQcmVzZXQiLCJkZXZpZ01ldGhvZHNQYXJhbSIsImRldmlnTWV0aG9kcyIsIm0iLCJtaW5FViIsInBhcnNlRmxvYXQiLCJtYXhFViIsIm1heGltdW0iLCJib29rc0ZpbHRlciIsImxpbWl0IiwiTWF0aCIsIm1pbiIsInBhcnNlSW50IiwibWluQm9va3NQZXJTaWRlIiwiY3VzdG9tU2hhcnBCb29rc1BhcmFtIiwiY3VzdG9tQm9va1dlaWdodHNQYXJhbSIsImN1c3RvbVNoYXJwQ29uZmlnIiwic3VwYWJhc2UiLCJ1c2VyIiwiYXV0aCIsImdldFVzZXIiLCJ1c2VyUGxhbiIsImNvZGUiLCJ3ZWlnaHRzIiwiSlNPTiIsInBhcnNlIiwiZSIsIndhcm4iLCJib29rcyIsInNwb3J0UHJvbWlzZXMiLCJzcG9ydCIsInNwb3J0T3BwcyIsImZldGNoUG9zaXRpdmVFVk9wcG9ydHVuaXRpZXMiLCJFcnJvciIsIm1lc3NhZ2UiLCJzcG9ydFJlc3VsdHMiLCJQcm9taXNlIiwiYWxsIiwiYWxsT3Bwb3J0dW5pdGllcyIsImZsYXQiLCJzb3J0IiwiYSIsImIiLCJldkNhbGN1bGF0aW9ucyIsImV2V29yc3QiLCJvcHBvcnR1bml0aWVzIiwic2xpY2UiLCJyZXNwb25zZSIsIm1ldGEiLCJ0b3RhbEZvdW5kIiwicmV0dXJuZWQiLCJ1bmRlZmluZWQiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsInJlc3BvbnNlU2l6ZSIsInN0cmluZ2lmeSIsInRvRml4ZWQiLCJjYXRjaCIsImVyciIsInR0bFVzZWQiLCJ0aW1pbmdfbXMiLCJPUFRJT05TIiwicmVxdWVzdCIsInBhaXJNYXAiLCJNYXAiLCJldmVudElkcyIsImdldEFjdGl2ZUV2ZW50SWRzIiwiYWxsT2Rkc0tleXMiLCJnZXRPZGRzS2V5c0ZvckV2ZW50cyIsImV2ZW50SWRTZXQiLCJmaWx0ZXJlZEtleXMiLCJpc01hcmtldEFsbG93ZWQiLCJtYXJrZXQiLCJwYXJ0cyIsImV2ZW50SWQiLCJib29rIiwicHVzaCIsImNodW5rcyIsImNodW5rUmVzdWx0cyIsImNodW5rIiwibWdldCIsImFsbE9kZHNEYXRhIiwib2Rkc0RhdGFNYXAiLCJmb3JFYWNoIiwiZXZlbnRLZXlzIiwiZXZlbnRzUmF3IiwiU0lYX0hPVVJTX01TIiwiZXZlbnRNYXAiLCJwcmVnYW1lRXZlbnRJZHMiLCJsaXZlRXZlbnRJZHMiLCJleGNsdWRlZEV2ZW50SWRzIiwiZXZlbnQiLCJjb21tZW5jZV90aW1lIiwic3RhcnRfdGltZSIsImlzTGl2ZUZsYWciLCJpc19saXZlIiwiaG9tZVRlYW0iLCJob21lX3RlYW0iLCJhd2F5VGVhbSIsImF3YXlfdGVhbSIsImdhbWVTdGFydCIsImlzTmFOIiwiZ2V0VGltZSIsIm1zU2luY2VTdGFydCIsImlzTGl2ZSIsImtleXNCeUV2ZW50TWFya2V0IiwiZ3JvdXBLZXkiLCJtYXJrZXRLZXlzIiwiZXZlbnREYXRhIiwiYm9va1NlbGVjdGlvbnMiLCJyYXdCb29rIiwicG9wIiwiYmFzZVNlbGVjdGlvbktleXMiLCJzZWxlY3Rpb25zIiwiT2JqZWN0IiwidmFsdWVzIiwic2VsIiwiZW50cmllcyIsInBsYXllclJhdyIsImxpbmVTdHIiLCJyYXdNYXJrZXQiLCJyYXdfbWFya2V0IiwidGVhbVNpZGUiLCJiYXNlS2V5IiwicGxheWVyIiwibGluZSIsInBhaXJLZXkiLCJwYWlyIiwicGxheWVyRGlzcGxheSIsInBsYXllcklkIiwidGVhbSIsIm1hcmtldERpc3BsYXkiLCJvdmVyIiwiYmVzdCIsInVuZGVyIiwibWF0Y2hlc1RlYW1TaWRlIiwib3ZlcktleSIsInllc0tleSIsIm1sS2V5Iiwib3ZlclNlbCIsImxvY2tlZCIsIm92ZXJQcmljZSIsImxpbWl0cyIsIm1heCIsImJvb2tPZmZlciIsImJvb2tJZCIsImJvb2tOYW1lIiwicHJpY2VEZWNpbWFsIiwicHJpY2VfZGVjaW1hbCIsImxpbmsiLCJtb2JpbGVMaW5rIiwibW9iaWxlX2xpbmsiLCJzZ3AiLCJ1cGRhdGVkIiwicGxheWVyX2lkIiwidW5kZXJLZXkiLCJub0tleSIsInVuZGVyU2VsIiwidW5kZXJQcmljZSIsInNoYXJwT3ZlciIsImdldFNoYXJwT2Rkc0ZvckN1c3RvbUNvbmZpZyIsImdldFNoYXJwT2Rkc0ZvclByZXNldCIsInNoYXJwVW5kZXIiLCJzaGFycE92ZXJSZWZzIiwiYmxlbmRlZEZyb20iLCJzb3VyY2UiLCJzaGFycFVuZGVyUmVmcyIsInNoYXJlZFJlZkNvdW50IiwiQXJyYXkiLCJmcm9tIiwiZGV2aWdSZXN1bHRzIiwiZWZmZWN0aXZlUHJlc2V0IiwiYm90aFNpZGVzQm9va3MiLCJzaGFycFJlZmVyZW5jZSIsInNpZGVzIiwiZXhjbHVkZWRCb29rcyIsInNpZGUiLCJzaWRlRGF0YSIsIm9wcG9zaXRlU2lkZSIsIm9wcG9zaXRlRGF0YSIsImJvb2tzV2l0aEVWIiwiZXZDYWxjIiwiaXNFeGNsdWRlZCIsImJldHRhYmxlQm9va3MiLCJiZXN0Qm9vayIsImZpbmQiLCJhbGxCb29rc1dpdGhFViIsImV2UGVyY2VudCIsImlzU2hhcnBSZWYiLCJtYXJrZXRLZXkiLCJvcHAiLCJwbGF5ZXJOYW1lIiwicGxheWVyVGVhbSIsInBsYXllclBvc2l0aW9uIiwiYWxsQm9va3MiLCJvcHBvc2l0ZUJvb2tzIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiRVhDTFVERURfRlJPTV9BVkVSQUdFIiwiUlNJX0JPT0tTIiwiZmlsdGVyQm9va3NGb3JBdmVyYWdlIiwiZmlsdGVyZWQiLCJyc2lCb29rcyIsIm90aGVyQm9va3MiLCJyc2lCeVByaWNlIiwicm91bmRlZCIsInJvdW5kIiwicHJlc2V0Q29uZmlnIiwiZmlsdGVyZWRCb29rcyIsImJsZW5kSW5wdXRzIiwib2RkcyIsIndlaWdodCIsImJsZW5kZWRPZGRzIiwicHJlc2V0Qm9va3MiLCJib29rTWFwIiwiYnVpbGRCb29rTG9va3VwTWFwIiwidGFyZ2V0Qm9vayIsIm1hdGNoIiwibm9ybWFsaXplQm9va0lkRm9yU2hhcnAiLCJub3JtYWxpemVkIiwiY29uZmlnIiwidG90YWxBdmFpbGFibGVXZWlnaHQiLCJub3JtYWxpemVkQm9va0lkIiwibm9ybWFsaXphdGlvbkZhY3RvciIsImlucHV0Iiwic291cmNlQm9va3MiLCJjaGFyQXQiLCJhY3RpdmVTZXQiLCJzbWVtYmVycyIsInNjYW5LZXlzIiwiYWxsS2V5cyIsIkJBVENIX1NJWkUiLCJiYXRjaCIsImJhdGNoUmVzdWx0cyIsInBhdHRlcm4iLCJjdXJzb3IiLCJpdGVyYXRpb25zIiwiTUFYX0lURVJBVElPTlMiLCJyZXN1bHQiLCJzY2FuIiwiY291bnQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./app/api/v2/positive-ev/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/ev/constants.ts":
/*!*****************************!*\
  !*** ./lib/ev/constants.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALL_DEVIG_METHODS: () => (/* binding */ ALL_DEVIG_METHODS),\n/* harmony export */   DEFAULT_DEVIG_METHODS: () => (/* binding */ DEFAULT_DEVIG_METHODS),\n/* harmony export */   DEVIG_METHODS: () => (/* binding */ DEVIG_METHODS),\n/* harmony export */   EV_THRESHOLDS: () => (/* binding */ EV_THRESHOLDS),\n/* harmony export */   NON_TWO_WAY_MARKETS: () => (/* binding */ NON_TWO_WAY_MARKETS),\n/* harmony export */   POSITIVE_EV_DEFAULTS: () => (/* binding */ POSITIVE_EV_DEFAULTS),\n/* harmony export */   SHARP_BOOKS: () => (/* binding */ SHARP_BOOKS),\n/* harmony export */   SHARP_PRESETS: () => (/* binding */ SHARP_PRESETS),\n/* harmony export */   SOFT_BOOKS: () => (/* binding */ SOFT_BOOKS),\n/* harmony export */   SUPPORTED_SPORTS: () => (/* binding */ SUPPORTED_SPORTS),\n/* harmony export */   TWO_WAY_MARKETS: () => (/* binding */ TWO_WAY_MARKETS)\n/* harmony export */ });\n/**\n * Positive EV Constants\n * \n * Sharp book mappings, preset configurations, and default values\n * for the +EV tool.\n */ // =============================================================================\n// Sharp Book Definitions\n// =============================================================================\n/**\n * Sharp/reference books available in the system\n * These are considered \"market makers\" with efficient pricing\n */ const SHARP_BOOKS = {\n    pinnacle: {\n        id: \"pinnacle\",\n        name: \"Pinnacle\",\n        tier: \"primary\",\n        description: \"Most respected sharp book globally\"\n    },\n    circa: {\n        id: \"circa\",\n        name: \"Circa\",\n        tier: \"primary\",\n        description: \"Las Vegas sharp book known for high limits\"\n    },\n    prophetx: {\n        id: \"prophetx\",\n        name: \"ProphetX\",\n        tier: \"primary\",\n        description: \"Sharp pricing with high limits and SGP support\"\n    },\n    hardrock: {\n        id: \"hardrock\",\n        name: \"Hard Rock\",\n        tier: \"secondary\",\n        description: \"Sharp pricing, especially for player props\"\n    },\n    thescore: {\n        id: \"thescore\",\n        name: \"theScore\",\n        tier: \"secondary\",\n        description: \"Canadian book with sharp lines\"\n    },\n    bookmaker: {\n        id: \"bookmaker\",\n        name: \"Bookmaker\",\n        tier: \"secondary\",\n        description: \"Offshore sharp book\"\n    }\n};\n/**\n * Soft/retail books - these are compared against sharp references\n */ const SOFT_BOOKS = [\n    \"draftkings\",\n    \"fanduel\",\n    \"betmgm\",\n    \"caesars\",\n    \"bet365\",\n    \"pointsbet\",\n    \"wynnbet\",\n    \"betrivers\",\n    \"unibet\",\n    \"foxbet\",\n    \"barstool\",\n    \"superbook\",\n    \"betfred\",\n    \"espnbet\",\n    \"fanatics\",\n    \"fliff\",\n    \"prizepicks\",\n    \"underdog\"\n];\n// =============================================================================\n// Sharp Preset Configurations\n// =============================================================================\n/**\n * Pre-configured sharp reference presets\n */ const SHARP_PRESETS = {\n    pinnacle: {\n        id: \"pinnacle\",\n        name: \"Pinnacle\",\n        label: \"Pinnacle\",\n        description: \"Uses Pinnacle as the sole sharp reference. Most common and reliable baseline.\",\n        books: [\n            {\n                bookId: \"pinnacle\",\n                weight: 1.0\n            }\n        ]\n    },\n    circa: {\n        id: \"circa\",\n        name: \"Circa\",\n        label: \"Circa\",\n        description: \"Uses Circa as the sole sharp reference. Top US-based sharp book.\",\n        books: [\n            {\n                bookId: \"circa\",\n                weight: 1.0\n            }\n        ]\n    },\n    betonline: {\n        id: \"betonline\",\n        name: \"BetOnline\",\n        label: \"BetOnline\",\n        description: \"Uses BetOnline as the sole sharp reference. Offshore sharp book with high limits.\",\n        books: [\n            {\n                bookId: \"betonline\",\n                weight: 1.0\n            }\n        ]\n    },\n    prophetx: {\n        id: \"prophetx\",\n        name: \"ProphetX\",\n        label: \"ProphetX\",\n        description: \"Uses ProphetX as the sole sharp reference. Sharp pricing with high limits.\",\n        books: [\n            {\n                bookId: \"prophetx\",\n                weight: 1.0\n            }\n        ]\n    },\n    pinnacle_circa: {\n        id: \"pinnacle_circa\",\n        name: \"Pinnacle + Circa\",\n        label: \"Pinnacle + Circa\",\n        description: \"Blends Pinnacle and Circa odds (50/50). Good for US markets.\",\n        books: [\n            {\n                bookId: \"pinnacle\",\n                weight: 0.5\n            },\n            {\n                bookId: \"circa\",\n                weight: 0.5\n            }\n        ]\n    },\n    hardrock_thescore: {\n        id: \"hardrock_thescore\",\n        name: \"Hard Rock + theScore\",\n        label: \"Hard Rock + theScore\",\n        description: \"Alternative sharp blend using Hard Rock and theScore.\",\n        books: [\n            {\n                bookId: \"hardrock\",\n                weight: 0.5\n            },\n            {\n                bookId: \"thescore\",\n                weight: 0.5\n            }\n        ]\n    },\n    draftkings: {\n        id: \"draftkings\",\n        name: \"DraftKings\",\n        label: \"DraftKings\",\n        description: \"Uses DraftKings as reference. Major US retail book.\",\n        books: [\n            {\n                bookId: \"draftkings\",\n                weight: 1.0\n            }\n        ]\n    },\n    fanduel: {\n        id: \"fanduel\",\n        name: \"FanDuel\",\n        label: \"FanDuel\",\n        description: \"Uses FanDuel as reference. Major US retail book.\",\n        books: [\n            {\n                bookId: \"fanduel\",\n                weight: 1.0\n            }\n        ]\n    },\n    betmgm: {\n        id: \"betmgm\",\n        name: \"BetMGM\",\n        label: \"BetMGM\",\n        description: \"Uses BetMGM as reference. Major US retail book.\",\n        books: [\n            {\n                bookId: \"betmgm\",\n                weight: 1.0\n            }\n        ]\n    },\n    caesars: {\n        id: \"caesars\",\n        name: \"Caesars\",\n        label: \"Caesars\",\n        description: \"Uses Caesars as reference. Major US retail book.\",\n        books: [\n            {\n                bookId: \"caesars\",\n                weight: 1.0\n            }\n        ]\n    },\n    hardrock: {\n        id: \"hardrock\",\n        name: \"Hard Rock\",\n        label: \"Hard Rock\",\n        description: \"Uses Hard Rock as reference. Known for sharp player props.\",\n        books: [\n            {\n                bookId: \"hardrock\",\n                weight: 1.0\n            }\n        ]\n    },\n    bet365: {\n        id: \"bet365\",\n        name: \"Bet365\",\n        label: \"Bet365\",\n        description: \"Uses Bet365 as reference. Global sportsbook with broad coverage.\",\n        books: [\n            {\n                bookId: \"bet365\",\n                weight: 1.0\n            }\n        ]\n    },\n    thescore: {\n        id: \"thescore\",\n        name: \"theScore\",\n        label: \"theScore\",\n        description: \"Uses theScore as reference. Canadian retail book.\",\n        books: [\n            {\n                bookId: \"thescore\",\n                weight: 1.0\n            }\n        ]\n    },\n    ballybet: {\n        id: \"ballybet\",\n        name: \"Bally Bet\",\n        label: \"Bally Bet\",\n        description: \"Uses Bally Bet as reference. Retail sportsbook.\",\n        books: [\n            {\n                bookId: \"ballybet\",\n                weight: 1.0\n            }\n        ]\n    },\n    betrivers: {\n        id: \"betrivers\",\n        name: \"BetRivers\",\n        label: \"BetRivers\",\n        description: \"Uses BetRivers as reference. Retail sportsbook.\",\n        books: [\n            {\n                bookId: \"betrivers\",\n                weight: 1.0\n            }\n        ]\n    },\n    fanatics: {\n        id: \"fanatics\",\n        name: \"Fanatics\",\n        label: \"Fanatics\",\n        description: \"Uses Fanatics as reference. Retail sportsbook.\",\n        books: [\n            {\n                bookId: \"fanatics\",\n                weight: 1.0\n            }\n        ]\n    },\n    polymarket: {\n        id: \"polymarket\",\n        name: \"Polymarket\",\n        label: \"Polymarket\",\n        description: \"Uses Polymarket as reference. Decentralized prediction market with high liquidity.\",\n        books: [\n            {\n                bookId: \"polymarket\",\n                weight: 1.0\n            }\n        ]\n    },\n    kalshi: {\n        id: \"kalshi\",\n        name: \"Kalshi\",\n        label: \"Kalshi\",\n        description: \"Uses Kalshi as reference. CFTC-regulated prediction market.\",\n        books: [\n            {\n                bookId: \"kalshi\",\n                weight: 1.0\n            }\n        ]\n    },\n    market_average: {\n        id: \"market_average\",\n        name: \"Market Average\",\n        label: \"Market Average\",\n        description: \"Averages implied probabilities across ALL books for each market. Uses market consensus as true probability.\",\n        books: []\n    },\n    custom: {\n        id: \"custom\",\n        name: \"Custom\",\n        label: \"Custom\",\n        description: \"User-defined blend of sharp books with custom weights.\",\n        books: []\n    }\n};\n// =============================================================================\n// De-vig Method Configurations\n// =============================================================================\n/**\n * De-vig method metadata\n */ const DEVIG_METHODS = {\n    power: {\n        id: \"power\",\n        name: \"Power\",\n        label: \"Power\",\n        description: \"Finds exponent k where p_over^k + p_under^k = 1. Handles favorite/longshot bias well.\",\n        tier: \"primary\",\n        complexity: \"moderate\"\n    },\n    multiplicative: {\n        id: \"multiplicative\",\n        name: \"Multiplicative\",\n        label: \"Multiplicative\",\n        description: \"Rescales implied probabilities proportionally to sum to 1. Simple and stable baseline.\",\n        tier: \"primary\",\n        complexity: \"simple\"\n    },\n    additive: {\n        id: \"additive\",\n        name: \"Additive\",\n        label: \"Additive\",\n        description: \"Subtracts equal margin from each side. Works best for balanced markets.\",\n        tier: \"secondary\",\n        complexity: \"simple\"\n    },\n    probit: {\n        id: \"probit\",\n        name: \"Probit\",\n        label: \"Probit\",\n        description: \"Uses normal quantile transformation for statistically smoother correction.\",\n        tier: \"secondary\",\n        complexity: \"complex\"\n    }\n};\n/**\n * Default de-vig methods to use (Tier A)\n */ const DEFAULT_DEVIG_METHODS = [\n    \"power\",\n    \"multiplicative\"\n];\n/**\n * All de-vig methods in recommended order\n */ const ALL_DEVIG_METHODS = [\n    \"power\",\n    \"multiplicative\",\n    \"additive\",\n    \"probit\"\n];\n// =============================================================================\n// Default Values\n// =============================================================================\n/**\n * Default configuration values for the +EV tool\n */ const POSITIVE_EV_DEFAULTS = {\n    // Sharp reference\n    sharpPreset: \"pinnacle\",\n    // De-vig\n    devigMethods: DEFAULT_DEVIG_METHODS,\n    // Filters\n    minEV: 0,\n    maxEV: 20,\n    limit: 100,\n    // Kelly\n    showKelly: true,\n    kellyFraction: 0.25,\n    kellyBankroll: 1000,\n    // API\n    cacheSeconds: 30\n};\n// =============================================================================\n// EV Thresholds\n// =============================================================================\n/**\n * EV percentage thresholds for UI display\n */ const EV_THRESHOLDS = {\n    /** Minimum to show as +EV */ positive: 0,\n    /** \"Good\" EV threshold */ good: 2,\n    /** \"Great\" EV threshold */ great: 5,\n    /** \"Excellent\" EV threshold (rare) */ excellent: 10,\n    /** Suspicious - likely data error or closing line */ suspicious: 15,\n    /** Maximum allowed - above this is filtered as error */ maximum: 25\n};\n// =============================================================================\n// Sport-specific Configurations\n// =============================================================================\n/**\n * Sports that support the +EV tool\n */ const SUPPORTED_SPORTS = [\n    \"nba\",\n    \"nfl\",\n    \"nhl\",\n    \"mlb\",\n    \"ncaab\",\n    \"ncaaf\",\n    \"soccer\",\n    \"tennis\",\n    \"mma\"\n];\n/**\n * Two-way market types that work with de-vigging\n * (markets with exactly 2 outcomes that sum to ~100%)\n */ const TWO_WAY_MARKETS = [\n    // Player props\n    \"player_points\",\n    \"player_rebounds\",\n    \"player_assists\",\n    \"player_threes\",\n    \"player_steals\",\n    \"player_blocks\",\n    \"player_turnovers\",\n    \"player_pts_rebs\",\n    \"player_pts_asts\",\n    \"player_rebs_asts\",\n    \"player_pts_rebs_asts\",\n    \"player_steals_blocks\",\n    \"player_fantasy_score\",\n    \"player_double_double\",\n    \"player_triple_double\",\n    // NFL player props\n    \"player_passing_yards\",\n    \"player_passing_tds\",\n    \"player_rushing_yards\",\n    \"player_rushing_tds\",\n    \"player_receiving_yards\",\n    \"player_receiving_tds\",\n    \"player_receptions\",\n    \"player_passing_attempts\",\n    \"player_rushing_attempts\",\n    \"player_interceptions\",\n    // NHL player props\n    \"player_goals\",\n    \"player_shots\",\n    \"player_saves\",\n    // Game markets\n    \"total\",\n    \"spread\",\n    \"moneyline\",\n    \"1st_half_total\",\n    \"1st_half_spread\",\n    \"1st_quarter_total\",\n    \"1st_quarter_spread\",\n    // Yes/No markets\n    \"both_teams_to_score\",\n    \"over_under_goals\"\n];\n/**\n * Markets that are NOT suitable for standard 2-way de-vigging\n * (3+ way markets, or markets with correlation issues)\n */ const NON_TWO_WAY_MARKETS = [\n    \"first_basket\",\n    \"first_field_goal\",\n    \"first_touchdown\",\n    \"anytime_touchdown\",\n    \"first_goal\",\n    \"exact_score\",\n    \"correct_score\",\n    \"race_to_points\"\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cy93ZWIvbGliL2V2L2NvbnN0YW50cy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFBvc2l0aXZlIEVWIENvbnN0YW50c1xuICogXG4gKiBTaGFycCBib29rIG1hcHBpbmdzLCBwcmVzZXQgY29uZmlndXJhdGlvbnMsIGFuZCBkZWZhdWx0IHZhbHVlc1xuICogZm9yIHRoZSArRVYgdG9vbC5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFNoYXJwUHJlc2V0LCBTaGFycFByZXNldENvbmZpZywgRGV2aWdNZXRob2QgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU2hhcnAgQm9vayBEZWZpbml0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBTaGFycC9yZWZlcmVuY2UgYm9va3MgYXZhaWxhYmxlIGluIHRoZSBzeXN0ZW1cbiAqIFRoZXNlIGFyZSBjb25zaWRlcmVkIFwibWFya2V0IG1ha2Vyc1wiIHdpdGggZWZmaWNpZW50IHByaWNpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFNIQVJQX0JPT0tTID0ge1xuICBwaW5uYWNsZToge1xuICAgIGlkOiBcInBpbm5hY2xlXCIsXG4gICAgbmFtZTogXCJQaW5uYWNsZVwiLFxuICAgIHRpZXI6IFwicHJpbWFyeVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk1vc3QgcmVzcGVjdGVkIHNoYXJwIGJvb2sgZ2xvYmFsbHlcIixcbiAgfSxcbiAgY2lyY2E6IHtcbiAgICBpZDogXCJjaXJjYVwiLFxuICAgIG5hbWU6IFwiQ2lyY2FcIixcbiAgICB0aWVyOiBcInByaW1hcnlcIixcbiAgICBkZXNjcmlwdGlvbjogXCJMYXMgVmVnYXMgc2hhcnAgYm9vayBrbm93biBmb3IgaGlnaCBsaW1pdHNcIixcbiAgfSxcbiAgcHJvcGhldHg6IHtcbiAgICBpZDogXCJwcm9waGV0eFwiLFxuICAgIG5hbWU6IFwiUHJvcGhldFhcIixcbiAgICB0aWVyOiBcInByaW1hcnlcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTaGFycCBwcmljaW5nIHdpdGggaGlnaCBsaW1pdHMgYW5kIFNHUCBzdXBwb3J0XCIsXG4gIH0sXG4gIGhhcmRyb2NrOiB7XG4gICAgaWQ6IFwiaGFyZHJvY2tcIixcbiAgICBuYW1lOiBcIkhhcmQgUm9ja1wiLFxuICAgIHRpZXI6IFwic2Vjb25kYXJ5XCIsXG4gICAgZGVzY3JpcHRpb246IFwiU2hhcnAgcHJpY2luZywgZXNwZWNpYWxseSBmb3IgcGxheWVyIHByb3BzXCIsXG4gIH0sXG4gIHRoZXNjb3JlOiB7XG4gICAgaWQ6IFwidGhlc2NvcmVcIixcbiAgICBuYW1lOiBcInRoZVNjb3JlXCIsXG4gICAgdGllcjogXCJzZWNvbmRhcnlcIixcbiAgICBkZXNjcmlwdGlvbjogXCJDYW5hZGlhbiBib29rIHdpdGggc2hhcnAgbGluZXNcIixcbiAgfSxcbiAgYm9va21ha2VyOiB7XG4gICAgaWQ6IFwiYm9va21ha2VyXCIsXG4gICAgbmFtZTogXCJCb29rbWFrZXJcIixcbiAgICB0aWVyOiBcInNlY29uZGFyeVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk9mZnNob3JlIHNoYXJwIGJvb2tcIixcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogU29mdC9yZXRhaWwgYm9va3MgLSB0aGVzZSBhcmUgY29tcGFyZWQgYWdhaW5zdCBzaGFycCByZWZlcmVuY2VzXG4gKi9cbmV4cG9ydCBjb25zdCBTT0ZUX0JPT0tTID0gW1xuICBcImRyYWZ0a2luZ3NcIixcbiAgXCJmYW5kdWVsXCIsXG4gIFwiYmV0bWdtXCIsXG4gIFwiY2Flc2Fyc1wiLFxuICBcImJldDM2NVwiLFxuICBcInBvaW50c2JldFwiLFxuICBcInd5bm5iZXRcIixcbiAgXCJiZXRyaXZlcnNcIixcbiAgXCJ1bmliZXRcIixcbiAgXCJmb3hiZXRcIixcbiAgXCJiYXJzdG9vbFwiLFxuICBcInN1cGVyYm9va1wiLFxuICBcImJldGZyZWRcIixcbiAgXCJlc3BuYmV0XCIsXG4gIFwiZmFuYXRpY3NcIixcbiAgXCJmbGlmZlwiLFxuICBcInByaXplcGlja3NcIixcbiAgXCJ1bmRlcmRvZ1wiLFxuXSBhcyBjb25zdDtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNoYXJwIFByZXNldCBDb25maWd1cmF0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBQcmUtY29uZmlndXJlZCBzaGFycCByZWZlcmVuY2UgcHJlc2V0c1xuICovXG5leHBvcnQgY29uc3QgU0hBUlBfUFJFU0VUUzogUmVjb3JkPFNoYXJwUHJlc2V0LCBTaGFycFByZXNldENvbmZpZz4gPSB7XG4gIHBpbm5hY2xlOiB7XG4gICAgaWQ6IFwicGlubmFjbGVcIixcbiAgICBuYW1lOiBcIlBpbm5hY2xlXCIsXG4gICAgbGFiZWw6IFwiUGlubmFjbGVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJVc2VzIFBpbm5hY2xlIGFzIHRoZSBzb2xlIHNoYXJwIHJlZmVyZW5jZS4gTW9zdCBjb21tb24gYW5kIHJlbGlhYmxlIGJhc2VsaW5lLlwiLFxuICAgIGJvb2tzOiBbeyBib29rSWQ6IFwicGlubmFjbGVcIiwgd2VpZ2h0OiAxLjAgfV0sXG4gIH0sXG4gIGNpcmNhOiB7XG4gICAgaWQ6IFwiY2lyY2FcIixcbiAgICBuYW1lOiBcIkNpcmNhXCIsXG4gICAgbGFiZWw6IFwiQ2lyY2FcIixcbiAgICBkZXNjcmlwdGlvbjogXCJVc2VzIENpcmNhIGFzIHRoZSBzb2xlIHNoYXJwIHJlZmVyZW5jZS4gVG9wIFVTLWJhc2VkIHNoYXJwIGJvb2suXCIsXG4gICAgYm9va3M6IFt7IGJvb2tJZDogXCJjaXJjYVwiLCB3ZWlnaHQ6IDEuMCB9XSxcbiAgfSxcbiAgYmV0b25saW5lOiB7XG4gICAgaWQ6IFwiYmV0b25saW5lXCIsXG4gICAgbmFtZTogXCJCZXRPbmxpbmVcIixcbiAgICBsYWJlbDogXCJCZXRPbmxpbmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJVc2VzIEJldE9ubGluZSBhcyB0aGUgc29sZSBzaGFycCByZWZlcmVuY2UuIE9mZnNob3JlIHNoYXJwIGJvb2sgd2l0aCBoaWdoIGxpbWl0cy5cIixcbiAgICBib29rczogW3sgYm9va0lkOiBcImJldG9ubGluZVwiLCB3ZWlnaHQ6IDEuMCB9XSxcbiAgfSxcbiAgcHJvcGhldHg6IHtcbiAgICBpZDogXCJwcm9waGV0eFwiLFxuICAgIG5hbWU6IFwiUHJvcGhldFhcIixcbiAgICBsYWJlbDogXCJQcm9waGV0WFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlVzZXMgUHJvcGhldFggYXMgdGhlIHNvbGUgc2hhcnAgcmVmZXJlbmNlLiBTaGFycCBwcmljaW5nIHdpdGggaGlnaCBsaW1pdHMuXCIsXG4gICAgYm9va3M6IFt7IGJvb2tJZDogXCJwcm9waGV0eFwiLCB3ZWlnaHQ6IDEuMCB9XSxcbiAgfSxcbiAgcGlubmFjbGVfY2lyY2E6IHtcbiAgICBpZDogXCJwaW5uYWNsZV9jaXJjYVwiLFxuICAgIG5hbWU6IFwiUGlubmFjbGUgKyBDaXJjYVwiLFxuICAgIGxhYmVsOiBcIlBpbm5hY2xlICsgQ2lyY2FcIixcbiAgICBkZXNjcmlwdGlvbjogXCJCbGVuZHMgUGlubmFjbGUgYW5kIENpcmNhIG9kZHMgKDUwLzUwKS4gR29vZCBmb3IgVVMgbWFya2V0cy5cIixcbiAgICBib29rczogW1xuICAgICAgeyBib29rSWQ6IFwicGlubmFjbGVcIiwgd2VpZ2h0OiAwLjUgfSxcbiAgICAgIHsgYm9va0lkOiBcImNpcmNhXCIsIHdlaWdodDogMC41IH0sXG4gICAgXSxcbiAgfSxcbiAgaGFyZHJvY2tfdGhlc2NvcmU6IHtcbiAgICBpZDogXCJoYXJkcm9ja190aGVzY29yZVwiLFxuICAgIG5hbWU6IFwiSGFyZCBSb2NrICsgdGhlU2NvcmVcIixcbiAgICBsYWJlbDogXCJIYXJkIFJvY2sgKyB0aGVTY29yZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkFsdGVybmF0aXZlIHNoYXJwIGJsZW5kIHVzaW5nIEhhcmQgUm9jayBhbmQgdGhlU2NvcmUuXCIsXG4gICAgYm9va3M6IFtcbiAgICAgIHsgYm9va0lkOiBcImhhcmRyb2NrXCIsIHdlaWdodDogMC41IH0sXG4gICAgICB7IGJvb2tJZDogXCJ0aGVzY29yZVwiLCB3ZWlnaHQ6IDAuNSB9LFxuICAgIF0sXG4gIH0sXG4gIGRyYWZ0a2luZ3M6IHtcbiAgICBpZDogXCJkcmFmdGtpbmdzXCIsXG4gICAgbmFtZTogXCJEcmFmdEtpbmdzXCIsXG4gICAgbGFiZWw6IFwiRHJhZnRLaW5nc1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlVzZXMgRHJhZnRLaW5ncyBhcyByZWZlcmVuY2UuIE1ham9yIFVTIHJldGFpbCBib29rLlwiLFxuICAgIGJvb2tzOiBbeyBib29rSWQ6IFwiZHJhZnRraW5nc1wiLCB3ZWlnaHQ6IDEuMCB9XSxcbiAgfSxcbiAgZmFuZHVlbDoge1xuICAgIGlkOiBcImZhbmR1ZWxcIixcbiAgICBuYW1lOiBcIkZhbkR1ZWxcIixcbiAgICBsYWJlbDogXCJGYW5EdWVsXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVXNlcyBGYW5EdWVsIGFzIHJlZmVyZW5jZS4gTWFqb3IgVVMgcmV0YWlsIGJvb2suXCIsXG4gICAgYm9va3M6IFt7IGJvb2tJZDogXCJmYW5kdWVsXCIsIHdlaWdodDogMS4wIH1dLFxuICB9LFxuICBiZXRtZ206IHtcbiAgICBpZDogXCJiZXRtZ21cIixcbiAgICBuYW1lOiBcIkJldE1HTVwiLFxuICAgIGxhYmVsOiBcIkJldE1HTVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlVzZXMgQmV0TUdNIGFzIHJlZmVyZW5jZS4gTWFqb3IgVVMgcmV0YWlsIGJvb2suXCIsXG4gICAgYm9va3M6IFt7IGJvb2tJZDogXCJiZXRtZ21cIiwgd2VpZ2h0OiAxLjAgfV0sXG4gIH0sXG4gIGNhZXNhcnM6IHtcbiAgICBpZDogXCJjYWVzYXJzXCIsXG4gICAgbmFtZTogXCJDYWVzYXJzXCIsXG4gICAgbGFiZWw6IFwiQ2Flc2Fyc1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlVzZXMgQ2Flc2FycyBhcyByZWZlcmVuY2UuIE1ham9yIFVTIHJldGFpbCBib29rLlwiLFxuICAgIGJvb2tzOiBbeyBib29rSWQ6IFwiY2Flc2Fyc1wiLCB3ZWlnaHQ6IDEuMCB9XSxcbiAgfSxcbiAgaGFyZHJvY2s6IHtcbiAgICBpZDogXCJoYXJkcm9ja1wiLFxuICAgIG5hbWU6IFwiSGFyZCBSb2NrXCIsXG4gICAgbGFiZWw6IFwiSGFyZCBSb2NrXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVXNlcyBIYXJkIFJvY2sgYXMgcmVmZXJlbmNlLiBLbm93biBmb3Igc2hhcnAgcGxheWVyIHByb3BzLlwiLFxuICAgIGJvb2tzOiBbeyBib29rSWQ6IFwiaGFyZHJvY2tcIiwgd2VpZ2h0OiAxLjAgfV0sXG4gIH0sXG4gIGJldDM2NToge1xuICAgIGlkOiBcImJldDM2NVwiLFxuICAgIG5hbWU6IFwiQmV0MzY1XCIsXG4gICAgbGFiZWw6IFwiQmV0MzY1XCIsXG4gICAgZGVzY3JpcHRpb246IFwiVXNlcyBCZXQzNjUgYXMgcmVmZXJlbmNlLiBHbG9iYWwgc3BvcnRzYm9vayB3aXRoIGJyb2FkIGNvdmVyYWdlLlwiLFxuICAgIGJvb2tzOiBbeyBib29rSWQ6IFwiYmV0MzY1XCIsIHdlaWdodDogMS4wIH1dLFxuICB9LFxuICB0aGVzY29yZToge1xuICAgIGlkOiBcInRoZXNjb3JlXCIsXG4gICAgbmFtZTogXCJ0aGVTY29yZVwiLFxuICAgIGxhYmVsOiBcInRoZVNjb3JlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVXNlcyB0aGVTY29yZSBhcyByZWZlcmVuY2UuIENhbmFkaWFuIHJldGFpbCBib29rLlwiLFxuICAgIGJvb2tzOiBbeyBib29rSWQ6IFwidGhlc2NvcmVcIiwgd2VpZ2h0OiAxLjAgfV0sXG4gIH0sXG4gIGJhbGx5YmV0OiB7XG4gICAgaWQ6IFwiYmFsbHliZXRcIixcbiAgICBuYW1lOiBcIkJhbGx5IEJldFwiLFxuICAgIGxhYmVsOiBcIkJhbGx5IEJldFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlVzZXMgQmFsbHkgQmV0IGFzIHJlZmVyZW5jZS4gUmV0YWlsIHNwb3J0c2Jvb2suXCIsXG4gICAgYm9va3M6IFt7IGJvb2tJZDogXCJiYWxseWJldFwiLCB3ZWlnaHQ6IDEuMCB9XSxcbiAgfSxcbiAgYmV0cml2ZXJzOiB7XG4gICAgaWQ6IFwiYmV0cml2ZXJzXCIsXG4gICAgbmFtZTogXCJCZXRSaXZlcnNcIixcbiAgICBsYWJlbDogXCJCZXRSaXZlcnNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJVc2VzIEJldFJpdmVycyBhcyByZWZlcmVuY2UuIFJldGFpbCBzcG9ydHNib29rLlwiLFxuICAgIGJvb2tzOiBbeyBib29rSWQ6IFwiYmV0cml2ZXJzXCIsIHdlaWdodDogMS4wIH1dLFxuICB9LFxuICBmYW5hdGljczoge1xuICAgIGlkOiBcImZhbmF0aWNzXCIsXG4gICAgbmFtZTogXCJGYW5hdGljc1wiLFxuICAgIGxhYmVsOiBcIkZhbmF0aWNzXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVXNlcyBGYW5hdGljcyBhcyByZWZlcmVuY2UuIFJldGFpbCBzcG9ydHNib29rLlwiLFxuICAgIGJvb2tzOiBbeyBib29rSWQ6IFwiZmFuYXRpY3NcIiwgd2VpZ2h0OiAxLjAgfV0sXG4gIH0sXG4gIHBvbHltYXJrZXQ6IHtcbiAgICBpZDogXCJwb2x5bWFya2V0XCIsXG4gICAgbmFtZTogXCJQb2x5bWFya2V0XCIsXG4gICAgbGFiZWw6IFwiUG9seW1hcmtldFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlVzZXMgUG9seW1hcmtldCBhcyByZWZlcmVuY2UuIERlY2VudHJhbGl6ZWQgcHJlZGljdGlvbiBtYXJrZXQgd2l0aCBoaWdoIGxpcXVpZGl0eS5cIixcbiAgICBib29rczogW3sgYm9va0lkOiBcInBvbHltYXJrZXRcIiwgd2VpZ2h0OiAxLjAgfV0sXG4gIH0sXG4gIGthbHNoaToge1xuICAgIGlkOiBcImthbHNoaVwiLFxuICAgIG5hbWU6IFwiS2Fsc2hpXCIsXG4gICAgbGFiZWw6IFwiS2Fsc2hpXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVXNlcyBLYWxzaGkgYXMgcmVmZXJlbmNlLiBDRlRDLXJlZ3VsYXRlZCBwcmVkaWN0aW9uIG1hcmtldC5cIixcbiAgICBib29rczogW3sgYm9va0lkOiBcImthbHNoaVwiLCB3ZWlnaHQ6IDEuMCB9XSxcbiAgfSxcbiAgbWFya2V0X2F2ZXJhZ2U6IHtcbiAgICBpZDogXCJtYXJrZXRfYXZlcmFnZVwiLFxuICAgIG5hbWU6IFwiTWFya2V0IEF2ZXJhZ2VcIixcbiAgICBsYWJlbDogXCJNYXJrZXQgQXZlcmFnZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkF2ZXJhZ2VzIGltcGxpZWQgcHJvYmFiaWxpdGllcyBhY3Jvc3MgQUxMIGJvb2tzIGZvciBlYWNoIG1hcmtldC4gVXNlcyBtYXJrZXQgY29uc2Vuc3VzIGFzIHRydWUgcHJvYmFiaWxpdHkuXCIsXG4gICAgYm9va3M6IFtdLCAvLyBNYXJrZXQgYXZlcmFnZSB1c2VzIGFsbCBhdmFpbGFibGUgYm9va3MgZHluYW1pY2FsbHlcbiAgfSxcbiAgY3VzdG9tOiB7XG4gICAgaWQ6IFwiY3VzdG9tXCIsXG4gICAgbmFtZTogXCJDdXN0b21cIixcbiAgICBsYWJlbDogXCJDdXN0b21cIixcbiAgICBkZXNjcmlwdGlvbjogXCJVc2VyLWRlZmluZWQgYmxlbmQgb2Ygc2hhcnAgYm9va3Mgd2l0aCBjdXN0b20gd2VpZ2h0cy5cIixcbiAgICBib29rczogW10sIC8vIEZpbGxlZCBpbiBieSB1c2VyXG4gIH0sXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRGUtdmlnIE1ldGhvZCBDb25maWd1cmF0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBEZS12aWcgbWV0aG9kIG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBERVZJR19NRVRIT0RTOiBSZWNvcmQ8RGV2aWdNZXRob2QsIHtcbiAgaWQ6IERldmlnTWV0aG9kO1xuICBuYW1lOiBzdHJpbmc7XG4gIGxhYmVsOiBzdHJpbmc7ICAvLyBBbGlhcyBmb3IgbmFtZSwgZm9yIFVJIGNvbnNpc3RlbmN5XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHRpZXI6IFwicHJpbWFyeVwiIHwgXCJzZWNvbmRhcnlcIjtcbiAgY29tcGxleGl0eTogXCJzaW1wbGVcIiB8IFwibW9kZXJhdGVcIiB8IFwiY29tcGxleFwiO1xufT4gPSB7XG4gIHBvd2VyOiB7XG4gICAgaWQ6IFwicG93ZXJcIixcbiAgICBuYW1lOiBcIlBvd2VyXCIsXG4gICAgbGFiZWw6IFwiUG93ZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJGaW5kcyBleHBvbmVudCBrIHdoZXJlIHBfb3Zlcl5rICsgcF91bmRlcl5rID0gMS4gSGFuZGxlcyBmYXZvcml0ZS9sb25nc2hvdCBiaWFzIHdlbGwuXCIsXG4gICAgdGllcjogXCJwcmltYXJ5XCIsXG4gICAgY29tcGxleGl0eTogXCJtb2RlcmF0ZVwiLFxuICB9LFxuICBtdWx0aXBsaWNhdGl2ZToge1xuICAgIGlkOiBcIm11bHRpcGxpY2F0aXZlXCIsXG4gICAgbmFtZTogXCJNdWx0aXBsaWNhdGl2ZVwiLFxuICAgIGxhYmVsOiBcIk11bHRpcGxpY2F0aXZlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUmVzY2FsZXMgaW1wbGllZCBwcm9iYWJpbGl0aWVzIHByb3BvcnRpb25hbGx5IHRvIHN1bSB0byAxLiBTaW1wbGUgYW5kIHN0YWJsZSBiYXNlbGluZS5cIixcbiAgICB0aWVyOiBcInByaW1hcnlcIixcbiAgICBjb21wbGV4aXR5OiBcInNpbXBsZVwiLFxuICB9LFxuICBhZGRpdGl2ZToge1xuICAgIGlkOiBcImFkZGl0aXZlXCIsXG4gICAgbmFtZTogXCJBZGRpdGl2ZVwiLFxuICAgIGxhYmVsOiBcIkFkZGl0aXZlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU3VidHJhY3RzIGVxdWFsIG1hcmdpbiBmcm9tIGVhY2ggc2lkZS4gV29ya3MgYmVzdCBmb3IgYmFsYW5jZWQgbWFya2V0cy5cIixcbiAgICB0aWVyOiBcInNlY29uZGFyeVwiLFxuICAgIGNvbXBsZXhpdHk6IFwic2ltcGxlXCIsXG4gIH0sXG4gIHByb2JpdDoge1xuICAgIGlkOiBcInByb2JpdFwiLFxuICAgIG5hbWU6IFwiUHJvYml0XCIsXG4gICAgbGFiZWw6IFwiUHJvYml0XCIsXG4gICAgZGVzY3JpcHRpb246IFwiVXNlcyBub3JtYWwgcXVhbnRpbGUgdHJhbnNmb3JtYXRpb24gZm9yIHN0YXRpc3RpY2FsbHkgc21vb3RoZXIgY29ycmVjdGlvbi5cIixcbiAgICB0aWVyOiBcInNlY29uZGFyeVwiLFxuICAgIGNvbXBsZXhpdHk6IFwiY29tcGxleFwiLFxuICB9LFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IGRlLXZpZyBtZXRob2RzIHRvIHVzZSAoVGllciBBKVxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9ERVZJR19NRVRIT0RTOiBEZXZpZ01ldGhvZFtdID0gW1wicG93ZXJcIiwgXCJtdWx0aXBsaWNhdGl2ZVwiXTtcblxuLyoqXG4gKiBBbGwgZGUtdmlnIG1ldGhvZHMgaW4gcmVjb21tZW5kZWQgb3JkZXJcbiAqL1xuZXhwb3J0IGNvbnN0IEFMTF9ERVZJR19NRVRIT0RTOiBEZXZpZ01ldGhvZFtdID0gW1wicG93ZXJcIiwgXCJtdWx0aXBsaWNhdGl2ZVwiLCBcImFkZGl0aXZlXCIsIFwicHJvYml0XCJdO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRGVmYXVsdCBWYWx1ZXNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRGVmYXVsdCBjb25maWd1cmF0aW9uIHZhbHVlcyBmb3IgdGhlICtFViB0b29sXG4gKi9cbmV4cG9ydCBjb25zdCBQT1NJVElWRV9FVl9ERUZBVUxUUyA9IHtcbiAgLy8gU2hhcnAgcmVmZXJlbmNlXG4gIHNoYXJwUHJlc2V0OiBcInBpbm5hY2xlXCIgYXMgU2hhcnBQcmVzZXQsXG4gIFxuICAvLyBEZS12aWdcbiAgZGV2aWdNZXRob2RzOiBERUZBVUxUX0RFVklHX01FVEhPRFMsXG4gIFxuICAvLyBGaWx0ZXJzXG4gIG1pbkVWOiAwLCAgICAgICAgICAgLy8gU2hvdyBhbGwgK0VWICg+IDAlKVxuICBtYXhFVjogMjAsICAgICAgICAgIC8vIENhcCBhdCAyMCUgdG8gZmlsdGVyIG91dGxpZXJzL2Vycm9yc1xuICBsaW1pdDogMTAwLCAgICAgICAgIC8vIE1heCByZXN1bHRzIHBlciByZXF1ZXN0XG4gIFxuICAvLyBLZWxseVxuICBzaG93S2VsbHk6IHRydWUsXG4gIGtlbGx5RnJhY3Rpb246IDAuMjUsICAvLyBRdWFydGVyIEtlbGx5IChjb25zZXJ2YXRpdmUpXG4gIGtlbGx5QmFua3JvbGw6IDEwMDAsICAvLyBEZWZhdWx0IGJhbmtyb2xsIGZvciBkaXNwbGF5XG4gIFxuICAvLyBBUElcbiAgY2FjaGVTZWNvbmRzOiAzMCwgICAgIC8vIENhY2hlIGR1cmF0aW9uIGZvciBBUEkgcmVzcG9uc2VzXG59IGFzIGNvbnN0O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRVYgVGhyZXNob2xkc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBFViBwZXJjZW50YWdlIHRocmVzaG9sZHMgZm9yIFVJIGRpc3BsYXlcbiAqL1xuZXhwb3J0IGNvbnN0IEVWX1RIUkVTSE9MRFMgPSB7XG4gIC8qKiBNaW5pbXVtIHRvIHNob3cgYXMgK0VWICovXG4gIHBvc2l0aXZlOiAwLFxuICBcbiAgLyoqIFwiR29vZFwiIEVWIHRocmVzaG9sZCAqL1xuICBnb29kOiAyLFxuICBcbiAgLyoqIFwiR3JlYXRcIiBFViB0aHJlc2hvbGQgKi9cbiAgZ3JlYXQ6IDUsXG4gIFxuICAvKiogXCJFeGNlbGxlbnRcIiBFViB0aHJlc2hvbGQgKHJhcmUpICovXG4gIGV4Y2VsbGVudDogMTAsXG4gIFxuICAvKiogU3VzcGljaW91cyAtIGxpa2VseSBkYXRhIGVycm9yIG9yIGNsb3NpbmcgbGluZSAqL1xuICBzdXNwaWNpb3VzOiAxNSxcbiAgXG4gIC8qKiBNYXhpbXVtIGFsbG93ZWQgLSBhYm92ZSB0aGlzIGlzIGZpbHRlcmVkIGFzIGVycm9yICovXG4gIG1heGltdW06IDI1LFxufSBhcyBjb25zdDtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNwb3J0LXNwZWNpZmljIENvbmZpZ3VyYXRpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFNwb3J0cyB0aGF0IHN1cHBvcnQgdGhlICtFViB0b29sXG4gKi9cbmV4cG9ydCBjb25zdCBTVVBQT1JURURfU1BPUlRTID0gW1xuICBcIm5iYVwiLFxuICBcIm5mbFwiLFxuICBcIm5obFwiLFxuICBcIm1sYlwiLFxuICBcIm5jYWFiXCIsXG4gIFwibmNhYWZcIixcbiAgXCJzb2NjZXJcIixcbiAgXCJ0ZW5uaXNcIixcbiAgXCJtbWFcIixcbl0gYXMgY29uc3Q7XG5cbi8qKlxuICogVHdvLXdheSBtYXJrZXQgdHlwZXMgdGhhdCB3b3JrIHdpdGggZGUtdmlnZ2luZ1xuICogKG1hcmtldHMgd2l0aCBleGFjdGx5IDIgb3V0Y29tZXMgdGhhdCBzdW0gdG8gfjEwMCUpXG4gKi9cbmV4cG9ydCBjb25zdCBUV09fV0FZX01BUktFVFMgPSBbXG4gIC8vIFBsYXllciBwcm9wc1xuICBcInBsYXllcl9wb2ludHNcIixcbiAgXCJwbGF5ZXJfcmVib3VuZHNcIixcbiAgXCJwbGF5ZXJfYXNzaXN0c1wiLFxuICBcInBsYXllcl90aHJlZXNcIixcbiAgXCJwbGF5ZXJfc3RlYWxzXCIsXG4gIFwicGxheWVyX2Jsb2Nrc1wiLFxuICBcInBsYXllcl90dXJub3ZlcnNcIixcbiAgXCJwbGF5ZXJfcHRzX3JlYnNcIixcbiAgXCJwbGF5ZXJfcHRzX2FzdHNcIixcbiAgXCJwbGF5ZXJfcmVic19hc3RzXCIsXG4gIFwicGxheWVyX3B0c19yZWJzX2FzdHNcIixcbiAgXCJwbGF5ZXJfc3RlYWxzX2Jsb2Nrc1wiLFxuICBcInBsYXllcl9mYW50YXN5X3Njb3JlXCIsXG4gIFwicGxheWVyX2RvdWJsZV9kb3VibGVcIixcbiAgXCJwbGF5ZXJfdHJpcGxlX2RvdWJsZVwiLFxuICBcbiAgLy8gTkZMIHBsYXllciBwcm9wc1xuICBcInBsYXllcl9wYXNzaW5nX3lhcmRzXCIsXG4gIFwicGxheWVyX3Bhc3NpbmdfdGRzXCIsXG4gIFwicGxheWVyX3J1c2hpbmdfeWFyZHNcIixcbiAgXCJwbGF5ZXJfcnVzaGluZ190ZHNcIixcbiAgXCJwbGF5ZXJfcmVjZWl2aW5nX3lhcmRzXCIsXG4gIFwicGxheWVyX3JlY2VpdmluZ190ZHNcIixcbiAgXCJwbGF5ZXJfcmVjZXB0aW9uc1wiLFxuICBcInBsYXllcl9wYXNzaW5nX2F0dGVtcHRzXCIsXG4gIFwicGxheWVyX3J1c2hpbmdfYXR0ZW1wdHNcIixcbiAgXCJwbGF5ZXJfaW50ZXJjZXB0aW9uc1wiLFxuICBcbiAgLy8gTkhMIHBsYXllciBwcm9wc1xuICBcInBsYXllcl9nb2Fsc1wiLFxuICBcInBsYXllcl9zaG90c1wiLFxuICBcInBsYXllcl9zYXZlc1wiLFxuICBcbiAgLy8gR2FtZSBtYXJrZXRzXG4gIFwidG90YWxcIixcbiAgXCJzcHJlYWRcIixcbiAgXCJtb25leWxpbmVcIixcbiAgXCIxc3RfaGFsZl90b3RhbFwiLFxuICBcIjFzdF9oYWxmX3NwcmVhZFwiLFxuICBcIjFzdF9xdWFydGVyX3RvdGFsXCIsXG4gIFwiMXN0X3F1YXJ0ZXJfc3ByZWFkXCIsXG4gIFxuICAvLyBZZXMvTm8gbWFya2V0c1xuICBcImJvdGhfdGVhbXNfdG9fc2NvcmVcIixcbiAgXCJvdmVyX3VuZGVyX2dvYWxzXCIsXG5dIGFzIGNvbnN0O1xuXG4vKipcbiAqIE1hcmtldHMgdGhhdCBhcmUgTk9UIHN1aXRhYmxlIGZvciBzdGFuZGFyZCAyLXdheSBkZS12aWdnaW5nXG4gKiAoMysgd2F5IG1hcmtldHMsIG9yIG1hcmtldHMgd2l0aCBjb3JyZWxhdGlvbiBpc3N1ZXMpXG4gKi9cbmV4cG9ydCBjb25zdCBOT05fVFdPX1dBWV9NQVJLRVRTID0gW1xuICBcImZpcnN0X2Jhc2tldFwiLFxuICBcImZpcnN0X2ZpZWxkX2dvYWxcIixcbiAgXCJmaXJzdF90b3VjaGRvd25cIixcbiAgXCJhbnl0aW1lX3RvdWNoZG93blwiLFxuICBcImZpcnN0X2dvYWxcIixcbiAgXCJleGFjdF9zY29yZVwiLFxuICBcImNvcnJlY3Rfc2NvcmVcIixcbiAgXCJyYWNlX3RvX3BvaW50c1wiLFxuXSBhcyBjb25zdDtcbiJdLCJuYW1lcyI6WyJTSEFSUF9CT09LUyIsInBpbm5hY2xlIiwiaWQiLCJuYW1lIiwidGllciIsImRlc2NyaXB0aW9uIiwiY2lyY2EiLCJwcm9waGV0eCIsImhhcmRyb2NrIiwidGhlc2NvcmUiLCJib29rbWFrZXIiLCJTT0ZUX0JPT0tTIiwiU0hBUlBfUFJFU0VUUyIsImxhYmVsIiwiYm9va3MiLCJib29rSWQiLCJ3ZWlnaHQiLCJiZXRvbmxpbmUiLCJwaW5uYWNsZV9jaXJjYSIsImhhcmRyb2NrX3RoZXNjb3JlIiwiZHJhZnRraW5ncyIsImZhbmR1ZWwiLCJiZXRtZ20iLCJjYWVzYXJzIiwiYmV0MzY1IiwiYmFsbHliZXQiLCJiZXRyaXZlcnMiLCJmYW5hdGljcyIsInBvbHltYXJrZXQiLCJrYWxzaGkiLCJtYXJrZXRfYXZlcmFnZSIsImN1c3RvbSIsIkRFVklHX01FVEhPRFMiLCJwb3dlciIsImNvbXBsZXhpdHkiLCJtdWx0aXBsaWNhdGl2ZSIsImFkZGl0aXZlIiwicHJvYml0IiwiREVGQVVMVF9ERVZJR19NRVRIT0RTIiwiQUxMX0RFVklHX01FVEhPRFMiLCJQT1NJVElWRV9FVl9ERUZBVUxUUyIsInNoYXJwUHJlc2V0IiwiZGV2aWdNZXRob2RzIiwibWluRVYiLCJtYXhFViIsImxpbWl0Iiwic2hvd0tlbGx5Iiwia2VsbHlGcmFjdGlvbiIsImtlbGx5QmFua3JvbGwiLCJjYWNoZVNlY29uZHMiLCJFVl9USFJFU0hPTERTIiwicG9zaXRpdmUiLCJnb29kIiwiZ3JlYXQiLCJleGNlbGxlbnQiLCJzdXNwaWNpb3VzIiwibWF4aW11bSIsIlNVUFBPUlRFRF9TUE9SVFMiLCJUV09fV0FZX01BUktFVFMiLCJOT05fVFdPX1dBWV9NQVJLRVRTIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/ev/constants.ts\n");

/***/ }),

/***/ "(rsc)/./lib/ev/devig.ts":
/*!*************************!*\
  !*** ./lib/ev/devig.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   americanToDecimal: () => (/* binding */ americanToDecimal),\n/* harmony export */   americanToImpliedProb: () => (/* binding */ americanToImpliedProb),\n/* harmony export */   blendSharpOdds: () => (/* binding */ blendSharpOdds),\n/* harmony export */   calculateEV: () => (/* binding */ calculateEV),\n/* harmony export */   calculateEVDetails: () => (/* binding */ calculateEVDetails),\n/* harmony export */   calculateKelly: () => (/* binding */ calculateKelly),\n/* harmony export */   calculateMargin: () => (/* binding */ calculateMargin),\n/* harmony export */   calculateMarginFromOdds: () => (/* binding */ calculateMarginFromOdds),\n/* harmony export */   calculateMultiEV: () => (/* binding */ calculateMultiEV),\n/* harmony export */   createSharpReference: () => (/* binding */ createSharpReference),\n/* harmony export */   decimalToAmerican: () => (/* binding */ decimalToAmerican),\n/* harmony export */   devigAdditive: () => (/* binding */ devigAdditive),\n/* harmony export */   devigMultiple: () => (/* binding */ devigMultiple),\n/* harmony export */   devigMultiplicative: () => (/* binding */ devigMultiplicative),\n/* harmony export */   devigPower: () => (/* binding */ devigPower),\n/* harmony export */   devigProbit: () => (/* binding */ devigProbit),\n/* harmony export */   formatEV: () => (/* binding */ formatEV),\n/* harmony export */   formatKelly: () => (/* binding */ formatKelly),\n/* harmony export */   getKellyStake: () => (/* binding */ getKellyStake),\n/* harmony export */   impliedProbToAmerican: () => (/* binding */ impliedProbToAmerican),\n/* harmony export */   impliedProbToDecimal: () => (/* binding */ impliedProbToDecimal),\n/* harmony export */   isPositiveEV: () => (/* binding */ isPositiveEV)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(rsc)/./lib/ev/constants.ts\");\n/**\n * De-vig Library\n * \n * Core mathematical functions for removing sportsbook margin (vig)\n * from odds to calculate fair probabilities and Expected Value.\n * \n * Implements 4 de-vig methods:\n * - Power (Tier A): Handles favorite/longshot bias\n * - Multiplicative (Tier A): Simple proportional rescaling\n * - Additive (Tier B): Equal margin subtraction\n * - Probit (Tier B): Normal quantile transformation\n */ \n// =============================================================================\n// Odds Conversion Functions\n// =============================================================================\n/**\n * Convert American odds to implied probability\n * \n * @param odds American odds (e.g., -110, +150)\n * @returns Implied probability (0-1)\n * \n * @example\n * americanToImpliedProb(-110) // 0.5238 (52.38%)\n * americanToImpliedProb(+150) // 0.4 (40%)\n */ function americanToImpliedProb(odds) {\n    if (odds === 0) return 0;\n    if (odds < 0) {\n        // Favorite: -110  110 / (110 + 100) = 0.5238\n        return Math.abs(odds) / (Math.abs(odds) + 100);\n    } else {\n        // Underdog: +150  100 / (150 + 100) = 0.4\n        return 100 / (odds + 100);\n    }\n}\n/**\n * Convert American odds to decimal odds\n * \n * @param odds American odds\n * @returns Decimal odds (e.g., 1.91, 2.5)\n * \n * @example\n * americanToDecimal(-110) // 1.909\n * americanToDecimal(+150) // 2.5\n */ function americanToDecimal(odds) {\n    if (odds === 0) return 1;\n    if (odds < 0) {\n        // Favorite: -110  1 + (100 / 110) = 1.909\n        return 1 + 100 / Math.abs(odds);\n    } else {\n        // Underdog: +150  1 + (150 / 100) = 2.5\n        return 1 + odds / 100;\n    }\n}\n/**\n * Convert decimal odds to American odds\n * \n * @param decimal Decimal odds\n * @returns American odds\n */ function decimalToAmerican(decimal) {\n    if (decimal <= 1) return 0;\n    if (decimal >= 2) {\n        // Underdog: 2.5  (2.5 - 1) * 100 = +150\n        return Math.round((decimal - 1) * 100);\n    } else {\n        // Favorite: 1.909  -100 / (1.909 - 1) = -110\n        return Math.round(-100 / (decimal - 1));\n    }\n}\n/**\n * Convert implied probability to American odds\n * \n * @param prob Implied probability (0-1)\n * @returns American odds\n */ function impliedProbToAmerican(prob) {\n    if (prob <= 0 || prob >= 1) return 0;\n    if (prob >= 0.5) {\n        // Favorite\n        return Math.round(-100 * prob / (1 - prob));\n    } else {\n        // Underdog\n        return Math.round(100 * (1 - prob) / prob);\n    }\n}\n/**\n * Convert implied probability to decimal odds\n * \n * @param prob Implied probability (0-1)\n * @returns Decimal odds\n */ function impliedProbToDecimal(prob) {\n    if (prob <= 0) return Infinity;\n    return 1 / prob;\n}\n// =============================================================================\n// Margin/Overround Calculation\n// =============================================================================\n/**\n * Calculate the market margin (overround/vig)\n * \n * @param probOver Implied probability for over side\n * @param probUnder Implied probability for under side\n * @returns Margin as decimal (e.g., 0.0476 = 4.76%)\n * \n * @example\n * // -110 on both sides\n * calculateMargin(0.5238, 0.5238) // 0.0476 (4.76% vig)\n */ function calculateMargin(probOver, probUnder) {\n    return probOver + probUnder - 1;\n}\n/**\n * Calculate margin from American odds\n */ function calculateMarginFromOdds(overOdds, underOdds) {\n    const probOver = americanToImpliedProb(overOdds);\n    const probUnder = americanToImpliedProb(underOdds);\n    return calculateMargin(probOver, probUnder);\n}\n// =============================================================================\n// De-vig Method: Multiplicative (Ratio)\n// =============================================================================\n/**\n * Multiplicative de-vig method (also called \"Ratio\" or \"Proportional\")\n * \n * Rescales implied probabilities proportionally so they sum to 1.\n * Simple, stable, and widely used baseline.\n * \n * Formula: p_fair = p_implied / (p_over + p_under)\n * \n * @param overOdds American odds for over\n * @param underOdds American odds for under\n * @returns DevigResult with fair probabilities\n */ function devigMultiplicative(overOdds, underOdds) {\n    try {\n        const probOver = americanToImpliedProb(overOdds);\n        const probUnder = americanToImpliedProb(underOdds);\n        const total = probOver + probUnder;\n        if (total <= 0) {\n            return {\n                method: \"multiplicative\",\n                fairProbOver: 0,\n                fairProbUnder: 0,\n                margin: 0,\n                success: false,\n                error: \"Invalid odds: total probability <= 0\"\n            };\n        }\n        const margin = total - 1;\n        const fairProbOver = probOver / total;\n        const fairProbUnder = probUnder / total;\n        return {\n            method: \"multiplicative\",\n            fairProbOver,\n            fairProbUnder,\n            margin,\n            success: true\n        };\n    } catch (err) {\n        return {\n            method: \"multiplicative\",\n            fairProbOver: 0,\n            fairProbUnder: 0,\n            margin: 0,\n            success: false,\n            error: err instanceof Error ? err.message : \"Unknown error\"\n        };\n    }\n}\n// =============================================================================\n// De-vig Method: Additive\n// =============================================================================\n/**\n * Additive de-vig method\n * \n * Subtracts an equal amount from each implied probability.\n * Works best for balanced markets; can produce negative values on extreme odds.\n * \n * Formula: p_fair = p_implied - (margin / 2)\n * \n * @param overOdds American odds for over\n * @param underOdds American odds for under\n * @returns DevigResult with fair probabilities\n */ function devigAdditive(overOdds, underOdds) {\n    try {\n        const probOver = americanToImpliedProb(overOdds);\n        const probUnder = americanToImpliedProb(underOdds);\n        const margin = probOver + probUnder - 1;\n        // Subtract half the margin from each side\n        let fairProbOver = probOver - margin / 2;\n        let fairProbUnder = probUnder - margin / 2;\n        // Clamp to valid probability range\n        // Note: if clamping is needed, results may be less accurate\n        const needsClamping = fairProbOver < 0 || fairProbOver > 1 || fairProbUnder < 0 || fairProbUnder > 1;\n        fairProbOver = Math.max(0.001, Math.min(0.999, fairProbOver));\n        fairProbUnder = Math.max(0.001, Math.min(0.999, fairProbUnder));\n        // Renormalize after clamping\n        const total = fairProbOver + fairProbUnder;\n        fairProbOver = fairProbOver / total;\n        fairProbUnder = fairProbUnder / total;\n        return {\n            method: \"additive\",\n            fairProbOver,\n            fairProbUnder,\n            margin,\n            success: true,\n            error: needsClamping ? \"Clamping applied due to extreme odds\" : undefined\n        };\n    } catch (err) {\n        return {\n            method: \"additive\",\n            fairProbOver: 0,\n            fairProbUnder: 0,\n            margin: 0,\n            success: false,\n            error: err instanceof Error ? err.message : \"Unknown error\"\n        };\n    }\n}\n// =============================================================================\n// De-vig Method: Power\n// =============================================================================\n/**\n * Power de-vig method\n * \n * Finds an exponent k such that p_over^k + p_under^k = 1.\n * Handles favorite/longshot bias better than simple methods.\n * \n * Uses binary search to solve for k.\n * \n * @param overOdds American odds for over\n * @param underOdds American odds for under\n * @returns DevigResult with fair probabilities\n */ function devigPower(overOdds, underOdds) {\n    try {\n        const probOver = americanToImpliedProb(overOdds);\n        const probUnder = americanToImpliedProb(underOdds);\n        const margin = probOver + probUnder - 1;\n        if (probOver <= 0 || probUnder <= 0) {\n            return {\n                method: \"power\",\n                fairProbOver: 0,\n                fairProbUnder: 0,\n                margin,\n                success: false,\n                error: \"Invalid odds: probability <= 0\"\n            };\n        }\n        // Binary search for k where p_over^k + p_under^k = 1\n        let kLow = 0.1;\n        let kHigh = 10;\n        let k = 1;\n        const tolerance = 1e-10;\n        const maxIterations = 100;\n        for(let i = 0; i < maxIterations; i++){\n            k = (kLow + kHigh) / 2;\n            const sum = Math.pow(probOver, k) + Math.pow(probUnder, k);\n            if (Math.abs(sum - 1) < tolerance) {\n                break;\n            }\n            if (sum > 1) {\n                kLow = k;\n            } else {\n                kHigh = k;\n            }\n        }\n        const fairProbOver = Math.pow(probOver, k);\n        const fairProbUnder = Math.pow(probUnder, k);\n        // Verify sum is close to 1\n        const sum = fairProbOver + fairProbUnder;\n        if (Math.abs(sum - 1) > 0.001) {\n            return {\n                method: \"power\",\n                fairProbOver: fairProbOver / sum,\n                fairProbUnder: fairProbUnder / sum,\n                margin,\n                success: true,\n                error: \"Convergence warning: sum not exactly 1\"\n            };\n        }\n        return {\n            method: \"power\",\n            fairProbOver,\n            fairProbUnder,\n            margin,\n            success: true\n        };\n    } catch (err) {\n        return {\n            method: \"power\",\n            fairProbOver: 0,\n            fairProbUnder: 0,\n            margin: 0,\n            success: false,\n            error: err instanceof Error ? err.message : \"Unknown error\"\n        };\n    }\n}\n// =============================================================================\n// De-vig Method: Probit\n// =============================================================================\n/**\n * Standard normal CDF (cumulative distribution function)\n * Approximation using error function\n */ function normalCDF(x) {\n    const a1 = 0.254829592;\n    const a2 = -0.284496736;\n    const a3 = 1.421413741;\n    const a4 = -1.453152027;\n    const a5 = 1.061405429;\n    const p = 0.3275911;\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x) / Math.sqrt(2);\n    const t = 1.0 / (1.0 + p * x);\n    const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n    return 0.5 * (1.0 + sign * y);\n}\n/**\n * Inverse standard normal CDF (probit function)\n * Approximation using Abramowitz and Stegun formula\n */ function normalInverseCDF(p) {\n    if (p <= 0) return -Infinity;\n    if (p >= 1) return Infinity;\n    if (p === 0.5) return 0;\n    // Coefficients for rational approximation\n    const a = [\n        -3.969683028665376e+01,\n        2.209460984245205e+02,\n        -2.759285104469687e+02,\n        1.383577518672690e+02,\n        -3.066479806614716e+01,\n        2.506628277459239e+00\n    ];\n    const b = [\n        -5.447609879822406e+01,\n        1.615858368580409e+02,\n        -1.556989798598866e+02,\n        6.680131188771972e+01,\n        -1.328068155288572e+01\n    ];\n    const c = [\n        -7.784894002430293e-03,\n        -3.223964580411365e-01,\n        -2.400758277161838e+00,\n        -2.549732539343734e+00,\n        4.374664141464968e+00,\n        2.938163982698783e+00\n    ];\n    const d = [\n        7.784695709041462e-03,\n        3.224671290700398e-01,\n        2.445134137142996e+00,\n        3.754408661907416e+00\n    ];\n    const pLow = 0.02425;\n    const pHigh = 1 - pLow;\n    let q, r;\n    if (p < pLow) {\n        q = Math.sqrt(-2 * Math.log(p));\n        return (((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) / ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);\n    } else if (p <= pHigh) {\n        q = p - 0.5;\n        r = q * q;\n        return (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q / (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);\n    } else {\n        q = Math.sqrt(-2 * Math.log(1 - p));\n        return -(((((c[0] * q + c[1]) * q + c[2]) * q + c[3]) * q + c[4]) * q + c[5]) / ((((d[0] * q + d[1]) * q + d[2]) * q + d[3]) * q + 1);\n    }\n}\n/**\n * Probit de-vig method\n * \n * Transforms probabilities via normal quantiles, adjusts, and transforms back.\n * Provides a statistically smoother correction that handles favorite/longshot bias.\n * \n * The key insight is that we need to find a shift value 'k' such that:\n * (z_over + k) + (z_under + k) = 1\n * \n * Since (z) + (-z) = 1, we need: z_over + k = -(z_under + k)\n * Which gives us: k = -(z_over + z_under) / 2\n * \n * @param overOdds American odds for over\n * @param underOdds American odds for under\n * @returns DevigResult with fair probabilities\n */ function devigProbit(overOdds, underOdds) {\n    try {\n        const probOver = americanToImpliedProb(overOdds);\n        const probUnder = americanToImpliedProb(underOdds);\n        const margin = probOver + probUnder - 1;\n        // If margin is very small, just use multiplicative (more stable)\n        if (Math.abs(margin) < 0.001) {\n            const fairProbOver = probOver / (probOver + probUnder);\n            const fairProbUnder = probUnder / (probOver + probUnder);\n            return {\n                method: \"probit\",\n                fairProbOver,\n                fairProbUnder,\n                margin,\n                success: true\n            };\n        }\n        // Clamp to avoid infinity in probit\n        const clampedOver = Math.max(0.001, Math.min(0.999, probOver));\n        const clampedUnder = Math.max(0.001, Math.min(0.999, probUnder));\n        // Transform to normal scale (z-scores)\n        const zOver = normalInverseCDF(clampedOver);\n        const zUnder = normalInverseCDF(clampedUnder);\n        // The analytical solution: shift both z-scores by -k where k = (zOver + zUnder) / 2\n        // This makes the adjusted z-scores symmetric around 0, ensuring probs sum to 1\n        const k = (zOver + zUnder) / 2;\n        const fairProbOver = normalCDF(zOver - k);\n        const fairProbUnder = normalCDF(zUnder - k);\n        // Safety check: if results are unreasonable, fall back to multiplicative\n        if (fairProbOver <= 0 || fairProbOver >= 1 || fairProbUnder <= 0 || fairProbUnder >= 1 || !isFinite(fairProbOver) || !isFinite(fairProbUnder)) {\n            const fairProbOverFallback = probOver / (probOver + probUnder);\n            const fairProbUnderFallback = probUnder / (probOver + probUnder);\n            return {\n                method: \"probit\",\n                fairProbOver: fairProbOverFallback,\n                fairProbUnder: fairProbUnderFallback,\n                margin,\n                success: true\n            };\n        }\n        // Normalize to ensure sum is exactly 1 (handle any floating point errors)\n        const total = fairProbOver + fairProbUnder;\n        return {\n            method: \"probit\",\n            fairProbOver: fairProbOver / total,\n            fairProbUnder: fairProbUnder / total,\n            margin,\n            success: true\n        };\n    } catch (err) {\n        return {\n            method: \"probit\",\n            fairProbOver: 0,\n            fairProbUnder: 0,\n            margin: 0,\n            success: false,\n            error: err instanceof Error ? err.message : \"Unknown error\"\n        };\n    }\n}\n// =============================================================================\n// Multi-Method De-vig\n// =============================================================================\n/**\n * Run multiple de-vig methods and return all results\n * \n * @param overOdds American odds for over\n * @param underOdds American odds for under\n * @param methods Which methods to run (default: power, multiplicative)\n * @returns Results from each method\n */ function devigMultiple(overOdds, underOdds, methods = _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DEVIG_METHODS) {\n    const results = {};\n    for (const method of methods){\n        switch(method){\n            case \"power\":\n                results.power = devigPower(overOdds, underOdds);\n                break;\n            case \"multiplicative\":\n                results.multiplicative = devigMultiplicative(overOdds, underOdds);\n                break;\n            case \"additive\":\n                results.additive = devigAdditive(overOdds, underOdds);\n                break;\n            case \"probit\":\n                results.probit = devigProbit(overOdds, underOdds);\n                break;\n        }\n    }\n    return results;\n}\n// =============================================================================\n// EV Calculation\n// =============================================================================\n/**\n * Calculate Expected Value for a single bet\n * \n * EV = (p_fair * decimal_payout) - 1\n * \n * @param fairProb Fair probability (0-1)\n * @param bookOdds Book's American odds\n * @returns EV as decimal (e.g., 0.05 = 5% EV)\n */ function calculateEV(fairProb, bookOdds) {\n    const decimal = americanToDecimal(bookOdds);\n    return fairProb * decimal - 1;\n}\n/**\n * Calculate Kelly fraction for optimal bet sizing\n * \n * Kelly = (p * (d - 1) - (1 - p)) / (d - 1)\n *       = (p * d - 1) / (d - 1)\n * \n * Where:\n * - p = fair probability\n * - d = decimal odds\n * \n * @param fairProb Fair probability (0-1)\n * @param bookOdds Book's American odds\n * @returns Optimal fraction of bankroll to bet (0-1)\n */ function calculateKelly(fairProb, bookOdds) {\n    const decimal = americanToDecimal(bookOdds);\n    if (decimal <= 1) return 0;\n    const kelly = (fairProb * decimal - 1) / (decimal - 1);\n    // Return 0 if negative (no edge)\n    return Math.max(0, kelly);\n}\n/**\n * Calculate full EV details for a book offer using a specific de-vig method\n * \n * @param fairProb Fair probability from de-vig\n * @param bookOffer Book's odds offer\n * @param method Which de-vig method was used\n * @returns Full EV calculation details\n */ function calculateEVDetails(fairProb, bookOffer, method) {\n    const bookDecimal = americanToDecimal(bookOffer.price);\n    const bookProb = americanToImpliedProb(bookOffer.price);\n    const ev = calculateEV(fairProb, bookOffer.price);\n    const kelly = calculateKelly(fairProb, bookOffer.price);\n    return {\n        method,\n        fairProb,\n        bookProb,\n        bookDecimal,\n        ev,\n        evPercent: ev * 100,\n        edge: bookProb - fairProb,\n        kellyFraction: kelly\n    };\n}\n/**\n * Calculate EV using multiple de-vig methods\n * \n * @param devigResults Results from multi-method de-vig\n * @param bookOffer Book's odds offer\n * @param side Which side to calculate for (\"over\" or \"under\")\n * @returns Combined EV calculations with worst/best/display values\n */ function calculateMultiEV(devigResults, bookOffer, side) {\n    const result = {\n        evWorst: Infinity,\n        evBest: -Infinity,\n        evDisplay: 0\n    };\n    const evValues = [];\n    const kellyValues = [];\n    // Calculate EV for each available method\n    if (devigResults.power?.success) {\n        const fairProb = side === \"over\" ? devigResults.power.fairProbOver : devigResults.power.fairProbUnder;\n        result.power = calculateEVDetails(fairProb, bookOffer, \"power\");\n        evValues.push(result.power.evPercent);\n        if (result.power.kellyFraction !== undefined) {\n            kellyValues.push(result.power.kellyFraction);\n        }\n    }\n    if (devigResults.multiplicative?.success) {\n        const fairProb = side === \"over\" ? devigResults.multiplicative.fairProbOver : devigResults.multiplicative.fairProbUnder;\n        result.multiplicative = calculateEVDetails(fairProb, bookOffer, \"multiplicative\");\n        evValues.push(result.multiplicative.evPercent);\n        if (result.multiplicative.kellyFraction !== undefined) {\n            kellyValues.push(result.multiplicative.kellyFraction);\n        }\n    }\n    if (devigResults.additive?.success) {\n        const fairProb = side === \"over\" ? devigResults.additive.fairProbOver : devigResults.additive.fairProbUnder;\n        result.additive = calculateEVDetails(fairProb, bookOffer, \"additive\");\n        evValues.push(result.additive.evPercent);\n        if (result.additive.kellyFraction !== undefined) {\n            kellyValues.push(result.additive.kellyFraction);\n        }\n    }\n    if (devigResults.probit?.success) {\n        const fairProb = side === \"over\" ? devigResults.probit.fairProbOver : devigResults.probit.fairProbUnder;\n        result.probit = calculateEVDetails(fairProb, bookOffer, \"probit\");\n        evValues.push(result.probit.evPercent);\n        if (result.probit.kellyFraction !== undefined) {\n            kellyValues.push(result.probit.kellyFraction);\n        }\n    }\n    // Calculate aggregated values\n    if (evValues.length > 0) {\n        result.evWorst = Math.min(...evValues);\n        result.evBest = Math.max(...evValues);\n        result.evDisplay = result.evWorst; // Default to conservative\n    } else {\n        result.evWorst = 0;\n        result.evBest = 0;\n        result.evDisplay = 0;\n    }\n    if (kellyValues.length > 0) {\n        result.kellyWorst = Math.min(...kellyValues);\n    }\n    return result;\n}\n// =============================================================================\n// Sharp Reference Helpers\n// =============================================================================\n/**\n * Blend odds from multiple sharp books\n * \n * @param bookOdds Array of { bookId, odds, weight }\n * @returns Blended American odds\n */ function blendSharpOdds(bookOdds) {\n    if (bookOdds.length === 0) return 0;\n    if (bookOdds.length === 1) return bookOdds[0].odds;\n    // Convert to probabilities, blend, convert back\n    let totalWeight = 0;\n    let blendedProb = 0;\n    for (const { odds, weight } of bookOdds){\n        const prob = americanToImpliedProb(odds);\n        blendedProb += prob * weight;\n        totalWeight += weight;\n    }\n    if (totalWeight === 0) return 0;\n    blendedProb = blendedProb / totalWeight;\n    return impliedProbToAmerican(blendedProb);\n}\n/**\n * Create a sharp reference from book odds\n */ function createSharpReference(overOdds, underOdds, preset, source, blendedFrom) {\n    return {\n        preset: preset,\n        overOdds,\n        underOdds,\n        overDecimal: americanToDecimal(overOdds),\n        underDecimal: americanToDecimal(underOdds),\n        source,\n        blendedFrom\n    };\n}\n// =============================================================================\n// Utility Functions\n// =============================================================================\n/**\n * Check if a market is +EV based on de-vig results\n * \n * @param evCalc EV calculation results\n * @param minEV Minimum EV% threshold\n * @returns true if the bet is +EV (above threshold)\n */ function isPositiveEV(evCalc, minEV = 0) {\n    return evCalc.evWorst > minEV;\n}\n/**\n * Format EV percentage for display\n * \n * @param ev EV as percentage (e.g., 5.23)\n * @returns Formatted string (e.g., \"+5.2%\")\n */ function formatEV(ev) {\n    const sign = ev >= 0 ? \"+\" : \"\";\n    return `${sign}${ev.toFixed(1)}%`;\n}\n/**\n * Format Kelly fraction as percentage\n * \n * @param kelly Kelly fraction (e.g., 0.0234)\n * @param fraction Kelly multiplier (e.g., 0.25 for quarter Kelly)\n * @returns Formatted string (e.g., \"0.6%\")\n */ function formatKelly(kelly, fraction = 1) {\n    const adjusted = kelly * fraction * 100;\n    return `${adjusted.toFixed(1)}%`;\n}\n/**\n * Get Kelly stake amount\n * \n * @param kelly Kelly fraction\n * @param bankroll Total bankroll\n * @param fraction Kelly multiplier (e.g., 0.25 for quarter Kelly)\n * @returns Stake amount\n */ function getKellyStake(kelly, bankroll, fraction = 1) {\n    return bankroll * kelly * fraction;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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akIrRixNQUFjLEVBQ2RDLE1BQWMsRUFDZEMsV0FBc0I7SUFFdEIsT0FBTztRQUNMRixRQUFRQTtRQUNSaEc7UUFDQUM7UUFDQWtHLGFBQWEvRyxrQkFBa0JZO1FBQy9Cb0csY0FBY2hILGtCQUFrQmE7UUFDaENnRztRQUNBQztJQUNGO0FBQ0Y7QUFFQSxnRkFBZ0Y7QUFDaEYsb0JBQW9CO0FBQ3BCLGdGQUFnRjtBQUVoRjs7Ozs7O0NBTUMsR0FDTSxTQUFTRyxhQUFhQyxNQUEwQixFQUFFQyxRQUFnQixDQUFDO0lBQ3hFLE9BQU9ELE9BQU9uQixPQUFPLEdBQUdvQjtBQUMxQjtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU0MsU0FBUzdCLEVBQVU7SUFDakMsTUFBTXhDLE9BQU93QyxNQUFNLElBQUksTUFBTTtJQUM3QixPQUFPLEdBQUd4QyxPQUFPd0MsR0FBRzhCLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNuQztBQUVBOzs7Ozs7Q0FNQyxHQUNNLFNBQVNDLFlBQVlyQyxLQUFhLEVBQUVzQyxXQUFtQixDQUFDO0lBQzdELE1BQU1DLFdBQVd2QyxRQUFRc0MsV0FBVztJQUNwQyxPQUFPLEdBQUdDLFNBQVNILE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNsQztBQUVBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTSSxjQUFjeEMsS0FBYSxFQUFFeUMsUUFBZ0IsRUFBRUgsV0FBbUIsQ0FBQztJQUNqRixPQUFPRyxXQUFXekMsUUFBUXNDO0FBQzVCIiwic291cmNlcyI6WyIvVXNlcnMvZHJld21hc2Nob2ZmL2Rldi91bmp1aWNlZC9hcHBzL3dlYi9saWIvZXYvZGV2aWcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZS12aWcgTGlicmFyeVxuICogXG4gKiBDb3JlIG1hdGhlbWF0aWNhbCBmdW5jdGlvbnMgZm9yIHJlbW92aW5nIHNwb3J0c2Jvb2sgbWFyZ2luICh2aWcpXG4gKiBmcm9tIG9kZHMgdG8gY2FsY3VsYXRlIGZhaXIgcHJvYmFiaWxpdGllcyBhbmQgRXhwZWN0ZWQgVmFsdWUuXG4gKiBcbiAqIEltcGxlbWVudHMgNCBkZS12aWcgbWV0aG9kczpcbiAqIC0gUG93ZXIgKFRpZXIgQSk6IEhhbmRsZXMgZmF2b3JpdGUvbG9uZ3Nob3QgYmlhc1xuICogLSBNdWx0aXBsaWNhdGl2ZSAoVGllciBBKTogU2ltcGxlIHByb3BvcnRpb25hbCByZXNjYWxpbmdcbiAqIC0gQWRkaXRpdmUgKFRpZXIgQik6IEVxdWFsIG1hcmdpbiBzdWJ0cmFjdGlvblxuICogLSBQcm9iaXQgKFRpZXIgQik6IE5vcm1hbCBxdWFudGlsZSB0cmFuc2Zvcm1hdGlvblxuICovXG5cbmltcG9ydCB0eXBlIHtcbiAgRGV2aWdNZXRob2QsXG4gIERldmlnUmVzdWx0LFxuICBNdWx0aURldmlnUmVzdWx0LFxuICBFVkNhbGN1bGF0aW9uLFxuICBNdWx0aUVWQ2FsY3VsYXRpb24sXG4gIFNoYXJwUmVmZXJlbmNlLFxuICBCb29rT2ZmZXIsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBERUZBVUxUX0RFVklHX01FVEhPRFMgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE9kZHMgQ29udmVyc2lvbiBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ29udmVydCBBbWVyaWNhbiBvZGRzIHRvIGltcGxpZWQgcHJvYmFiaWxpdHlcbiAqIFxuICogQHBhcmFtIG9kZHMgQW1lcmljYW4gb2RkcyAoZS5nLiwgLTExMCwgKzE1MClcbiAqIEByZXR1cm5zIEltcGxpZWQgcHJvYmFiaWxpdHkgKDAtMSlcbiAqIFxuICogQGV4YW1wbGVcbiAqIGFtZXJpY2FuVG9JbXBsaWVkUHJvYigtMTEwKSAvLyAwLjUyMzggKDUyLjM4JSlcbiAqIGFtZXJpY2FuVG9JbXBsaWVkUHJvYigrMTUwKSAvLyAwLjQgKDQwJSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFtZXJpY2FuVG9JbXBsaWVkUHJvYihvZGRzOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAob2RkcyA9PT0gMCkgcmV0dXJuIDA7XG4gIFxuICBpZiAob2RkcyA8IDApIHtcbiAgICAvLyBGYXZvcml0ZTogLTExMCDihpIgMTEwIC8gKDExMCArIDEwMCkgPSAwLjUyMzhcbiAgICByZXR1cm4gTWF0aC5hYnMob2RkcykgLyAoTWF0aC5hYnMob2RkcykgKyAxMDApO1xuICB9IGVsc2Uge1xuICAgIC8vIFVuZGVyZG9nOiArMTUwIOKGkiAxMDAgLyAoMTUwICsgMTAwKSA9IDAuNFxuICAgIHJldHVybiAxMDAgLyAob2RkcyArIDEwMCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEFtZXJpY2FuIG9kZHMgdG8gZGVjaW1hbCBvZGRzXG4gKiBcbiAqIEBwYXJhbSBvZGRzIEFtZXJpY2FuIG9kZHNcbiAqIEByZXR1cm5zIERlY2ltYWwgb2RkcyAoZS5nLiwgMS45MSwgMi41KVxuICogXG4gKiBAZXhhbXBsZVxuICogYW1lcmljYW5Ub0RlY2ltYWwoLTExMCkgLy8gMS45MDlcbiAqIGFtZXJpY2FuVG9EZWNpbWFsKCsxNTApIC8vIDIuNVxuICovXG5leHBvcnQgZnVuY3Rpb24gYW1lcmljYW5Ub0RlY2ltYWwob2RkczogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKG9kZHMgPT09IDApIHJldHVybiAxO1xuICBcbiAgaWYgKG9kZHMgPCAwKSB7XG4gICAgLy8gRmF2b3JpdGU6IC0xMTAg4oaSIDEgKyAoMTAwIC8gMTEwKSA9IDEuOTA5XG4gICAgcmV0dXJuIDEgKyAoMTAwIC8gTWF0aC5hYnMob2RkcykpO1xuICB9IGVsc2Uge1xuICAgIC8vIFVuZGVyZG9nOiArMTUwIOKGkiAxICsgKDE1MCAvIDEwMCkgPSAyLjVcbiAgICByZXR1cm4gMSArIChvZGRzIC8gMTAwKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgZGVjaW1hbCBvZGRzIHRvIEFtZXJpY2FuIG9kZHNcbiAqIFxuICogQHBhcmFtIGRlY2ltYWwgRGVjaW1hbCBvZGRzXG4gKiBAcmV0dXJucyBBbWVyaWNhbiBvZGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNpbWFsVG9BbWVyaWNhbihkZWNpbWFsOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoZGVjaW1hbCA8PSAxKSByZXR1cm4gMDtcbiAgXG4gIGlmIChkZWNpbWFsID49IDIpIHtcbiAgICAvLyBVbmRlcmRvZzogMi41IOKGkiAoMi41IC0gMSkgKiAxMDAgPSArMTUwXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGRlY2ltYWwgLSAxKSAqIDEwMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmF2b3JpdGU6IDEuOTA5IOKGkiAtMTAwIC8gKDEuOTA5IC0gMSkgPSAtMTEwXG4gICAgcmV0dXJuIE1hdGgucm91bmQoLTEwMCAvIChkZWNpbWFsIC0gMSkpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBpbXBsaWVkIHByb2JhYmlsaXR5IHRvIEFtZXJpY2FuIG9kZHNcbiAqIFxuICogQHBhcmFtIHByb2IgSW1wbGllZCBwcm9iYWJpbGl0eSAoMC0xKVxuICogQHJldHVybnMgQW1lcmljYW4gb2Rkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW1wbGllZFByb2JUb0FtZXJpY2FuKHByb2I6IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChwcm9iIDw9IDAgfHwgcHJvYiA+PSAxKSByZXR1cm4gMDtcbiAgXG4gIGlmIChwcm9iID49IDAuNSkge1xuICAgIC8vIEZhdm9yaXRlXG4gICAgcmV0dXJuIE1hdGgucm91bmQoLTEwMCAqIHByb2IgLyAoMSAtIHByb2IpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBVbmRlcmRvZ1xuICAgIHJldHVybiBNYXRoLnJvdW5kKDEwMCAqICgxIC0gcHJvYikgLyBwcm9iKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgaW1wbGllZCBwcm9iYWJpbGl0eSB0byBkZWNpbWFsIG9kZHNcbiAqIFxuICogQHBhcmFtIHByb2IgSW1wbGllZCBwcm9iYWJpbGl0eSAoMC0xKVxuICogQHJldHVybnMgRGVjaW1hbCBvZGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbXBsaWVkUHJvYlRvRGVjaW1hbChwcm9iOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAocHJvYiA8PSAwKSByZXR1cm4gSW5maW5pdHk7XG4gIHJldHVybiAxIC8gcHJvYjtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE1hcmdpbi9PdmVycm91bmQgQ2FsY3VsYXRpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBtYXJrZXQgbWFyZ2luIChvdmVycm91bmQvdmlnKVxuICogXG4gKiBAcGFyYW0gcHJvYk92ZXIgSW1wbGllZCBwcm9iYWJpbGl0eSBmb3Igb3ZlciBzaWRlXG4gKiBAcGFyYW0gcHJvYlVuZGVyIEltcGxpZWQgcHJvYmFiaWxpdHkgZm9yIHVuZGVyIHNpZGVcbiAqIEByZXR1cm5zIE1hcmdpbiBhcyBkZWNpbWFsIChlLmcuLCAwLjA0NzYgPSA0Ljc2JSlcbiAqIFxuICogQGV4YW1wbGVcbiAqIC8vIC0xMTAgb24gYm90aCBzaWRlc1xuICogY2FsY3VsYXRlTWFyZ2luKDAuNTIzOCwgMC41MjM4KSAvLyAwLjA0NzYgKDQuNzYlIHZpZylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU1hcmdpbihwcm9iT3ZlcjogbnVtYmVyLCBwcm9iVW5kZXI6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBwcm9iT3ZlciArIHByb2JVbmRlciAtIDE7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIG1hcmdpbiBmcm9tIEFtZXJpY2FuIG9kZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU1hcmdpbkZyb21PZGRzKG92ZXJPZGRzOiBudW1iZXIsIHVuZGVyT2RkczogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgcHJvYk92ZXIgPSBhbWVyaWNhblRvSW1wbGllZFByb2Iob3Zlck9kZHMpO1xuICBjb25zdCBwcm9iVW5kZXIgPSBhbWVyaWNhblRvSW1wbGllZFByb2IodW5kZXJPZGRzKTtcbiAgcmV0dXJuIGNhbGN1bGF0ZU1hcmdpbihwcm9iT3ZlciwgcHJvYlVuZGVyKTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIERlLXZpZyBNZXRob2Q6IE11bHRpcGxpY2F0aXZlIChSYXRpbylcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogTXVsdGlwbGljYXRpdmUgZGUtdmlnIG1ldGhvZCAoYWxzbyBjYWxsZWQgXCJSYXRpb1wiIG9yIFwiUHJvcG9ydGlvbmFsXCIpXG4gKiBcbiAqIFJlc2NhbGVzIGltcGxpZWQgcHJvYmFiaWxpdGllcyBwcm9wb3J0aW9uYWxseSBzbyB0aGV5IHN1bSB0byAxLlxuICogU2ltcGxlLCBzdGFibGUsIGFuZCB3aWRlbHkgdXNlZCBiYXNlbGluZS5cbiAqIFxuICogRm9ybXVsYTogcF9mYWlyID0gcF9pbXBsaWVkIC8gKHBfb3ZlciArIHBfdW5kZXIpXG4gKiBcbiAqIEBwYXJhbSBvdmVyT2RkcyBBbWVyaWNhbiBvZGRzIGZvciBvdmVyXG4gKiBAcGFyYW0gdW5kZXJPZGRzIEFtZXJpY2FuIG9kZHMgZm9yIHVuZGVyXG4gKiBAcmV0dXJucyBEZXZpZ1Jlc3VsdCB3aXRoIGZhaXIgcHJvYmFiaWxpdGllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGV2aWdNdWx0aXBsaWNhdGl2ZShvdmVyT2RkczogbnVtYmVyLCB1bmRlck9kZHM6IG51bWJlcik6IERldmlnUmVzdWx0IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9iT3ZlciA9IGFtZXJpY2FuVG9JbXBsaWVkUHJvYihvdmVyT2Rkcyk7XG4gICAgY29uc3QgcHJvYlVuZGVyID0gYW1lcmljYW5Ub0ltcGxpZWRQcm9iKHVuZGVyT2Rkcyk7XG4gICAgY29uc3QgdG90YWwgPSBwcm9iT3ZlciArIHByb2JVbmRlcjtcbiAgICBcbiAgICBpZiAodG90YWwgPD0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kOiBcIm11bHRpcGxpY2F0aXZlXCIsXG4gICAgICAgIGZhaXJQcm9iT3ZlcjogMCxcbiAgICAgICAgZmFpclByb2JVbmRlcjogMCxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IFwiSW52YWxpZCBvZGRzOiB0b3RhbCBwcm9iYWJpbGl0eSA8PSAwXCIsXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBtYXJnaW4gPSB0b3RhbCAtIDE7XG4gICAgY29uc3QgZmFpclByb2JPdmVyID0gcHJvYk92ZXIgLyB0b3RhbDtcbiAgICBjb25zdCBmYWlyUHJvYlVuZGVyID0gcHJvYlVuZGVyIC8gdG90YWw7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogXCJtdWx0aXBsaWNhdGl2ZVwiLFxuICAgICAgZmFpclByb2JPdmVyLFxuICAgICAgZmFpclByb2JVbmRlcixcbiAgICAgIG1hcmdpbixcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogXCJtdWx0aXBsaWNhdGl2ZVwiLFxuICAgICAgZmFpclByb2JPdmVyOiAwLFxuICAgICAgZmFpclByb2JVbmRlcjogMCxcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIixcbiAgICB9O1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEZS12aWcgTWV0aG9kOiBBZGRpdGl2ZVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBBZGRpdGl2ZSBkZS12aWcgbWV0aG9kXG4gKiBcbiAqIFN1YnRyYWN0cyBhbiBlcXVhbCBhbW91bnQgZnJvbSBlYWNoIGltcGxpZWQgcHJvYmFiaWxpdHkuXG4gKiBXb3JrcyBiZXN0IGZvciBiYWxhbmNlZCBtYXJrZXRzOyBjYW4gcHJvZHVjZSBuZWdhdGl2ZSB2YWx1ZXMgb24gZXh0cmVtZSBvZGRzLlxuICogXG4gKiBGb3JtdWxhOiBwX2ZhaXIgPSBwX2ltcGxpZWQgLSAobWFyZ2luIC8gMilcbiAqIFxuICogQHBhcmFtIG92ZXJPZGRzIEFtZXJpY2FuIG9kZHMgZm9yIG92ZXJcbiAqIEBwYXJhbSB1bmRlck9kZHMgQW1lcmljYW4gb2RkcyBmb3IgdW5kZXJcbiAqIEByZXR1cm5zIERldmlnUmVzdWx0IHdpdGggZmFpciBwcm9iYWJpbGl0aWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXZpZ0FkZGl0aXZlKG92ZXJPZGRzOiBudW1iZXIsIHVuZGVyT2RkczogbnVtYmVyKTogRGV2aWdSZXN1bHQge1xuICB0cnkge1xuICAgIGNvbnN0IHByb2JPdmVyID0gYW1lcmljYW5Ub0ltcGxpZWRQcm9iKG92ZXJPZGRzKTtcbiAgICBjb25zdCBwcm9iVW5kZXIgPSBhbWVyaWNhblRvSW1wbGllZFByb2IodW5kZXJPZGRzKTtcbiAgICBjb25zdCBtYXJnaW4gPSBwcm9iT3ZlciArIHByb2JVbmRlciAtIDE7XG4gICAgXG4gICAgLy8gU3VidHJhY3QgaGFsZiB0aGUgbWFyZ2luIGZyb20gZWFjaCBzaWRlXG4gICAgbGV0IGZhaXJQcm9iT3ZlciA9IHByb2JPdmVyIC0gbWFyZ2luIC8gMjtcbiAgICBsZXQgZmFpclByb2JVbmRlciA9IHByb2JVbmRlciAtIG1hcmdpbiAvIDI7XG4gICAgXG4gICAgLy8gQ2xhbXAgdG8gdmFsaWQgcHJvYmFiaWxpdHkgcmFuZ2VcbiAgICAvLyBOb3RlOiBpZiBjbGFtcGluZyBpcyBuZWVkZWQsIHJlc3VsdHMgbWF5IGJlIGxlc3MgYWNjdXJhdGVcbiAgICBjb25zdCBuZWVkc0NsYW1waW5nID0gZmFpclByb2JPdmVyIDwgMCB8fCBmYWlyUHJvYk92ZXIgPiAxIHx8IGZhaXJQcm9iVW5kZXIgPCAwIHx8IGZhaXJQcm9iVW5kZXIgPiAxO1xuICAgIFxuICAgIGZhaXJQcm9iT3ZlciA9IE1hdGgubWF4KDAuMDAxLCBNYXRoLm1pbigwLjk5OSwgZmFpclByb2JPdmVyKSk7XG4gICAgZmFpclByb2JVbmRlciA9IE1hdGgubWF4KDAuMDAxLCBNYXRoLm1pbigwLjk5OSwgZmFpclByb2JVbmRlcikpO1xuICAgIFxuICAgIC8vIFJlbm9ybWFsaXplIGFmdGVyIGNsYW1waW5nXG4gICAgY29uc3QgdG90YWwgPSBmYWlyUHJvYk92ZXIgKyBmYWlyUHJvYlVuZGVyO1xuICAgIGZhaXJQcm9iT3ZlciA9IGZhaXJQcm9iT3ZlciAvIHRvdGFsO1xuICAgIGZhaXJQcm9iVW5kZXIgPSBmYWlyUHJvYlVuZGVyIC8gdG90YWw7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogXCJhZGRpdGl2ZVwiLFxuICAgICAgZmFpclByb2JPdmVyLFxuICAgICAgZmFpclByb2JVbmRlcixcbiAgICAgIG1hcmdpbixcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBlcnJvcjogbmVlZHNDbGFtcGluZyA/IFwiQ2xhbXBpbmcgYXBwbGllZCBkdWUgdG8gZXh0cmVtZSBvZGRzXCIgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogXCJhZGRpdGl2ZVwiLFxuICAgICAgZmFpclByb2JPdmVyOiAwLFxuICAgICAgZmFpclByb2JVbmRlcjogMCxcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIixcbiAgICB9O1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEZS12aWcgTWV0aG9kOiBQb3dlclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBQb3dlciBkZS12aWcgbWV0aG9kXG4gKiBcbiAqIEZpbmRzIGFuIGV4cG9uZW50IGsgc3VjaCB0aGF0IHBfb3Zlcl5rICsgcF91bmRlcl5rID0gMS5cbiAqIEhhbmRsZXMgZmF2b3JpdGUvbG9uZ3Nob3QgYmlhcyBiZXR0ZXIgdGhhbiBzaW1wbGUgbWV0aG9kcy5cbiAqIFxuICogVXNlcyBiaW5hcnkgc2VhcmNoIHRvIHNvbHZlIGZvciBrLlxuICogXG4gKiBAcGFyYW0gb3Zlck9kZHMgQW1lcmljYW4gb2RkcyBmb3Igb3ZlclxuICogQHBhcmFtIHVuZGVyT2RkcyBBbWVyaWNhbiBvZGRzIGZvciB1bmRlclxuICogQHJldHVybnMgRGV2aWdSZXN1bHQgd2l0aCBmYWlyIHByb2JhYmlsaXRpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldmlnUG93ZXIob3Zlck9kZHM6IG51bWJlciwgdW5kZXJPZGRzOiBudW1iZXIpOiBEZXZpZ1Jlc3VsdCB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvYk92ZXIgPSBhbWVyaWNhblRvSW1wbGllZFByb2Iob3Zlck9kZHMpO1xuICAgIGNvbnN0IHByb2JVbmRlciA9IGFtZXJpY2FuVG9JbXBsaWVkUHJvYih1bmRlck9kZHMpO1xuICAgIGNvbnN0IG1hcmdpbiA9IHByb2JPdmVyICsgcHJvYlVuZGVyIC0gMTtcbiAgICBcbiAgICBpZiAocHJvYk92ZXIgPD0gMCB8fCBwcm9iVW5kZXIgPD0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kOiBcInBvd2VyXCIsXG4gICAgICAgIGZhaXJQcm9iT3ZlcjogMCxcbiAgICAgICAgZmFpclByb2JVbmRlcjogMCxcbiAgICAgICAgbWFyZ2luLFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IFwiSW52YWxpZCBvZGRzOiBwcm9iYWJpbGl0eSA8PSAwXCIsXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBCaW5hcnkgc2VhcmNoIGZvciBrIHdoZXJlIHBfb3Zlcl5rICsgcF91bmRlcl5rID0gMVxuICAgIGxldCBrTG93ID0gMC4xO1xuICAgIGxldCBrSGlnaCA9IDEwO1xuICAgIGxldCBrID0gMTtcbiAgICBjb25zdCB0b2xlcmFuY2UgPSAxZS0xMDtcbiAgICBjb25zdCBtYXhJdGVyYXRpb25zID0gMTAwO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICBrID0gKGtMb3cgKyBrSGlnaCkgLyAyO1xuICAgICAgY29uc3Qgc3VtID0gTWF0aC5wb3cocHJvYk92ZXIsIGspICsgTWF0aC5wb3cocHJvYlVuZGVyLCBrKTtcbiAgICAgIFxuICAgICAgaWYgKE1hdGguYWJzKHN1bSAtIDEpIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoc3VtID4gMSkge1xuICAgICAgICBrTG93ID0gaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtIaWdoID0gaztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc3QgZmFpclByb2JPdmVyID0gTWF0aC5wb3cocHJvYk92ZXIsIGspO1xuICAgIGNvbnN0IGZhaXJQcm9iVW5kZXIgPSBNYXRoLnBvdyhwcm9iVW5kZXIsIGspO1xuICAgIFxuICAgIC8vIFZlcmlmeSBzdW0gaXMgY2xvc2UgdG8gMVxuICAgIGNvbnN0IHN1bSA9IGZhaXJQcm9iT3ZlciArIGZhaXJQcm9iVW5kZXI7XG4gICAgaWYgKE1hdGguYWJzKHN1bSAtIDEpID4gMC4wMDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZDogXCJwb3dlclwiLFxuICAgICAgICBmYWlyUHJvYk92ZXI6IGZhaXJQcm9iT3ZlciAvIHN1bSxcbiAgICAgICAgZmFpclByb2JVbmRlcjogZmFpclByb2JVbmRlciAvIHN1bSxcbiAgICAgICAgbWFyZ2luLFxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBlcnJvcjogXCJDb252ZXJnZW5jZSB3YXJuaW5nOiBzdW0gbm90IGV4YWN0bHkgMVwiLFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogXCJwb3dlclwiLFxuICAgICAgZmFpclByb2JPdmVyLFxuICAgICAgZmFpclByb2JVbmRlcixcbiAgICAgIG1hcmdpbixcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogXCJwb3dlclwiLFxuICAgICAgZmFpclByb2JPdmVyOiAwLFxuICAgICAgZmFpclByb2JVbmRlcjogMCxcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIixcbiAgICB9O1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEZS12aWcgTWV0aG9kOiBQcm9iaXRcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogU3RhbmRhcmQgbm9ybWFsIENERiAoY3VtdWxhdGl2ZSBkaXN0cmlidXRpb24gZnVuY3Rpb24pXG4gKiBBcHByb3hpbWF0aW9uIHVzaW5nIGVycm9yIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbENERih4OiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBhMSA9ICAwLjI1NDgyOTU5MjtcbiAgY29uc3QgYTIgPSAtMC4yODQ0OTY3MzY7XG4gIGNvbnN0IGEzID0gIDEuNDIxNDEzNzQxO1xuICBjb25zdCBhNCA9IC0xLjQ1MzE1MjAyNztcbiAgY29uc3QgYTUgPSAgMS4wNjE0MDU0Mjk7XG4gIGNvbnN0IHAgID0gIDAuMzI3NTkxMTtcbiAgXG4gIGNvbnN0IHNpZ24gPSB4IDwgMCA/IC0xIDogMTtcbiAgeCA9IE1hdGguYWJzKHgpIC8gTWF0aC5zcXJ0KDIpO1xuICBcbiAgY29uc3QgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XG4gIGNvbnN0IHkgPSAxLjAgLSAoKCgoKGE1ICogdCArIGE0KSAqIHQpICsgYTMpICogdCArIGEyKSAqIHQgKyBhMSkgKiB0ICogTWF0aC5leHAoLXggKiB4KTtcbiAgXG4gIHJldHVybiAwLjUgKiAoMS4wICsgc2lnbiAqIHkpO1xufVxuXG4vKipcbiAqIEludmVyc2Ugc3RhbmRhcmQgbm9ybWFsIENERiAocHJvYml0IGZ1bmN0aW9uKVxuICogQXBwcm94aW1hdGlvbiB1c2luZyBBYnJhbW93aXR6IGFuZCBTdGVndW4gZm9ybXVsYVxuICovXG5mdW5jdGlvbiBub3JtYWxJbnZlcnNlQ0RGKHA6IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChwIDw9IDApIHJldHVybiAtSW5maW5pdHk7XG4gIGlmIChwID49IDEpIHJldHVybiBJbmZpbml0eTtcbiAgaWYgKHAgPT09IDAuNSkgcmV0dXJuIDA7XG4gIFxuICAvLyBDb2VmZmljaWVudHMgZm9yIHJhdGlvbmFsIGFwcHJveGltYXRpb25cbiAgY29uc3QgYSA9IFtcbiAgICAtMy45Njk2ODMwMjg2NjUzNzZlKzAxLFxuICAgICAyLjIwOTQ2MDk4NDI0NTIwNWUrMDIsXG4gICAgLTIuNzU5Mjg1MTA0NDY5Njg3ZSswMixcbiAgICAgMS4zODM1Nzc1MTg2NzI2OTBlKzAyLFxuICAgIC0zLjA2NjQ3OTgwNjYxNDcxNmUrMDEsXG4gICAgIDIuNTA2NjI4Mjc3NDU5MjM5ZSswMCxcbiAgXTtcbiAgY29uc3QgYiA9IFtcbiAgICAtNS40NDc2MDk4Nzk4MjI0MDZlKzAxLFxuICAgICAxLjYxNTg1ODM2ODU4MDQwOWUrMDIsXG4gICAgLTEuNTU2OTg5Nzk4NTk4ODY2ZSswMixcbiAgICAgNi42ODAxMzExODg3NzE5NzJlKzAxLFxuICAgIC0xLjMyODA2ODE1NTI4ODU3MmUrMDEsXG4gIF07XG4gIGNvbnN0IGMgPSBbXG4gICAgLTcuNzg0ODk0MDAyNDMwMjkzZS0wMyxcbiAgICAtMy4yMjM5NjQ1ODA0MTEzNjVlLTAxLFxuICAgIC0yLjQwMDc1ODI3NzE2MTgzOGUrMDAsXG4gICAgLTIuNTQ5NzMyNTM5MzQzNzM0ZSswMCxcbiAgICAgNC4zNzQ2NjQxNDE0NjQ5NjhlKzAwLFxuICAgICAyLjkzODE2Mzk4MjY5ODc4M2UrMDAsXG4gIF07XG4gIGNvbnN0IGQgPSBbXG4gICAgIDcuNzg0Njk1NzA5MDQxNDYyZS0wMyxcbiAgICAgMy4yMjQ2NzEyOTA3MDAzOThlLTAxLFxuICAgICAyLjQ0NTEzNDEzNzE0Mjk5NmUrMDAsXG4gICAgIDMuNzU0NDA4NjYxOTA3NDE2ZSswMCxcbiAgXTtcbiAgXG4gIGNvbnN0IHBMb3cgPSAwLjAyNDI1O1xuICBjb25zdCBwSGlnaCA9IDEgLSBwTG93O1xuICBsZXQgcTogbnVtYmVyLCByOiBudW1iZXI7XG4gIFxuICBpZiAocCA8IHBMb3cpIHtcbiAgICBxID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocCkpO1xuICAgIHJldHVybiAoKCgoKGNbMF0qcStjWzFdKSpxK2NbMl0pKnErY1szXSkqcStjWzRdKSpxK2NbNV0pIC9cbiAgICAgICAgICAgKCgoKGRbMF0qcStkWzFdKSpxK2RbMl0pKnErZFszXSkqcSsxKTtcbiAgfSBlbHNlIGlmIChwIDw9IHBIaWdoKSB7XG4gICAgcSA9IHAgLSAwLjU7XG4gICAgciA9IHEgKiBxO1xuICAgIHJldHVybiAoKCgoKGFbMF0qcithWzFdKSpyK2FbMl0pKnIrYVszXSkqcithWzRdKSpyK2FbNV0pKnEgL1xuICAgICAgICAgICAoKCgoKGJbMF0qcitiWzFdKSpyK2JbMl0pKnIrYlszXSkqcitiWzRdKSpyKzEpO1xuICB9IGVsc2Uge1xuICAgIHEgPSBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZygxIC0gcCkpO1xuICAgIHJldHVybiAtKCgoKChjWzBdKnErY1sxXSkqcStjWzJdKSpxK2NbM10pKnErY1s0XSkqcStjWzVdKSAvXG4gICAgICAgICAgICAoKCgoZFswXSpxK2RbMV0pKnErZFsyXSkqcStkWzNdKSpxKzEpO1xuICB9XG59XG5cbi8qKlxuICogUHJvYml0IGRlLXZpZyBtZXRob2RcbiAqIFxuICogVHJhbnNmb3JtcyBwcm9iYWJpbGl0aWVzIHZpYSBub3JtYWwgcXVhbnRpbGVzLCBhZGp1c3RzLCBhbmQgdHJhbnNmb3JtcyBiYWNrLlxuICogUHJvdmlkZXMgYSBzdGF0aXN0aWNhbGx5IHNtb290aGVyIGNvcnJlY3Rpb24gdGhhdCBoYW5kbGVzIGZhdm9yaXRlL2xvbmdzaG90IGJpYXMuXG4gKiBcbiAqIFRoZSBrZXkgaW5zaWdodCBpcyB0aGF0IHdlIG5lZWQgdG8gZmluZCBhIHNoaWZ0IHZhbHVlICdrJyBzdWNoIHRoYXQ6XG4gKiDOpih6X292ZXIgKyBrKSArIM6mKHpfdW5kZXIgKyBrKSA9IDFcbiAqIFxuICogU2luY2UgzqYoeikgKyDOpigteikgPSAxLCB3ZSBuZWVkOiB6X292ZXIgKyBrID0gLSh6X3VuZGVyICsgaylcbiAqIFdoaWNoIGdpdmVzIHVzOiBrID0gLSh6X292ZXIgKyB6X3VuZGVyKSAvIDJcbiAqIFxuICogQHBhcmFtIG92ZXJPZGRzIEFtZXJpY2FuIG9kZHMgZm9yIG92ZXJcbiAqIEBwYXJhbSB1bmRlck9kZHMgQW1lcmljYW4gb2RkcyBmb3IgdW5kZXJcbiAqIEByZXR1cm5zIERldmlnUmVzdWx0IHdpdGggZmFpciBwcm9iYWJpbGl0aWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXZpZ1Byb2JpdChvdmVyT2RkczogbnVtYmVyLCB1bmRlck9kZHM6IG51bWJlcik6IERldmlnUmVzdWx0IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcm9iT3ZlciA9IGFtZXJpY2FuVG9JbXBsaWVkUHJvYihvdmVyT2Rkcyk7XG4gICAgY29uc3QgcHJvYlVuZGVyID0gYW1lcmljYW5Ub0ltcGxpZWRQcm9iKHVuZGVyT2Rkcyk7XG4gICAgY29uc3QgbWFyZ2luID0gcHJvYk92ZXIgKyBwcm9iVW5kZXIgLSAxO1xuICAgIFxuICAgIC8vIElmIG1hcmdpbiBpcyB2ZXJ5IHNtYWxsLCBqdXN0IHVzZSBtdWx0aXBsaWNhdGl2ZSAobW9yZSBzdGFibGUpXG4gICAgaWYgKE1hdGguYWJzKG1hcmdpbikgPCAwLjAwMSkge1xuICAgICAgY29uc3QgZmFpclByb2JPdmVyID0gcHJvYk92ZXIgLyAocHJvYk92ZXIgKyBwcm9iVW5kZXIpO1xuICAgICAgY29uc3QgZmFpclByb2JVbmRlciA9IHByb2JVbmRlciAvIChwcm9iT3ZlciArIHByb2JVbmRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2Q6IFwicHJvYml0XCIsXG4gICAgICAgIGZhaXJQcm9iT3ZlcixcbiAgICAgICAgZmFpclByb2JVbmRlcixcbiAgICAgICAgbWFyZ2luLFxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xhbXAgdG8gYXZvaWQgaW5maW5pdHkgaW4gcHJvYml0XG4gICAgY29uc3QgY2xhbXBlZE92ZXIgPSBNYXRoLm1heCgwLjAwMSwgTWF0aC5taW4oMC45OTksIHByb2JPdmVyKSk7XG4gICAgY29uc3QgY2xhbXBlZFVuZGVyID0gTWF0aC5tYXgoMC4wMDEsIE1hdGgubWluKDAuOTk5LCBwcm9iVW5kZXIpKTtcbiAgICBcbiAgICAvLyBUcmFuc2Zvcm0gdG8gbm9ybWFsIHNjYWxlICh6LXNjb3JlcylcbiAgICBjb25zdCB6T3ZlciA9IG5vcm1hbEludmVyc2VDREYoY2xhbXBlZE92ZXIpO1xuICAgIGNvbnN0IHpVbmRlciA9IG5vcm1hbEludmVyc2VDREYoY2xhbXBlZFVuZGVyKTtcbiAgICBcbiAgICAvLyBUaGUgYW5hbHl0aWNhbCBzb2x1dGlvbjogc2hpZnQgYm90aCB6LXNjb3JlcyBieSAtayB3aGVyZSBrID0gKHpPdmVyICsgelVuZGVyKSAvIDJcbiAgICAvLyBUaGlzIG1ha2VzIHRoZSBhZGp1c3RlZCB6LXNjb3JlcyBzeW1tZXRyaWMgYXJvdW5kIDAsIGVuc3VyaW5nIHByb2JzIHN1bSB0byAxXG4gICAgY29uc3QgayA9ICh6T3ZlciArIHpVbmRlcikgLyAyO1xuICAgIFxuICAgIGNvbnN0IGZhaXJQcm9iT3ZlciA9IG5vcm1hbENERih6T3ZlciAtIGspO1xuICAgIGNvbnN0IGZhaXJQcm9iVW5kZXIgPSBub3JtYWxDREYoelVuZGVyIC0gayk7XG4gICAgXG4gICAgLy8gU2FmZXR5IGNoZWNrOiBpZiByZXN1bHRzIGFyZSB1bnJlYXNvbmFibGUsIGZhbGwgYmFjayB0byBtdWx0aXBsaWNhdGl2ZVxuICAgIGlmIChmYWlyUHJvYk92ZXIgPD0gMCB8fCBmYWlyUHJvYk92ZXIgPj0gMSB8fCBmYWlyUHJvYlVuZGVyIDw9IDAgfHwgZmFpclByb2JVbmRlciA+PSAxIHx8XG4gICAgICAgICFpc0Zpbml0ZShmYWlyUHJvYk92ZXIpIHx8ICFpc0Zpbml0ZShmYWlyUHJvYlVuZGVyKSkge1xuICAgICAgY29uc3QgZmFpclByb2JPdmVyRmFsbGJhY2sgPSBwcm9iT3ZlciAvIChwcm9iT3ZlciArIHByb2JVbmRlcik7XG4gICAgICBjb25zdCBmYWlyUHJvYlVuZGVyRmFsbGJhY2sgPSBwcm9iVW5kZXIgLyAocHJvYk92ZXIgKyBwcm9iVW5kZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kOiBcInByb2JpdFwiLFxuICAgICAgICBmYWlyUHJvYk92ZXI6IGZhaXJQcm9iT3ZlckZhbGxiYWNrLFxuICAgICAgICBmYWlyUHJvYlVuZGVyOiBmYWlyUHJvYlVuZGVyRmFsbGJhY2ssXG4gICAgICAgIG1hcmdpbixcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIE5vcm1hbGl6ZSB0byBlbnN1cmUgc3VtIGlzIGV4YWN0bHkgMSAoaGFuZGxlIGFueSBmbG9hdGluZyBwb2ludCBlcnJvcnMpXG4gICAgY29uc3QgdG90YWwgPSBmYWlyUHJvYk92ZXIgKyBmYWlyUHJvYlVuZGVyO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6IFwicHJvYml0XCIsXG4gICAgICBmYWlyUHJvYk92ZXI6IGZhaXJQcm9iT3ZlciAvIHRvdGFsLFxuICAgICAgZmFpclByb2JVbmRlcjogZmFpclByb2JVbmRlciAvIHRvdGFsLFxuICAgICAgbWFyZ2luLFxuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWV0aG9kOiBcInByb2JpdFwiLFxuICAgICAgZmFpclByb2JPdmVyOiAwLFxuICAgICAgZmFpclByb2JVbmRlcjogMCxcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIixcbiAgICB9O1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBNdWx0aS1NZXRob2QgRGUtdmlnXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFJ1biBtdWx0aXBsZSBkZS12aWcgbWV0aG9kcyBhbmQgcmV0dXJuIGFsbCByZXN1bHRzXG4gKiBcbiAqIEBwYXJhbSBvdmVyT2RkcyBBbWVyaWNhbiBvZGRzIGZvciBvdmVyXG4gKiBAcGFyYW0gdW5kZXJPZGRzIEFtZXJpY2FuIG9kZHMgZm9yIHVuZGVyXG4gKiBAcGFyYW0gbWV0aG9kcyBXaGljaCBtZXRob2RzIHRvIHJ1biAoZGVmYXVsdDogcG93ZXIsIG11bHRpcGxpY2F0aXZlKVxuICogQHJldHVybnMgUmVzdWx0cyBmcm9tIGVhY2ggbWV0aG9kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXZpZ011bHRpcGxlKFxuICBvdmVyT2RkczogbnVtYmVyLFxuICB1bmRlck9kZHM6IG51bWJlcixcbiAgbWV0aG9kczogRGV2aWdNZXRob2RbXSA9IERFRkFVTFRfREVWSUdfTUVUSE9EU1xuKTogTXVsdGlEZXZpZ1Jlc3VsdCB7XG4gIGNvbnN0IHJlc3VsdHM6IE11bHRpRGV2aWdSZXN1bHQgPSB7fTtcbiAgXG4gIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSBcInBvd2VyXCI6XG4gICAgICAgIHJlc3VsdHMucG93ZXIgPSBkZXZpZ1Bvd2VyKG92ZXJPZGRzLCB1bmRlck9kZHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtdWx0aXBsaWNhdGl2ZVwiOlxuICAgICAgICByZXN1bHRzLm11bHRpcGxpY2F0aXZlID0gZGV2aWdNdWx0aXBsaWNhdGl2ZShvdmVyT2RkcywgdW5kZXJPZGRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWRkaXRpdmVcIjpcbiAgICAgICAgcmVzdWx0cy5hZGRpdGl2ZSA9IGRldmlnQWRkaXRpdmUob3Zlck9kZHMsIHVuZGVyT2Rkcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByb2JpdFwiOlxuICAgICAgICByZXN1bHRzLnByb2JpdCA9IGRldmlnUHJvYml0KG92ZXJPZGRzLCB1bmRlck9kZHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRVYgQ2FsY3VsYXRpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogQ2FsY3VsYXRlIEV4cGVjdGVkIFZhbHVlIGZvciBhIHNpbmdsZSBiZXRcbiAqIFxuICogRVYgPSAocF9mYWlyICogZGVjaW1hbF9wYXlvdXQpIC0gMVxuICogXG4gKiBAcGFyYW0gZmFpclByb2IgRmFpciBwcm9iYWJpbGl0eSAoMC0xKVxuICogQHBhcmFtIGJvb2tPZGRzIEJvb2sncyBBbWVyaWNhbiBvZGRzXG4gKiBAcmV0dXJucyBFViBhcyBkZWNpbWFsIChlLmcuLCAwLjA1ID0gNSUgRVYpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVFVihmYWlyUHJvYjogbnVtYmVyLCBib29rT2RkczogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgZGVjaW1hbCA9IGFtZXJpY2FuVG9EZWNpbWFsKGJvb2tPZGRzKTtcbiAgcmV0dXJuIChmYWlyUHJvYiAqIGRlY2ltYWwpIC0gMTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgS2VsbHkgZnJhY3Rpb24gZm9yIG9wdGltYWwgYmV0IHNpemluZ1xuICogXG4gKiBLZWxseSA9IChwICogKGQgLSAxKSAtICgxIC0gcCkpIC8gKGQgLSAxKVxuICogICAgICAgPSAocCAqIGQgLSAxKSAvIChkIC0gMSlcbiAqIFxuICogV2hlcmU6XG4gKiAtIHAgPSBmYWlyIHByb2JhYmlsaXR5XG4gKiAtIGQgPSBkZWNpbWFsIG9kZHNcbiAqIFxuICogQHBhcmFtIGZhaXJQcm9iIEZhaXIgcHJvYmFiaWxpdHkgKDAtMSlcbiAqIEBwYXJhbSBib29rT2RkcyBCb29rJ3MgQW1lcmljYW4gb2Rkc1xuICogQHJldHVybnMgT3B0aW1hbCBmcmFjdGlvbiBvZiBiYW5rcm9sbCB0byBiZXQgKDAtMSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUtlbGx5KGZhaXJQcm9iOiBudW1iZXIsIGJvb2tPZGRzOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBkZWNpbWFsID0gYW1lcmljYW5Ub0RlY2ltYWwoYm9va09kZHMpO1xuICBcbiAgaWYgKGRlY2ltYWwgPD0gMSkgcmV0dXJuIDA7XG4gIFxuICBjb25zdCBrZWxseSA9IChmYWlyUHJvYiAqIGRlY2ltYWwgLSAxKSAvIChkZWNpbWFsIC0gMSk7XG4gIFxuICAvLyBSZXR1cm4gMCBpZiBuZWdhdGl2ZSAobm8gZWRnZSlcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGtlbGx5KTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZnVsbCBFViBkZXRhaWxzIGZvciBhIGJvb2sgb2ZmZXIgdXNpbmcgYSBzcGVjaWZpYyBkZS12aWcgbWV0aG9kXG4gKiBcbiAqIEBwYXJhbSBmYWlyUHJvYiBGYWlyIHByb2JhYmlsaXR5IGZyb20gZGUtdmlnXG4gKiBAcGFyYW0gYm9va09mZmVyIEJvb2sncyBvZGRzIG9mZmVyXG4gKiBAcGFyYW0gbWV0aG9kIFdoaWNoIGRlLXZpZyBtZXRob2Qgd2FzIHVzZWRcbiAqIEByZXR1cm5zIEZ1bGwgRVYgY2FsY3VsYXRpb24gZGV0YWlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlRVZEZXRhaWxzKFxuICBmYWlyUHJvYjogbnVtYmVyLFxuICBib29rT2ZmZXI6IEJvb2tPZmZlcixcbiAgbWV0aG9kOiBEZXZpZ01ldGhvZFxuKTogRVZDYWxjdWxhdGlvbiB7XG4gIGNvbnN0IGJvb2tEZWNpbWFsID0gYW1lcmljYW5Ub0RlY2ltYWwoYm9va09mZmVyLnByaWNlKTtcbiAgY29uc3QgYm9va1Byb2IgPSBhbWVyaWNhblRvSW1wbGllZFByb2IoYm9va09mZmVyLnByaWNlKTtcbiAgY29uc3QgZXYgPSBjYWxjdWxhdGVFVihmYWlyUHJvYiwgYm9va09mZmVyLnByaWNlKTtcbiAgY29uc3Qga2VsbHkgPSBjYWxjdWxhdGVLZWxseShmYWlyUHJvYiwgYm9va09mZmVyLnByaWNlKTtcbiAgXG4gIHJldHVybiB7XG4gICAgbWV0aG9kLFxuICAgIGZhaXJQcm9iLFxuICAgIGJvb2tQcm9iLFxuICAgIGJvb2tEZWNpbWFsLFxuICAgIGV2LFxuICAgIGV2UGVyY2VudDogZXYgKiAxMDAsXG4gICAgZWRnZTogYm9va1Byb2IgLSBmYWlyUHJvYiwgLy8gSG93IG11Y2ggdGhlIGJvb2sgaXMgXCJvZmZcIlxuICAgIGtlbGx5RnJhY3Rpb246IGtlbGx5LFxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBFViB1c2luZyBtdWx0aXBsZSBkZS12aWcgbWV0aG9kc1xuICogXG4gKiBAcGFyYW0gZGV2aWdSZXN1bHRzIFJlc3VsdHMgZnJvbSBtdWx0aS1tZXRob2QgZGUtdmlnXG4gKiBAcGFyYW0gYm9va09mZmVyIEJvb2sncyBvZGRzIG9mZmVyXG4gKiBAcGFyYW0gc2lkZSBXaGljaCBzaWRlIHRvIGNhbGN1bGF0ZSBmb3IgKFwib3ZlclwiIG9yIFwidW5kZXJcIilcbiAqIEByZXR1cm5zIENvbWJpbmVkIEVWIGNhbGN1bGF0aW9ucyB3aXRoIHdvcnN0L2Jlc3QvZGlzcGxheSB2YWx1ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZU11bHRpRVYoXG4gIGRldmlnUmVzdWx0czogTXVsdGlEZXZpZ1Jlc3VsdCxcbiAgYm9va09mZmVyOiBCb29rT2ZmZXIsXG4gIHNpZGU6IFwib3ZlclwiIHwgXCJ1bmRlclwiXG4pOiBNdWx0aUVWQ2FsY3VsYXRpb24ge1xuICBjb25zdCByZXN1bHQ6IE11bHRpRVZDYWxjdWxhdGlvbiA9IHtcbiAgICBldldvcnN0OiBJbmZpbml0eSxcbiAgICBldkJlc3Q6IC1JbmZpbml0eSxcbiAgICBldkRpc3BsYXk6IDAsXG4gIH07XG4gIFxuICBjb25zdCBldlZhbHVlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qga2VsbHlWYWx1ZXM6IG51bWJlcltdID0gW107XG4gIFxuICAvLyBDYWxjdWxhdGUgRVYgZm9yIGVhY2ggYXZhaWxhYmxlIG1ldGhvZFxuICBpZiAoZGV2aWdSZXN1bHRzLnBvd2VyPy5zdWNjZXNzKSB7XG4gICAgY29uc3QgZmFpclByb2IgPSBzaWRlID09PSBcIm92ZXJcIiBcbiAgICAgID8gZGV2aWdSZXN1bHRzLnBvd2VyLmZhaXJQcm9iT3ZlciBcbiAgICAgIDogZGV2aWdSZXN1bHRzLnBvd2VyLmZhaXJQcm9iVW5kZXI7XG4gICAgcmVzdWx0LnBvd2VyID0gY2FsY3VsYXRlRVZEZXRhaWxzKGZhaXJQcm9iLCBib29rT2ZmZXIsIFwicG93ZXJcIik7XG4gICAgZXZWYWx1ZXMucHVzaChyZXN1bHQucG93ZXIuZXZQZXJjZW50KTtcbiAgICBpZiAocmVzdWx0LnBvd2VyLmtlbGx5RnJhY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAga2VsbHlWYWx1ZXMucHVzaChyZXN1bHQucG93ZXIua2VsbHlGcmFjdGlvbik7XG4gICAgfVxuICB9XG4gIFxuICBpZiAoZGV2aWdSZXN1bHRzLm11bHRpcGxpY2F0aXZlPy5zdWNjZXNzKSB7XG4gICAgY29uc3QgZmFpclByb2IgPSBzaWRlID09PSBcIm92ZXJcIiBcbiAgICAgID8gZGV2aWdSZXN1bHRzLm11bHRpcGxpY2F0aXZlLmZhaXJQcm9iT3ZlciBcbiAgICAgIDogZGV2aWdSZXN1bHRzLm11bHRpcGxpY2F0aXZlLmZhaXJQcm9iVW5kZXI7XG4gICAgcmVzdWx0Lm11bHRpcGxpY2F0aXZlID0gY2FsY3VsYXRlRVZEZXRhaWxzKGZhaXJQcm9iLCBib29rT2ZmZXIsIFwibXVsdGlwbGljYXRpdmVcIik7XG4gICAgZXZWYWx1ZXMucHVzaChyZXN1bHQubXVsdGlwbGljYXRpdmUuZXZQZXJjZW50KTtcbiAgICBpZiAocmVzdWx0Lm11bHRpcGxpY2F0aXZlLmtlbGx5RnJhY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAga2VsbHlWYWx1ZXMucHVzaChyZXN1bHQubXVsdGlwbGljYXRpdmUua2VsbHlGcmFjdGlvbik7XG4gICAgfVxuICB9XG4gIFxuICBpZiAoZGV2aWdSZXN1bHRzLmFkZGl0aXZlPy5zdWNjZXNzKSB7XG4gICAgY29uc3QgZmFpclByb2IgPSBzaWRlID09PSBcIm92ZXJcIiBcbiAgICAgID8gZGV2aWdSZXN1bHRzLmFkZGl0aXZlLmZhaXJQcm9iT3ZlciBcbiAgICAgIDogZGV2aWdSZXN1bHRzLmFkZGl0aXZlLmZhaXJQcm9iVW5kZXI7XG4gICAgcmVzdWx0LmFkZGl0aXZlID0gY2FsY3VsYXRlRVZEZXRhaWxzKGZhaXJQcm9iLCBib29rT2ZmZXIsIFwiYWRkaXRpdmVcIik7XG4gICAgZXZWYWx1ZXMucHVzaChyZXN1bHQuYWRkaXRpdmUuZXZQZXJjZW50KTtcbiAgICBpZiAocmVzdWx0LmFkZGl0aXZlLmtlbGx5RnJhY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAga2VsbHlWYWx1ZXMucHVzaChyZXN1bHQuYWRkaXRpdmUua2VsbHlGcmFjdGlvbik7XG4gICAgfVxuICB9XG4gIFxuICBpZiAoZGV2aWdSZXN1bHRzLnByb2JpdD8uc3VjY2Vzcykge1xuICAgIGNvbnN0IGZhaXJQcm9iID0gc2lkZSA9PT0gXCJvdmVyXCIgXG4gICAgICA/IGRldmlnUmVzdWx0cy5wcm9iaXQuZmFpclByb2JPdmVyIFxuICAgICAgOiBkZXZpZ1Jlc3VsdHMucHJvYml0LmZhaXJQcm9iVW5kZXI7XG4gICAgcmVzdWx0LnByb2JpdCA9IGNhbGN1bGF0ZUVWRGV0YWlscyhmYWlyUHJvYiwgYm9va09mZmVyLCBcInByb2JpdFwiKTtcbiAgICBldlZhbHVlcy5wdXNoKHJlc3VsdC5wcm9iaXQuZXZQZXJjZW50KTtcbiAgICBpZiAocmVzdWx0LnByb2JpdC5rZWxseUZyYWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtlbGx5VmFsdWVzLnB1c2gocmVzdWx0LnByb2JpdC5rZWxseUZyYWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENhbGN1bGF0ZSBhZ2dyZWdhdGVkIHZhbHVlc1xuICBpZiAoZXZWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5ldldvcnN0ID0gTWF0aC5taW4oLi4uZXZWYWx1ZXMpO1xuICAgIHJlc3VsdC5ldkJlc3QgPSBNYXRoLm1heCguLi5ldlZhbHVlcyk7XG4gICAgcmVzdWx0LmV2RGlzcGxheSA9IHJlc3VsdC5ldldvcnN0OyAvLyBEZWZhdWx0IHRvIGNvbnNlcnZhdGl2ZVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5ldldvcnN0ID0gMDtcbiAgICByZXN1bHQuZXZCZXN0ID0gMDtcbiAgICByZXN1bHQuZXZEaXNwbGF5ID0gMDtcbiAgfVxuICBcbiAgaWYgKGtlbGx5VmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICByZXN1bHQua2VsbHlXb3JzdCA9IE1hdGgubWluKC4uLmtlbGx5VmFsdWVzKTtcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFNoYXJwIFJlZmVyZW5jZSBIZWxwZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEJsZW5kIG9kZHMgZnJvbSBtdWx0aXBsZSBzaGFycCBib29rc1xuICogXG4gKiBAcGFyYW0gYm9va09kZHMgQXJyYXkgb2YgeyBib29rSWQsIG9kZHMsIHdlaWdodCB9XG4gKiBAcmV0dXJucyBCbGVuZGVkIEFtZXJpY2FuIG9kZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJsZW5kU2hhcnBPZGRzKFxuICBib29rT2RkczogeyBib29rSWQ6IHN0cmluZzsgb2RkczogbnVtYmVyOyB3ZWlnaHQ6IG51bWJlciB9W11cbik6IG51bWJlciB7XG4gIGlmIChib29rT2Rkcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICBpZiAoYm9va09kZHMubGVuZ3RoID09PSAxKSByZXR1cm4gYm9va09kZHNbMF0ub2RkcztcbiAgXG4gIC8vIENvbnZlcnQgdG8gcHJvYmFiaWxpdGllcywgYmxlbmQsIGNvbnZlcnQgYmFja1xuICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuICBsZXQgYmxlbmRlZFByb2IgPSAwO1xuICBcbiAgZm9yIChjb25zdCB7IG9kZHMsIHdlaWdodCB9IG9mIGJvb2tPZGRzKSB7XG4gICAgY29uc3QgcHJvYiA9IGFtZXJpY2FuVG9JbXBsaWVkUHJvYihvZGRzKTtcbiAgICBibGVuZGVkUHJvYiArPSBwcm9iICogd2VpZ2h0O1xuICAgIHRvdGFsV2VpZ2h0ICs9IHdlaWdodDtcbiAgfVxuICBcbiAgaWYgKHRvdGFsV2VpZ2h0ID09PSAwKSByZXR1cm4gMDtcbiAgXG4gIGJsZW5kZWRQcm9iID0gYmxlbmRlZFByb2IgLyB0b3RhbFdlaWdodDtcbiAgcmV0dXJuIGltcGxpZWRQcm9iVG9BbWVyaWNhbihibGVuZGVkUHJvYik7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2hhcnAgcmVmZXJlbmNlIGZyb20gYm9vayBvZGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaGFycFJlZmVyZW5jZShcbiAgb3Zlck9kZHM6IG51bWJlcixcbiAgdW5kZXJPZGRzOiBudW1iZXIsXG4gIHByZXNldDogc3RyaW5nLFxuICBzb3VyY2U6IHN0cmluZyxcbiAgYmxlbmRlZEZyb20/OiBzdHJpbmdbXVxuKTogU2hhcnBSZWZlcmVuY2Uge1xuICByZXR1cm4ge1xuICAgIHByZXNldDogcHJlc2V0IGFzIFNoYXJwUmVmZXJlbmNlW1wicHJlc2V0XCJdLFxuICAgIG92ZXJPZGRzLFxuICAgIHVuZGVyT2RkcyxcbiAgICBvdmVyRGVjaW1hbDogYW1lcmljYW5Ub0RlY2ltYWwob3Zlck9kZHMpLFxuICAgIHVuZGVyRGVjaW1hbDogYW1lcmljYW5Ub0RlY2ltYWwodW5kZXJPZGRzKSxcbiAgICBzb3VyY2UsXG4gICAgYmxlbmRlZEZyb20sXG4gIH07XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBVdGlsaXR5IEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBDaGVjayBpZiBhIG1hcmtldCBpcyArRVYgYmFzZWQgb24gZGUtdmlnIHJlc3VsdHNcbiAqIFxuICogQHBhcmFtIGV2Q2FsYyBFViBjYWxjdWxhdGlvbiByZXN1bHRzXG4gKiBAcGFyYW0gbWluRVYgTWluaW11bSBFViUgdGhyZXNob2xkXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBiZXQgaXMgK0VWIChhYm92ZSB0aHJlc2hvbGQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Bvc2l0aXZlRVYoZXZDYWxjOiBNdWx0aUVWQ2FsY3VsYXRpb24sIG1pbkVWOiBudW1iZXIgPSAwKTogYm9vbGVhbiB7XG4gIHJldHVybiBldkNhbGMuZXZXb3JzdCA+IG1pbkVWO1xufVxuXG4vKipcbiAqIEZvcm1hdCBFViBwZXJjZW50YWdlIGZvciBkaXNwbGF5XG4gKiBcbiAqIEBwYXJhbSBldiBFViBhcyBwZXJjZW50YWdlIChlLmcuLCA1LjIzKVxuICogQHJldHVybnMgRm9ybWF0dGVkIHN0cmluZyAoZS5nLiwgXCIrNS4yJVwiKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RVYoZXY6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IHNpZ24gPSBldiA+PSAwID8gXCIrXCIgOiBcIlwiO1xuICByZXR1cm4gYCR7c2lnbn0ke2V2LnRvRml4ZWQoMSl9JWA7XG59XG5cbi8qKlxuICogRm9ybWF0IEtlbGx5IGZyYWN0aW9uIGFzIHBlcmNlbnRhZ2VcbiAqIFxuICogQHBhcmFtIGtlbGx5IEtlbGx5IGZyYWN0aW9uIChlLmcuLCAwLjAyMzQpXG4gKiBAcGFyYW0gZnJhY3Rpb24gS2VsbHkgbXVsdGlwbGllciAoZS5nLiwgMC4yNSBmb3IgcXVhcnRlciBLZWxseSlcbiAqIEByZXR1cm5zIEZvcm1hdHRlZCBzdHJpbmcgKGUuZy4sIFwiMC42JVwiKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0S2VsbHkoa2VsbHk6IG51bWJlciwgZnJhY3Rpb246IG51bWJlciA9IDEpOiBzdHJpbmcge1xuICBjb25zdCBhZGp1c3RlZCA9IGtlbGx5ICogZnJhY3Rpb24gKiAxMDA7XG4gIHJldHVybiBgJHthZGp1c3RlZC50b0ZpeGVkKDEpfSVgO1xufVxuXG4vKipcbiAqIEdldCBLZWxseSBzdGFrZSBhbW91bnRcbiAqIFxuICogQHBhcmFtIGtlbGx5IEtlbGx5IGZyYWN0aW9uXG4gKiBAcGFyYW0gYmFua3JvbGwgVG90YWwgYmFua3JvbGxcbiAqIEBwYXJhbSBmcmFjdGlvbiBLZWxseSBtdWx0aXBsaWVyIChlLmcuLCAwLjI1IGZvciBxdWFydGVyIEtlbGx5KVxuICogQHJldHVybnMgU3Rha2UgYW1vdW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZWxseVN0YWtlKGtlbGx5OiBudW1iZXIsIGJhbmtyb2xsOiBudW1iZXIsIGZyYWN0aW9uOiBudW1iZXIgPSAxKTogbnVtYmVyIHtcbiAgcmV0dXJuIGJhbmtyb2xsICoga2VsbHkgKiBmcmFjdGlvbjtcbn1cbiJdLCJuYW1lcyI6WyJERUZBVUxUX0RFVklHX01FVEhPRFMiLCJhbWVyaWNhblRvSW1wbGllZFByb2IiLCJvZGRzIiwiTWF0aCIsImFicyIsImFtZXJpY2FuVG9EZWNpbWFsIiwiZGVjaW1hbFRvQW1lcmljYW4iLCJkZWNpbWFsIiwicm91bmQiLCJpbXBsaWVkUHJvYlRvQW1lcmljYW4iLCJwcm9iIiwiaW1wbGllZFByb2JUb0RlY2ltYWwiLCJJbmZpbml0eSIsImNhbGN1bGF0ZU1hcmdpbiIsInByb2JPdmVyIiwicHJvYlVuZGVyIiwiY2FsY3VsYXRlTWFyZ2luRnJvbU9kZHMiLCJvdmVyT2RkcyIsInVuZGVyT2RkcyIsImRldmlnTXVsdGlwbGljYXRpdmUiLCJ0b3RhbCIsIm1ldGhvZCIsImZhaXJQcm9iT3ZlciIsImZhaXJQcm9iVW5kZXIiLCJtYXJnaW4iLCJzdWNjZXNzIiwiZXJyb3IiLCJlcnIiLCJFcnJvciIsIm1lc3NhZ2UiLCJkZXZpZ0FkZGl0aXZlIiwibmVlZHNDbGFtcGluZyIsIm1heCIsIm1pbiIsInVuZGVmaW5lZCIsImRldmlnUG93ZXIiLCJrTG93Iiwia0hpZ2giLCJrIiwidG9sZXJhbmNlIiwibWF4SXRlcmF0aW9ucyIsImkiLCJzdW0iLCJwb3ciLCJub3JtYWxDREYiLCJ4IiwiYTEiLCJhMiIsImEzIiwiYTQiLCJhNSIsInAiLCJzaWduIiwic3FydCIsInQiLCJ5IiwiZXhwIiwibm9ybWFsSW52ZXJzZUNERiIsImEiLCJiIiwiYyIsImQiLCJwTG93IiwicEhpZ2giLCJxIiwiciIsImxvZyIsImRldmlnUHJvYml0IiwiY2xhbXBlZE92ZXIiLCJjbGFtcGVkVW5kZXIiLCJ6T3ZlciIsInpVbmRlciIsImlzRmluaXRlIiwiZmFpclByb2JPdmVyRmFsbGJhY2siLCJmYWlyUHJvYlVuZGVyRmFsbGJhY2siLCJkZXZpZ011bHRpcGxlIiwibWV0aG9kcyIsInJlc3VsdHMiLCJwb3dlciIsIm11bHRpcGxpY2F0aXZlIiwiYWRkaXRpdmUiLCJwcm9iaXQiLCJjYWxjdWxhdGVFViIsImZhaXJQcm9iIiwiYm9va09kZHMiLCJjYWxjdWxhdGVLZWxseSIsImtlbGx5IiwiY2FsY3VsYXRlRVZEZXRhaWxzIiwiYm9va09mZmVyIiwiYm9va0RlY2ltYWwiLCJwcmljZSIsImJvb2tQcm9iIiwiZXYiLCJldlBlcmNlbnQiLCJlZGdlIiwia2VsbHlGcmFjdGlvbiIsImNhbGN1bGF0ZU11bHRpRVYiLCJkZXZpZ1Jlc3VsdHMiLCJzaWRlIiwicmVzdWx0IiwiZXZXb3JzdCIsImV2QmVzdCIsImV2RGlzcGxheSIsImV2VmFsdWVzIiwia2VsbHlWYWx1ZXMiLCJwdXNoIiwibGVuZ3RoIiwia2VsbHlXb3JzdCIsImJsZW5kU2hhcnBPZGRzIiwidG90YWxXZWlnaHQiLCJibGVuZGVkUHJvYiIsIndlaWdodCIsImNyZWF0ZVNoYXJwUmVmZXJlbmNlIiwicHJlc2V0Iiwic291cmNlIiwiYmxlbmRlZEZyb20iLCJvdmVyRGVjaW1hbCIsInVuZGVyRGVjaW1hbCIsImlzUG9zaXRpdmVFViIsImV2Q2FsYyIsIm1pbkVWIiwiZm9ybWF0RVYiLCJ0b0ZpeGVkIiwiZm9ybWF0S2VsbHkiLCJmcmFjdGlvbiIsImFkanVzdGVkIiwiZ2V0S2VsbHlTdGFrZSIsImJhbmtyb2xsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/ev/devig.ts\n");

/***/ }),

/***/ "(rsc)/./lib/ev/index.ts":
/*!*************************!*\
  !*** ./lib/ev/index.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALL_DEVIG_METHODS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.ALL_DEVIG_METHODS),\n/* harmony export */   DEFAULT_DEVIG_METHODS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DEVIG_METHODS),\n/* harmony export */   DEVIG_METHODS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.DEVIG_METHODS),\n/* harmony export */   EV_THRESHOLDS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.EV_THRESHOLDS),\n/* harmony export */   NON_TWO_WAY_MARKETS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.NON_TWO_WAY_MARKETS),\n/* harmony export */   POSITIVE_EV_DEFAULTS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.POSITIVE_EV_DEFAULTS),\n/* harmony export */   SHARP_BOOKS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.SHARP_BOOKS),\n/* harmony export */   SHARP_PRESETS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.SHARP_PRESETS),\n/* harmony export */   SOFT_BOOKS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.SOFT_BOOKS),\n/* harmony export */   SUPPORTED_SPORTS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.SUPPORTED_SPORTS),\n/* harmony export */   TWO_WAY_MARKETS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_0__.TWO_WAY_MARKETS),\n/* harmony export */   americanToDecimal: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.americanToDecimal),\n/* harmony export */   americanToImpliedProb: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.americanToImpliedProb),\n/* harmony export */   blendSharpOdds: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.blendSharpOdds),\n/* harmony export */   calculateEV: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.calculateEV),\n/* harmony export */   calculateEVDetails: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.calculateEVDetails),\n/* harmony export */   calculateKelly: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.calculateKelly),\n/* harmony export */   calculateMargin: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.calculateMargin),\n/* harmony export */   calculateMarginFromOdds: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.calculateMarginFromOdds),\n/* harmony export */   calculateMultiEV: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.calculateMultiEV),\n/* harmony export */   createSharpReference: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.createSharpReference),\n/* harmony export */   decimalToAmerican: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.decimalToAmerican),\n/* harmony export */   devigAdditive: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.devigAdditive),\n/* harmony export */   devigMultiple: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.devigMultiple),\n/* harmony export */   devigMultiplicative: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.devigMultiplicative),\n/* harmony export */   devigPower: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.devigPower),\n/* harmony export */   devigProbit: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.devigProbit),\n/* harmony export */   formatEV: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.formatEV),\n/* harmony export */   formatKelly: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.formatKelly),\n/* harmony export */   getKellyStake: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.getKellyStake),\n/* harmony export */   impliedProbToAmerican: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.impliedProbToAmerican),\n/* harmony export */   impliedProbToDecimal: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.impliedProbToDecimal),\n/* harmony export */   isPositiveEV: () => (/* reexport safe */ _devig__WEBPACK_IMPORTED_MODULE_1__.isPositiveEV)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(rsc)/./lib/ev/constants.ts\");\n/* harmony import */ var _devig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./devig */ \"(rsc)/./lib/ev/devig.ts\");\n/**\n * Positive EV Library\n * \n * Core library for Expected Value calculations using de-vigging methods.\n * \n * Usage:\n * ```typescript\n * import { \n *   devigPower, \n *   devigMultiplicative, \n *   calculateEV,\n *   calculateMultiEV \n * } from \"@/lib/ev\";\n * \n * // De-vig sharp odds\n * const sharpOver = -110;\n * const sharpUnder = -110;\n * const devigResult = devigPower(sharpOver, sharpUnder);\n * \n * // Calculate EV for a soft book offer\n * const ev = calculateEV(devigResult.fairProbOver, +105);\n * console.log(`EV: ${(ev * 100).toFixed(1)}%`); // \"EV: 2.5%\"\n * ```\n */ // Types\n// Constants\n\n// Odds conversion functions\n\n// Margin calculation\n\n// De-vig methods\n\n// EV calculation\n\n// Sharp reference helpers\n\n// Utility functions\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvZXYvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FFRCxRQUFRO0FBb0JSLFlBQVk7QUFhUztBQUVyQiw0QkFBNEI7QUFPWDtBQUVqQixxQkFBcUI7QUFJSjtBQUVqQixpQkFBaUI7QUFPQTtBQUVqQixpQkFBaUI7QUFNQTtBQUVqQiwwQkFBMEI7QUFJVDtBQUVqQixvQkFBb0I7QUFNSCIsInNvdXJjZXMiOlsiL1VzZXJzL2RyZXdtYXNjaG9mZi9kZXYvdW5qdWljZWQvYXBwcy93ZWIvbGliL2V2L2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUG9zaXRpdmUgRVYgTGlicmFyeVxuICogXG4gKiBDb3JlIGxpYnJhcnkgZm9yIEV4cGVjdGVkIFZhbHVlIGNhbGN1bGF0aW9ucyB1c2luZyBkZS12aWdnaW5nIG1ldGhvZHMuXG4gKiBcbiAqIFVzYWdlOlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgXG4gKiAgIGRldmlnUG93ZXIsIFxuICogICBkZXZpZ011bHRpcGxpY2F0aXZlLCBcbiAqICAgY2FsY3VsYXRlRVYsXG4gKiAgIGNhbGN1bGF0ZU11bHRpRVYgXG4gKiB9IGZyb20gXCJAL2xpYi9ldlwiO1xuICogXG4gKiAvLyBEZS12aWcgc2hhcnAgb2Rkc1xuICogY29uc3Qgc2hhcnBPdmVyID0gLTExMDtcbiAqIGNvbnN0IHNoYXJwVW5kZXIgPSAtMTEwO1xuICogY29uc3QgZGV2aWdSZXN1bHQgPSBkZXZpZ1Bvd2VyKHNoYXJwT3Zlciwgc2hhcnBVbmRlcik7XG4gKiBcbiAqIC8vIENhbGN1bGF0ZSBFViBmb3IgYSBzb2Z0IGJvb2sgb2ZmZXJcbiAqIGNvbnN0IGV2ID0gY2FsY3VsYXRlRVYoZGV2aWdSZXN1bHQuZmFpclByb2JPdmVyLCArMTA1KTtcbiAqIGNvbnNvbGUubG9nKGBFVjogJHsoZXYgKiAxMDApLnRvRml4ZWQoMSl9JWApOyAvLyBcIkVWOiAyLjUlXCJcbiAqIGBgYFxuICovXG5cbi8vIFR5cGVzXG5leHBvcnQgdHlwZSB7XG4gIERldmlnTWV0aG9kLFxuICBEZXZpZ1Jlc3VsdCxcbiAgTXVsdGlEZXZpZ1Jlc3VsdCxcbiAgU2hhcnBQcmVzZXQsXG4gIFNoYXJwUHJlc2V0Q29uZmlnLFxuICBTaGFycFJlZmVyZW5jZSxcbiAgQm9va09mZmVyLFxuICBCb29rUGFpcmVkT2RkcyxcbiAgRVZDYWxjdWxhdGlvbixcbiAgTXVsdGlFVkNhbGN1bGF0aW9uLFxuICBQb3NpdGl2ZUVWT3Bwb3J0dW5pdHksXG4gIFBvc2l0aXZlRVZSZXF1ZXN0LFxuICBQb3NpdGl2ZUVWUmVzcG9uc2UsXG4gIFBvc2l0aXZlRVZNb2RlbCxcbiAgRVZNb2RlLFxuICBDdXN0b21TaGFycENvbmZpZyxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLy8gQ29uc3RhbnRzXG5leHBvcnQge1xuICBTSEFSUF9CT09LUyxcbiAgU09GVF9CT09LUyxcbiAgU0hBUlBfUFJFU0VUUyxcbiAgREVWSUdfTUVUSE9EUyxcbiAgREVGQVVMVF9ERVZJR19NRVRIT0RTLFxuICBBTExfREVWSUdfTUVUSE9EUyxcbiAgUE9TSVRJVkVfRVZfREVGQVVMVFMsXG4gIEVWX1RIUkVTSE9MRFMsXG4gIFNVUFBPUlRFRF9TUE9SVFMsXG4gIFRXT19XQVlfTUFSS0VUUyxcbiAgTk9OX1RXT19XQVlfTUFSS0VUUyxcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8vIE9kZHMgY29udmVyc2lvbiBmdW5jdGlvbnNcbmV4cG9ydCB7XG4gIGFtZXJpY2FuVG9JbXBsaWVkUHJvYixcbiAgYW1lcmljYW5Ub0RlY2ltYWwsXG4gIGRlY2ltYWxUb0FtZXJpY2FuLFxuICBpbXBsaWVkUHJvYlRvQW1lcmljYW4sXG4gIGltcGxpZWRQcm9iVG9EZWNpbWFsLFxufSBmcm9tIFwiLi9kZXZpZ1wiO1xuXG4vLyBNYXJnaW4gY2FsY3VsYXRpb25cbmV4cG9ydCB7XG4gIGNhbGN1bGF0ZU1hcmdpbixcbiAgY2FsY3VsYXRlTWFyZ2luRnJvbU9kZHMsXG59IGZyb20gXCIuL2RldmlnXCI7XG5cbi8vIERlLXZpZyBtZXRob2RzXG5leHBvcnQge1xuICBkZXZpZ011bHRpcGxpY2F0aXZlLFxuICBkZXZpZ0FkZGl0aXZlLFxuICBkZXZpZ1Bvd2VyLFxuICBkZXZpZ1Byb2JpdCxcbiAgZGV2aWdNdWx0aXBsZSxcbn0gZnJvbSBcIi4vZGV2aWdcIjtcblxuLy8gRVYgY2FsY3VsYXRpb25cbmV4cG9ydCB7XG4gIGNhbGN1bGF0ZUVWLFxuICBjYWxjdWxhdGVLZWxseSxcbiAgY2FsY3VsYXRlRVZEZXRhaWxzLFxuICBjYWxjdWxhdGVNdWx0aUVWLFxufSBmcm9tIFwiLi9kZXZpZ1wiO1xuXG4vLyBTaGFycCByZWZlcmVuY2UgaGVscGVyc1xuZXhwb3J0IHtcbiAgYmxlbmRTaGFycE9kZHMsXG4gIGNyZWF0ZVNoYXJwUmVmZXJlbmNlLFxufSBmcm9tIFwiLi9kZXZpZ1wiO1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uc1xuZXhwb3J0IHtcbiAgaXNQb3NpdGl2ZUVWLFxuICBmb3JtYXRFVixcbiAgZm9ybWF0S2VsbHksXG4gIGdldEtlbGx5U3Rha2UsXG59IGZyb20gXCIuL2RldmlnXCI7XG4iXSwibmFtZXMiOlsiU0hBUlBfQk9PS1MiLCJTT0ZUX0JPT0tTIiwiU0hBUlBfUFJFU0VUUyIsIkRFVklHX01FVEhPRFMiLCJERUZBVUxUX0RFVklHX01FVEhPRFMiLCJBTExfREVWSUdfTUVUSE9EUyIsIlBPU0lUSVZFX0VWX0RFRkFVTFRTIiwiRVZfVEhSRVNIT0xEUyIsIlNVUFBPUlRFRF9TUE9SVFMiLCJUV09fV0FZX01BUktFVFMiLCJOT05fVFdPX1dBWV9NQVJLRVRTIiwiYW1lcmljYW5Ub0ltcGxpZWRQcm9iIiwiYW1lcmljYW5Ub0RlY2ltYWwiLCJkZWNpbWFsVG9BbWVyaWNhbiIsImltcGxpZWRQcm9iVG9BbWVyaWNhbiIsImltcGxpZWRQcm9iVG9EZWNpbWFsIiwiY2FsY3VsYXRlTWFyZ2luIiwiY2FsY3VsYXRlTWFyZ2luRnJvbU9kZHMiLCJkZXZpZ011bHRpcGxpY2F0aXZlIiwiZGV2aWdBZGRpdGl2ZSIsImRldmlnUG93ZXIiLCJkZXZpZ1Byb2JpdCIsImRldmlnTXVsdGlwbGUiLCJjYWxjdWxhdGVFViIsImNhbGN1bGF0ZUtlbGx5IiwiY2FsY3VsYXRlRVZEZXRhaWxzIiwiY2FsY3VsYXRlTXVsdGlFViIsImJsZW5kU2hhcnBPZGRzIiwiY3JlYXRlU2hhcnBSZWZlcmVuY2UiLCJpc1Bvc2l0aXZlRVYiLCJmb3JtYXRFViIsImZvcm1hdEtlbGx5IiwiZ2V0S2VsbHlTdGFrZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/ev/index.ts\n");

/***/ }),

/***/ "(rsc)/./lib/odds/types.ts":
/*!***************************!*\
  !*** ./lib/odds/types.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SSE_MARKETS: () => (/* binding */ SSE_MARKETS),\n/* harmony export */   buildSelectionKey: () => (/* binding */ buildSelectionKey),\n/* harmony export */   calculateEdge: () => (/* binding */ calculateEdge),\n/* harmony export */   decimalToAmerican: () => (/* binding */ decimalToAmerican),\n/* harmony export */   getActiveEventsKey: () => (/* binding */ getActiveEventsKey),\n/* harmony export */   getBookOddsKey: () => (/* binding */ getBookOddsKey),\n/* harmony export */   getEventKey: () => (/* binding */ getEventKey),\n/* harmony export */   getMarketDisplay: () => (/* binding */ getMarketDisplay),\n/* harmony export */   getMarketDisplayShort: () => (/* binding */ getMarketDisplayShort),\n/* harmony export */   getMarketOddsPattern: () => (/* binding */ getMarketOddsPattern),\n/* harmony export */   impliedProbability: () => (/* binding */ impliedProbability),\n/* harmony export */   normalizePlayerName: () => (/* binding */ normalizePlayerName),\n/* harmony export */   normalizeRawMarket: () => (/* binding */ normalizeRawMarket),\n/* harmony export */   parseAmericanOdds: () => (/* binding */ parseAmericanOdds)\n/* harmony export */ });\n/**\n * SSE Odds Types\n * \n * Types and utilities for the SSE-powered odds system.\n * These match the Redis key structure from the SSE consumer.\n */ // =============================================================================\n// MARKET CONSTANTS\n// =============================================================================\n/**\n * Canonical market keys - use these everywhere for consistency.\n * Maps to display names for UI.\n */ const SSE_MARKETS = {\n    // Player Props - Core\n    player_points: \"Points\",\n    player_rebounds: \"Rebounds\",\n    player_assists: \"Assists\",\n    player_threes_made: \"3-Pointers\",\n    player_steals: \"Steals\",\n    player_blocks: \"Blocks\",\n    player_turnovers: \"Turnovers\",\n    // Player Props - Combos\n    player_pra: \"PRA\",\n    player_points_rebounds_assists: \"PRA\",\n    player_pr: \"PTS+REB\",\n    player_points_rebounds: \"P+R\",\n    player_pa: \"PTS+AST\",\n    player_points_assists: \"P+A\",\n    player_ra: \"REB+AST\",\n    player_rebounds_assists: \"R+A\",\n    player_bs: \"BLK+STL\",\n    player_blocks_steals: \"B+S\",\n    // Player Props - Special\n    player_double_double: \"Double Double\",\n    player_fantasy: \"Fantasy Points\",\n    // First Basket Markets (NBA)\n    first_field_goal: \"First Basket\",\n    team_first_basket: \"First Basket (Team)\",\n    home_team_first_field_goal: \"First Basket (Home)\",\n    away_team_first_field_goal: \"First Basket (Away)\",\n    // Game Markets\n    game_spread: \"Point Spread\",\n    game_total: \"Game Total\",\n    game_moneyline: \"Moneyline\",\n    team_total: \"Team Total\"\n};\n/**\n * Normalize raw market display names to consistent labels.\n * This handles cases where different sportsbooks send different names for the same market.\n */ const RAW_MARKET_ALIASES = {\n    // First Basket variations - all should display as \"First Basket\"\n    \"First Field Goal\": \"First Basket\",\n    \"First Basket\": \"First Basket\",\n    \"First Basket Scorer\": \"First Basket\",\n    \"1st Basket\": \"First Basket\",\n    \"1st Field Goal\": \"First Basket\",\n    \"Team First Basket\": \"First Basket (Team)\",\n    \"Team First Field Goal\": \"First Basket (Team)\",\n    \"Home Team First Basket\": \"First Basket (Home)\",\n    \"Home Team First Field Goal\": \"First Basket (Home)\",\n    \"Away Team First Basket\": \"First Basket (Away)\",\n    \"Away Team First Field Goal\": \"First Basket (Away)\",\n    // 1Q Points variations\n    \"1st Quarter Points\": \"1Q Points\",\n    \"1Q Points\": \"1Q Points\",\n    \"First Quarter Points\": \"1Q Points\"\n};\n/**\n * Normalize a raw market name to a consistent display name.\n * Used when setting marketDisplay from SSE data.\n */ function normalizeRawMarket(rawMarket) {\n    return RAW_MARKET_ALIASES[rawMarket] || rawMarket;\n}\n/**\n * Get display name for a market key\n */ function getMarketDisplay(market) {\n    return SSE_MARKETS[market] || market.replace(/_/g, \" \").replace(/player /i, \"\");\n}\n/**\n * Get short display name for a market key (for compact UI)\n */ function getMarketDisplayShort(market) {\n    const shortNames = {\n        player_points: \"PTS\",\n        player_rebounds: \"REB\",\n        player_assists: \"AST\",\n        player_threes_made: \"3PM\",\n        player_steals: \"STL\",\n        player_blocks: \"BLK\",\n        player_turnovers: \"TO\",\n        player_pra: \"PRA\",\n        player_pr: \"P+R\",\n        player_pa: \"P+A\",\n        player_ra: \"R+A\",\n        player_bs: \"B+S\",\n        player_double_double: \"DD\",\n        player_fantasy: \"FAN\",\n        game_spread: \"SPR\",\n        game_total: \"TOT\",\n        game_moneyline: \"ML\",\n        team_total: \"TT\"\n    };\n    return shortNames[market] || market.slice(0, 3).toUpperCase();\n}\n// =============================================================================\n// PLAYER NAME NORMALIZATION\n// =============================================================================\n/**\n * Normalize player name to match Redis selection key format.\n * MUST match SSE consumer's normalization exactly.\n * \n * Rules:\n * 1. Lowercase\n * 2. Spaces  underscores\n * 3. Remove periods (.)\n * 4. Remove apostrophes (')\n * 5. Hyphens  underscores\n * \n * @example\n * normalizePlayerName(\"LeBron James\") //  \"lebron_james\"\n * normalizePlayerName(\"De'Aaron Fox\") //  \"deaaron_fox\"\n * normalizePlayerName(\"P.J. Washington\") //  \"pj_washington\"\n * normalizePlayerName(\"Karl-Anthony Towns\") //  \"karl_anthony_towns\"\n */ function normalizePlayerName(name) {\n    return name.toLowerCase().replace(/ /g, \"_\").replace(/\\./g, \"\").replace(/'/g, \"\").replace(/-/g, \"_\");\n}\n/**\n * Build a selection key from player name, side, and line.\n * \n * @example\n * buildSelectionKey(\"LeBron James\", \"over\", 25.5) //  \"lebron_james|over|25.5\"\n */ function buildSelectionKey(playerName, side, line) {\n    return `${normalizePlayerName(playerName)}|${side}|${line}`;\n}\n// =============================================================================\n// REDIS KEY HELPERS\n// =============================================================================\n/**\n * Build Redis key for active events SET\n */ function getActiveEventsKey(sport) {\n    return `active_events:${sport}`;\n}\n/**\n * Build Redis key for event metadata\n */ function getEventKey(sport, eventId) {\n    return `events:${sport}:${eventId}`;\n}\n/**\n * Build Redis key pattern for all books in a market\n */ function getMarketOddsPattern(sport, eventId, market) {\n    return `odds:${sport}:${eventId}:${market}:*`;\n}\n/**\n * Build Redis key for specific book's odds\n */ function getBookOddsKey(sport, eventId, market, book) {\n    return `odds:${sport}:${eventId}:${market}:${book}`;\n}\n// =============================================================================\n// ODDS UTILITIES\n// =============================================================================\n/**\n * Parse American odds string to number\n */ function parseAmericanOdds(odds) {\n    return parseInt(odds.replace(\"+\", \"\"), 10);\n}\n/**\n * Format decimal odds to American odds string\n */ function decimalToAmerican(decimal) {\n    if (decimal >= 2) {\n        const american = Math.round((decimal - 1) * 100);\n        return `+${american}`;\n    } else {\n        const american = Math.round(-100 / (decimal - 1));\n        return `${american}`;\n    }\n}\n/**\n * Calculate implied probability from decimal odds\n */ function impliedProbability(decimal) {\n    return 1 / decimal;\n}\n/**\n * Calculate edge between two decimal odds\n */ function calculateEdge(best, comparison) {\n    const edge = best - comparison;\n    const edgePct = (best / comparison - 1) * 100;\n    return {\n        edge,\n        edgePct\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU1FLFVBQVUsQ0FBQyxPQUFRRixhQUFjLEtBQUs7SUFDNUMsT0FBTztRQUFFQztRQUFNQztJQUFRO0FBQ3pCIiwic291cmNlcyI6WyIvVXNlcnMvZHJld21hc2Nob2ZmL2Rldi91bmp1aWNlZC9hcHBzL3dlYi9saWIvb2Rkcy90eXBlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNTRSBPZGRzIFR5cGVzXG4gKiBcbiAqIFR5cGVzIGFuZCB1dGlsaXRpZXMgZm9yIHRoZSBTU0UtcG93ZXJlZCBvZGRzIHN5c3RlbS5cbiAqIFRoZXNlIG1hdGNoIHRoZSBSZWRpcyBrZXkgc3RydWN0dXJlIGZyb20gdGhlIFNTRSBjb25zdW1lci5cbiAqL1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTUFSS0VUIENPTlNUQU5UU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBDYW5vbmljYWwgbWFya2V0IGtleXMgLSB1c2UgdGhlc2UgZXZlcnl3aGVyZSBmb3IgY29uc2lzdGVuY3kuXG4gKiBNYXBzIHRvIGRpc3BsYXkgbmFtZXMgZm9yIFVJLlxuICovXG5leHBvcnQgY29uc3QgU1NFX01BUktFVFMgPSB7XG4gIC8vIFBsYXllciBQcm9wcyAtIENvcmVcbiAgcGxheWVyX3BvaW50czogXCJQb2ludHNcIixcbiAgcGxheWVyX3JlYm91bmRzOiBcIlJlYm91bmRzXCIsXG4gIHBsYXllcl9hc3Npc3RzOiBcIkFzc2lzdHNcIixcbiAgcGxheWVyX3RocmVlc19tYWRlOiBcIjMtUG9pbnRlcnNcIiwgLy8gTm90ZTogX21hZGUgc3VmZml4XG4gIHBsYXllcl9zdGVhbHM6IFwiU3RlYWxzXCIsXG4gIHBsYXllcl9ibG9ja3M6IFwiQmxvY2tzXCIsXG4gIHBsYXllcl90dXJub3ZlcnM6IFwiVHVybm92ZXJzXCIsXG4gIFxuICAvLyBQbGF5ZXIgUHJvcHMgLSBDb21ib3NcbiAgcGxheWVyX3ByYTogXCJQUkFcIixcbiAgcGxheWVyX3BvaW50c19yZWJvdW5kc19hc3Npc3RzOiBcIlBSQVwiLFxuICBwbGF5ZXJfcHI6IFwiUFRTK1JFQlwiLFxuICBwbGF5ZXJfcG9pbnRzX3JlYm91bmRzOiBcIlArUlwiLFxuICBwbGF5ZXJfcGE6IFwiUFRTK0FTVFwiLFxuICBwbGF5ZXJfcG9pbnRzX2Fzc2lzdHM6IFwiUCtBXCIsXG4gIHBsYXllcl9yYTogXCJSRUIrQVNUXCIsXG4gIHBsYXllcl9yZWJvdW5kc19hc3Npc3RzOiBcIlIrQVwiLFxuICBwbGF5ZXJfYnM6IFwiQkxLK1NUTFwiLFxuICBwbGF5ZXJfYmxvY2tzX3N0ZWFsczogXCJCK1NcIixcbiAgXG4gIC8vIFBsYXllciBQcm9wcyAtIFNwZWNpYWxcbiAgcGxheWVyX2RvdWJsZV9kb3VibGU6IFwiRG91YmxlIERvdWJsZVwiLFxuICBwbGF5ZXJfZmFudGFzeTogXCJGYW50YXN5IFBvaW50c1wiLFxuICBcbiAgLy8gRmlyc3QgQmFza2V0IE1hcmtldHMgKE5CQSlcbiAgZmlyc3RfZmllbGRfZ29hbDogXCJGaXJzdCBCYXNrZXRcIixcbiAgdGVhbV9maXJzdF9iYXNrZXQ6IFwiRmlyc3QgQmFza2V0IChUZWFtKVwiLFxuICBob21lX3RlYW1fZmlyc3RfZmllbGRfZ29hbDogXCJGaXJzdCBCYXNrZXQgKEhvbWUpXCIsXG4gIGF3YXlfdGVhbV9maXJzdF9maWVsZF9nb2FsOiBcIkZpcnN0IEJhc2tldCAoQXdheSlcIixcbiAgXG4gIC8vIEdhbWUgTWFya2V0c1xuICBnYW1lX3NwcmVhZDogXCJQb2ludCBTcHJlYWRcIixcbiAgZ2FtZV90b3RhbDogXCJHYW1lIFRvdGFsXCIsXG4gIGdhbWVfbW9uZXlsaW5lOiBcIk1vbmV5bGluZVwiLFxuICB0ZWFtX3RvdGFsOiBcIlRlYW0gVG90YWxcIixcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIFNTRU1hcmtldEtleSA9IGtleW9mIHR5cGVvZiBTU0VfTUFSS0VUUztcblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IG1hcmtldCBkaXNwbGF5IG5hbWVzIHRvIGNvbnNpc3RlbnQgbGFiZWxzLlxuICogVGhpcyBoYW5kbGVzIGNhc2VzIHdoZXJlIGRpZmZlcmVudCBzcG9ydHNib29rcyBzZW5kIGRpZmZlcmVudCBuYW1lcyBmb3IgdGhlIHNhbWUgbWFya2V0LlxuICovXG5jb25zdCBSQVdfTUFSS0VUX0FMSUFTRVM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gIC8vIEZpcnN0IEJhc2tldCB2YXJpYXRpb25zIC0gYWxsIHNob3VsZCBkaXNwbGF5IGFzIFwiRmlyc3QgQmFza2V0XCJcbiAgXCJGaXJzdCBGaWVsZCBHb2FsXCI6IFwiRmlyc3QgQmFza2V0XCIsXG4gIFwiRmlyc3QgQmFza2V0XCI6IFwiRmlyc3QgQmFza2V0XCIsXG4gIFwiRmlyc3QgQmFza2V0IFNjb3JlclwiOiBcIkZpcnN0IEJhc2tldFwiLFxuICBcIjFzdCBCYXNrZXRcIjogXCJGaXJzdCBCYXNrZXRcIixcbiAgXCIxc3QgRmllbGQgR29hbFwiOiBcIkZpcnN0IEJhc2tldFwiLFxuICBcIlRlYW0gRmlyc3QgQmFza2V0XCI6IFwiRmlyc3QgQmFza2V0IChUZWFtKVwiLFxuICBcIlRlYW0gRmlyc3QgRmllbGQgR29hbFwiOiBcIkZpcnN0IEJhc2tldCAoVGVhbSlcIixcbiAgXCJIb21lIFRlYW0gRmlyc3QgQmFza2V0XCI6IFwiRmlyc3QgQmFza2V0IChIb21lKVwiLFxuICBcIkhvbWUgVGVhbSBGaXJzdCBGaWVsZCBHb2FsXCI6IFwiRmlyc3QgQmFza2V0IChIb21lKVwiLFxuICBcIkF3YXkgVGVhbSBGaXJzdCBCYXNrZXRcIjogXCJGaXJzdCBCYXNrZXQgKEF3YXkpXCIsIFxuICBcIkF3YXkgVGVhbSBGaXJzdCBGaWVsZCBHb2FsXCI6IFwiRmlyc3QgQmFza2V0IChBd2F5KVwiLFxuICAvLyAxUSBQb2ludHMgdmFyaWF0aW9uc1xuICBcIjFzdCBRdWFydGVyIFBvaW50c1wiOiBcIjFRIFBvaW50c1wiLFxuICBcIjFRIFBvaW50c1wiOiBcIjFRIFBvaW50c1wiLFxuICBcIkZpcnN0IFF1YXJ0ZXIgUG9pbnRzXCI6IFwiMVEgUG9pbnRzXCIsXG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHJhdyBtYXJrZXQgbmFtZSB0byBhIGNvbnNpc3RlbnQgZGlzcGxheSBuYW1lLlxuICogVXNlZCB3aGVuIHNldHRpbmcgbWFya2V0RGlzcGxheSBmcm9tIFNTRSBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUmF3TWFya2V0KHJhd01hcmtldDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIFJBV19NQVJLRVRfQUxJQVNFU1tyYXdNYXJrZXRdIHx8IHJhd01hcmtldDtcbn1cblxuLyoqXG4gKiBHZXQgZGlzcGxheSBuYW1lIGZvciBhIG1hcmtldCBrZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtldERpc3BsYXkobWFya2V0OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gU1NFX01BUktFVFNbbWFya2V0IGFzIFNTRU1hcmtldEtleV0gfHwgbWFya2V0LnJlcGxhY2UoL18vZywgXCIgXCIpLnJlcGxhY2UoL3BsYXllciAvaSwgXCJcIik7XG59XG5cbi8qKlxuICogR2V0IHNob3J0IGRpc3BsYXkgbmFtZSBmb3IgYSBtYXJrZXQga2V5IChmb3IgY29tcGFjdCBVSSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1hcmtldERpc3BsYXlTaG9ydChtYXJrZXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHNob3J0TmFtZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgcGxheWVyX3BvaW50czogXCJQVFNcIixcbiAgICBwbGF5ZXJfcmVib3VuZHM6IFwiUkVCXCIsXG4gICAgcGxheWVyX2Fzc2lzdHM6IFwiQVNUXCIsXG4gICAgcGxheWVyX3RocmVlc19tYWRlOiBcIjNQTVwiLFxuICAgIHBsYXllcl9zdGVhbHM6IFwiU1RMXCIsXG4gICAgcGxheWVyX2Jsb2NrczogXCJCTEtcIixcbiAgICBwbGF5ZXJfdHVybm92ZXJzOiBcIlRPXCIsXG4gICAgcGxheWVyX3ByYTogXCJQUkFcIixcbiAgICBwbGF5ZXJfcHI6IFwiUCtSXCIsXG4gICAgcGxheWVyX3BhOiBcIlArQVwiLFxuICAgIHBsYXllcl9yYTogXCJSK0FcIixcbiAgICBwbGF5ZXJfYnM6IFwiQitTXCIsXG4gICAgcGxheWVyX2RvdWJsZV9kb3VibGU6IFwiRERcIixcbiAgICBwbGF5ZXJfZmFudGFzeTogXCJGQU5cIixcbiAgICBnYW1lX3NwcmVhZDogXCJTUFJcIixcbiAgICBnYW1lX3RvdGFsOiBcIlRPVFwiLFxuICAgIGdhbWVfbW9uZXlsaW5lOiBcIk1MXCIsXG4gICAgdGVhbV90b3RhbDogXCJUVFwiLFxuICB9O1xuICByZXR1cm4gc2hvcnROYW1lc1ttYXJrZXRdIHx8IG1hcmtldC5zbGljZSgwLCAzKS50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUExBWUVSIE5BTUUgTk9STUFMSVpBVElPTlxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBOb3JtYWxpemUgcGxheWVyIG5hbWUgdG8gbWF0Y2ggUmVkaXMgc2VsZWN0aW9uIGtleSBmb3JtYXQuXG4gKiBNVVNUIG1hdGNoIFNTRSBjb25zdW1lcidzIG5vcm1hbGl6YXRpb24gZXhhY3RseS5cbiAqIFxuICogUnVsZXM6XG4gKiAxLiBMb3dlcmNhc2VcbiAqIDIuIFNwYWNlcyDihpIgdW5kZXJzY29yZXNcbiAqIDMuIFJlbW92ZSBwZXJpb2RzICguKVxuICogNC4gUmVtb3ZlIGFwb3N0cm9waGVzICgnKVxuICogNS4gSHlwaGVucyDihpIgdW5kZXJzY29yZXNcbiAqIFxuICogQGV4YW1wbGVcbiAqIG5vcm1hbGl6ZVBsYXllck5hbWUoXCJMZUJyb24gSmFtZXNcIikgLy8g4oaSIFwibGVicm9uX2phbWVzXCJcbiAqIG5vcm1hbGl6ZVBsYXllck5hbWUoXCJEZSdBYXJvbiBGb3hcIikgLy8g4oaSIFwiZGVhYXJvbl9mb3hcIlxuICogbm9ybWFsaXplUGxheWVyTmFtZShcIlAuSi4gV2FzaGluZ3RvblwiKSAvLyDihpIgXCJwal93YXNoaW5ndG9uXCJcbiAqIG5vcm1hbGl6ZVBsYXllck5hbWUoXCJLYXJsLUFudGhvbnkgVG93bnNcIikgLy8g4oaSIFwia2FybF9hbnRob255X3Rvd25zXCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVBsYXllck5hbWUobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5hbWVcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC5yZXBsYWNlKC8gL2csIFwiX1wiKVxuICAgIC5yZXBsYWNlKC9cXC4vZywgXCJcIilcbiAgICAucmVwbGFjZSgvJy9nLCBcIlwiKVxuICAgIC5yZXBsYWNlKC8tL2csIFwiX1wiKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHNlbGVjdGlvbiBrZXkgZnJvbSBwbGF5ZXIgbmFtZSwgc2lkZSwgYW5kIGxpbmUuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBidWlsZFNlbGVjdGlvbktleShcIkxlQnJvbiBKYW1lc1wiLCBcIm92ZXJcIiwgMjUuNSkgLy8g4oaSIFwibGVicm9uX2phbWVzfG92ZXJ8MjUuNVwiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlbGVjdGlvbktleShcbiAgcGxheWVyTmFtZTogc3RyaW5nLFxuICBzaWRlOiBcIm92ZXJcIiB8IFwidW5kZXJcIiB8IFwibWxcIiB8IFwic3ByZWFkXCIsXG4gIGxpbmU6IG51bWJlclxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke25vcm1hbGl6ZVBsYXllck5hbWUocGxheWVyTmFtZSl9fCR7c2lkZX18JHtsaW5lfWA7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBSRURJUyBLRVkgSEVMUEVSU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBCdWlsZCBSZWRpcyBrZXkgZm9yIGFjdGl2ZSBldmVudHMgU0VUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3RpdmVFdmVudHNLZXkoc3BvcnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgYWN0aXZlX2V2ZW50czoke3Nwb3J0fWA7XG59XG5cbi8qKlxuICogQnVpbGQgUmVkaXMga2V5IGZvciBldmVudCBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRLZXkoc3BvcnQ6IHN0cmluZywgZXZlbnRJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBldmVudHM6JHtzcG9ydH06JHtldmVudElkfWA7XG59XG5cbi8qKlxuICogQnVpbGQgUmVkaXMga2V5IHBhdHRlcm4gZm9yIGFsbCBib29rcyBpbiBhIG1hcmtldFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFya2V0T2Rkc1BhdHRlcm4oc3BvcnQ6IHN0cmluZywgZXZlbnRJZDogc3RyaW5nLCBtYXJrZXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgb2Rkczoke3Nwb3J0fToke2V2ZW50SWR9OiR7bWFya2V0fToqYDtcbn1cblxuLyoqXG4gKiBCdWlsZCBSZWRpcyBrZXkgZm9yIHNwZWNpZmljIGJvb2sncyBvZGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCb29rT2Rkc0tleShzcG9ydDogc3RyaW5nLCBldmVudElkOiBzdHJpbmcsIG1hcmtldDogc3RyaW5nLCBib29rOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gYG9kZHM6JHtzcG9ydH06JHtldmVudElkfToke21hcmtldH06JHtib29rfWA7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEQVRBIFRZUEVTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEV2ZW50IG1ldGFkYXRhIGZyb20gUmVkaXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTU0VFdmVudCB7XG4gIGV2ZW50X2lkOiBzdHJpbmc7XG4gIGlzX2xpdmU6IGJvb2xlYW47XG4gIGNvbW1lbmNlX3RpbWU6IHN0cmluZztcbiAgaG9tZV90ZWFtX2lkOiBzdHJpbmc7XG4gIGhvbWVfdGVhbTogc3RyaW5nO1xuICBob21lX3RlYW1fbmFtZTogc3RyaW5nO1xuICBhd2F5X3RlYW1faWQ6IHN0cmluZztcbiAgYXdheV90ZWFtOiBzdHJpbmc7XG4gIGF3YXlfdGVhbV9uYW1lOiBzdHJpbmc7XG4gIHVwZGF0ZWQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBJbmRpdmlkdWFsIHNlbGVjdGlvbiAocGxheWVyL2xpbmUvc2lkZSkgZnJvbSBSZWRpc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNTRVNlbGVjdGlvbiB7XG4gIHBsYXllcjogc3RyaW5nO1xuICBwbGF5ZXJfaWQ6IHN0cmluZztcbiAgamVyc2V5X251bWJlcjogc3RyaW5nO1xuICBwb3NpdGlvbjogc3RyaW5nO1xuICB0ZWFtOiBzdHJpbmc7XG4gIHRlYW1fbmFtZTogc3RyaW5nO1xuICBzaWRlOiBcIm92ZXJcIiB8IFwidW5kZXJcIiB8IFwibWxcIiB8IFwic3ByZWFkXCI7XG4gIGxpbmU6IG51bWJlcjtcbiAgcHJpY2U6IHN0cmluZzsgLy8gQW1lcmljYW4gb2RkcyBhcyBzdHJpbmcsIGUuZy4sIFwiLTExNVwiLCBcIisxMjBcIlxuICBwcmljZV9kZWNpbWFsOiBudW1iZXI7XG4gIG1haW46IGJvb2xlYW47XG4gIGxvY2tlZDogYm9vbGVhbjtcbiAgbGluazogc3RyaW5nO1xuICBtb2JpbGVfbGluaz86IHN0cmluZyB8IG51bGw7ICAvLyBEZWVwIGxpbmsgZm9yIG1vYmlsZSBhcHBzIChlLmcuLCBmYW5kdWVsc3BvcnRzYm9vazovLy4uLilcbiAgc2dwOiBzdHJpbmcgfCBudWxsO1xuICBsaW1pdHM6IHsgbWF4OiBudW1iZXIgfSB8IG51bGw7ICAvLyBCZXR0aW5nIGxpbWl0cyAobWF4IHdhZ2VyKSB3aGVuIGF2YWlsYWJsZVxuICByYXdfbWFya2V0OiBzdHJpbmc7XG4gIHVwZGF0ZWQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBbGwgc2VsZWN0aW9ucyBmb3IgYSBib29rIChrZXllZCBieSBzZWxlY3Rpb24ga2V5KVxuICovXG5leHBvcnQgdHlwZSBTU0VCb29rU2VsZWN0aW9ucyA9IFJlY29yZDxzdHJpbmcsIFNTRVNlbGVjdGlvbj47XG5cbi8qKlxuICogQWxsIGJvb2tzIGZvciBhIG1hcmtldFxuICovXG5leHBvcnQgdHlwZSBTU0VNYXJrZXRPZGRzID0gUmVjb3JkPHN0cmluZywgU1NFQm9va1NlbGVjdGlvbnM+O1xuXG4vKipcbiAqIEJvb2sgcHJpY2UgaW5mbyBmb3IgZWRnZSBjYWxjdWxhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJvb2tQcmljZSB7XG4gIGJvb2s6IHN0cmluZztcbiAgcHJpY2U6IHN0cmluZztcbiAgZGVjaW1hbDogbnVtYmVyO1xuICBsaW5rOiBzdHJpbmc7XG4gIHNncDogc3RyaW5nIHwgbnVsbDtcbiAgc2VsZWN0aW9uOiBTU0VTZWxlY3Rpb247XG59XG5cbi8qKlxuICogRWRnZSBjYWxjdWxhdGlvbiByZXN1bHQgZm9yIGEgc2luZ2xlIHNlbGVjdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVkZ2VSZXN1bHQge1xuICAvLyBFdmVudCBpbmZvXG4gIGV2ZW50X2lkOiBzdHJpbmc7XG4gIGhvbWVfdGVhbTogc3RyaW5nO1xuICBhd2F5X3RlYW06IHN0cmluZztcbiAgY29tbWVuY2VfdGltZTogc3RyaW5nO1xuICBpc19saXZlOiBib29sZWFuO1xuICBcbiAgLy8gU2VsZWN0aW9uIGluZm9cbiAgcGxheWVyOiBzdHJpbmc7XG4gIHBsYXllcl9pZDogc3RyaW5nO1xuICB0ZWFtOiBzdHJpbmc7XG4gIG1hcmtldDogc3RyaW5nO1xuICBtYXJrZXRfZGlzcGxheTogc3RyaW5nO1xuICBsaW5lOiBudW1iZXI7XG4gIHNpZGU6IFwib3ZlclwiIHwgXCJ1bmRlclwiIHwgXCJtbFwiIHwgXCJzcHJlYWRcIjtcbiAgXG4gIC8vIEJlc3Qgb2Rkc1xuICBiZXN0X2Jvb2s6IHN0cmluZztcbiAgYmVzdF9wcmljZTogc3RyaW5nO1xuICBiZXN0X2RlY2ltYWw6IG51bWJlcjtcbiAgYmVzdF9saW5rOiBzdHJpbmc7XG4gIGJlc3Rfc2dwOiBzdHJpbmcgfCBudWxsO1xuICBcbiAgLy8gQ29tcGFyaXNvblxuICBwaW5uYWNsZV9wcmljZTogc3RyaW5nIHwgbnVsbDtcbiAgcGlubmFjbGVfZGVjaW1hbDogbnVtYmVyIHwgbnVsbDtcbiAgY2lyY2FfcHJpY2U6IHN0cmluZyB8IG51bGw7XG4gIGNpcmNhX2RlY2ltYWw6IG51bWJlciB8IG51bGw7XG4gIGF2ZXJhZ2VfZGVjaW1hbDogbnVtYmVyO1xuICBcbiAgLy8gRWRnZSBjYWxjdWxhdGlvbnNcbiAgZWRnZV92c19waW5uYWNsZTogbnVtYmVyIHwgbnVsbDsgLy8gRGVjaW1hbCBkaWZmZXJlbmNlXG4gIGVkZ2VfdnNfcGlubmFjbGVfcGN0OiBudW1iZXIgfCBudWxsOyAvLyBQZXJjZW50YWdlXG4gIGVkZ2VfdnNfYXZlcmFnZTogbnVtYmVyO1xuICBlZGdlX3ZzX2F2ZXJhZ2VfcGN0OiBudW1iZXI7XG4gIFxuICAvLyBBbGwgYm9va3MgZm9yIHRoaXMgc2VsZWN0aW9uXG4gIGFsbF9ib29rczogQXJyYXk8e1xuICAgIGJvb2s6IHN0cmluZztcbiAgICBwcmljZTogc3RyaW5nO1xuICAgIGRlY2ltYWw6IG51bWJlcjtcbiAgICBsaW5rOiBzdHJpbmc7XG4gIH0+O1xufVxuXG4vKipcbiAqIEVkZ2UgZmluZGVyIEFQSSByZXNwb25zZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVkZ2VGaW5kZXJSZXNwb25zZSB7XG4gIGVkZ2VzOiBFZGdlUmVzdWx0W107XG4gIGNvdW50OiBudW1iZXI7XG4gIHRvdGFsX2ZvdW5kOiBudW1iZXI7XG4gIG1hcmtldDogc3RyaW5nO1xuICBjb21wYXJlX2Jvb2s6IHN0cmluZztcbiAgbWluX2VkZ2U6IG51bWJlcjtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE9ERFMgVVRJTElUSUVTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIFBhcnNlIEFtZXJpY2FuIG9kZHMgc3RyaW5nIHRvIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBbWVyaWNhbk9kZHMob2Rkczogc3RyaW5nKTogbnVtYmVyIHtcbiAgcmV0dXJuIHBhcnNlSW50KG9kZHMucmVwbGFjZShcIitcIiwgXCJcIiksIDEwKTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgZGVjaW1hbCBvZGRzIHRvIEFtZXJpY2FuIG9kZHMgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNpbWFsVG9BbWVyaWNhbihkZWNpbWFsOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoZGVjaW1hbCA+PSAyKSB7XG4gICAgY29uc3QgYW1lcmljYW4gPSBNYXRoLnJvdW5kKChkZWNpbWFsIC0gMSkgKiAxMDApO1xuICAgIHJldHVybiBgKyR7YW1lcmljYW59YDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBhbWVyaWNhbiA9IE1hdGgucm91bmQoLTEwMCAvIChkZWNpbWFsIC0gMSkpO1xuICAgIHJldHVybiBgJHthbWVyaWNhbn1gO1xuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGltcGxpZWQgcHJvYmFiaWxpdHkgZnJvbSBkZWNpbWFsIG9kZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGltcGxpZWRQcm9iYWJpbGl0eShkZWNpbWFsOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gMSAvIGRlY2ltYWw7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIGVkZ2UgYmV0d2VlbiB0d28gZGVjaW1hbCBvZGRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVFZGdlKGJlc3Q6IG51bWJlciwgY29tcGFyaXNvbjogbnVtYmVyKToge1xuICBlZGdlOiBudW1iZXI7XG4gIGVkZ2VQY3Q6IG51bWJlcjtcbn0ge1xuICBjb25zdCBlZGdlID0gYmVzdCAtIGNvbXBhcmlzb247XG4gIGNvbnN0IGVkZ2VQY3QgPSAoKGJlc3QgLyBjb21wYXJpc29uKSAtIDEpICogMTAwO1xuICByZXR1cm4geyBlZGdlLCBlZGdlUGN0IH07XG59XG5cbiJdLCJuYW1lcyI6WyJTU0VfTUFSS0VUUyIsInBsYXllcl9wb2ludHMiLCJwbGF5ZXJfcmVib3VuZHMiLCJwbGF5ZXJfYXNzaXN0cyIsInBsYXllcl90aHJlZXNfbWFkZSIsInBsYXllcl9zdGVhbHMiLCJwbGF5ZXJfYmxvY2tzIiwicGxheWVyX3R1cm5vdmVycyIsInBsYXllcl9wcmEiLCJwbGF5ZXJfcG9pbnRzX3JlYm91bmRzX2Fzc2lzdHMiLCJwbGF5ZXJfcHIiLCJwbGF5ZXJfcG9pbnRzX3JlYm91bmRzIiwicGxheWVyX3BhIiwicGxheWVyX3BvaW50c19hc3Npc3RzIiwicGxheWVyX3JhIiwicGxheWVyX3JlYm91bmRzX2Fzc2lzdHMiLCJwbGF5ZXJfYnMiLCJwbGF5ZXJfYmxvY2tzX3N0ZWFscyIsInBsYXllcl9kb3VibGVfZG91YmxlIiwicGxheWVyX2ZhbnRhc3kiLCJmaXJzdF9maWVsZF9nb2FsIiwidGVhbV9maXJzdF9iYXNrZXQiLCJob21lX3RlYW1fZmlyc3RfZmllbGRfZ29hbCIsImF3YXlfdGVhbV9maXJzdF9maWVsZF9nb2FsIiwiZ2FtZV9zcHJlYWQiLCJnYW1lX3RvdGFsIiwiZ2FtZV9tb25leWxpbmUiLCJ0ZWFtX3RvdGFsIiwiUkFXX01BUktFVF9BTElBU0VTIiwibm9ybWFsaXplUmF3TWFya2V0IiwicmF3TWFya2V0IiwiZ2V0TWFya2V0RGlzcGxheSIsIm1hcmtldCIsInJlcGxhY2UiLCJnZXRNYXJrZXREaXNwbGF5U2hvcnQiLCJzaG9ydE5hbWVzIiwic2xpY2UiLCJ0b1VwcGVyQ2FzZSIsIm5vcm1hbGl6ZVBsYXllck5hbWUiLCJuYW1lIiwidG9Mb3dlckNhc2UiLCJidWlsZFNlbGVjdGlvbktleSIsInBsYXllck5hbWUiLCJzaWRlIiwibGluZSIsImdldEFjdGl2ZUV2ZW50c0tleSIsInNwb3J0IiwiZ2V0RXZlbnRLZXkiLCJldmVudElkIiwiZ2V0TWFya2V0T2Rkc1BhdHRlcm4iLCJnZXRCb29rT2Rkc0tleSIsImJvb2siLCJwYXJzZUFtZXJpY2FuT2RkcyIsIm9kZHMiLCJwYXJzZUludCIsImRlY2ltYWxUb0FtZXJpY2FuIiwiZGVjaW1hbCIsImFtZXJpY2FuIiwiTWF0aCIsInJvdW5kIiwiaW1wbGllZFByb2JhYmlsaXR5IiwiY2FsY3VsYXRlRWRnZSIsImJlc3QiLCJjb21wYXJpc29uIiwiZWRnZSIsImVkZ2VQY3QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/odds/types.ts\n");

/***/ }),

/***/ "(rsc)/./lib/plans-server.ts":
/*!*****************************!*\
  !*** ./lib/plans-server.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUserPlan: () => (/* binding */ getUserPlan)\n/* harmony export */ });\n/* harmony import */ var _libs_supabase_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/libs/supabase/server */ \"(rsc)/./libs/supabase/server.ts\");\n/* harmony import */ var _plans__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plans */ \"(rsc)/./lib/plans.ts\");\n\n\n/**\n * Get user's plan tier using the v_user_entitlements view\n * This accounts for both active subscriptions AND active trials\n * \n * NOTE: This is a server-only function. Use getClientUserPlan for client components.\n */ async function getUserPlan(user) {\n    if (!user) {\n        return \"anonymous\";\n    }\n    try {\n        const supabase = await (0,_libs_supabase_server__WEBPACK_IMPORTED_MODULE_0__.createClient)();\n        // Use current_entitlements view to get effective plan\n        const { data: entitlement, error } = await supabase.from(\"current_entitlements\").select(\"current_plan\").eq(\"user_id\", user.id).single();\n        if (error || !entitlement) {\n            console.error(\"Error fetching user entitlement:\", error);\n            return \"free\"; // Default to free if entitlement not found\n        }\n        const normalized = (0,_plans__WEBPACK_IMPORTED_MODULE_1__.normalizePlanName)(String(entitlement.current_plan || \"free\"));\n        if (normalized in _plans__WEBPACK_IMPORTED_MODULE_1__.PLAN_LIMITS) {\n            return normalized;\n        }\n        console.warn(\"Unknown plan in entitlements:\", entitlement.current_plan);\n        return \"free\";\n    } catch (error) {\n        console.error(\"Error in getUserPlan:\", error);\n        return \"free\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvcGxhbnMtc2VydmVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUNzRDtBQUNrQjtBQUV4RTs7Ozs7Q0FLQyxHQUNNLGVBQWVHLFlBQVlDLElBQWlCO0lBQ2pELElBQUksQ0FBQ0EsTUFBTTtRQUNULE9BQU87SUFDVDtJQUVBLElBQUk7UUFDRixNQUFNQyxXQUFXLE1BQU1MLG1FQUFZQTtRQUVuQyxzREFBc0Q7UUFDdEQsTUFBTSxFQUFFTSxNQUFNQyxXQUFXLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1ILFNBQ3hDSSxJQUFJLENBQUMsd0JBQ0xDLE1BQU0sQ0FBQyxnQkFDUEMsRUFBRSxDQUFDLFdBQVdQLEtBQUtRLEVBQUUsRUFDckJDLE1BQU07UUFFVCxJQUFJTCxTQUFTLENBQUNELGFBQWE7WUFDekJPLFFBQVFOLEtBQUssQ0FBQyxvQ0FBb0NBO1lBQ2xELE9BQU8sUUFBUSwyQ0FBMkM7UUFDNUQ7UUFFQSxNQUFNTyxhQUFhYix5REFBaUJBLENBQUNjLE9BQU9ULFlBQVlVLFlBQVksSUFBSTtRQUN4RSxJQUFJRixjQUFjZCwrQ0FBV0EsRUFBRTtZQUM3QixPQUFPYztRQUNUO1FBQ0FELFFBQVFJLElBQUksQ0FBQyxpQ0FBaUNYLFlBQVlVLFlBQVk7UUFDdEUsT0FBTztJQUNULEVBQUUsT0FBT1QsT0FBTztRQUNkTSxRQUFRTixLQUFLLENBQUMseUJBQXlCQTtRQUN2QyxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL2RyZXdtYXNjaG9mZi9kZXYvdW5qdWljZWQvYXBwcy93ZWIvbGliL3BsYW5zLXNlcnZlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBVc2VyIH0gZnJvbSBcIkBzdXBhYmFzZS9zdXBhYmFzZS1qc1wiO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSBcIkAvbGlicy9zdXBhYmFzZS9zZXJ2ZXJcIjtcbmltcG9ydCB7IFBMQU5fTElNSVRTLCBub3JtYWxpemVQbGFuTmFtZSwgdHlwZSBVc2VyUGxhbiB9IGZyb20gXCIuL3BsYW5zXCI7XG5cbi8qKlxuICogR2V0IHVzZXIncyBwbGFuIHRpZXIgdXNpbmcgdGhlIHZfdXNlcl9lbnRpdGxlbWVudHMgdmlld1xuICogVGhpcyBhY2NvdW50cyBmb3IgYm90aCBhY3RpdmUgc3Vic2NyaXB0aW9ucyBBTkQgYWN0aXZlIHRyaWFsc1xuICogXG4gKiBOT1RFOiBUaGlzIGlzIGEgc2VydmVyLW9ubHkgZnVuY3Rpb24uIFVzZSBnZXRDbGllbnRVc2VyUGxhbiBmb3IgY2xpZW50IGNvbXBvbmVudHMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyUGxhbih1c2VyOiBVc2VyIHwgbnVsbCk6IFByb21pc2U8VXNlclBsYW4+IHtcbiAgaWYgKCF1c2VyKSB7XG4gICAgcmV0dXJuIFwiYW5vbnltb3VzXCI7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHN1cGFiYXNlID0gYXdhaXQgY3JlYXRlQ2xpZW50KCk7XG4gICAgXG4gICAgLy8gVXNlIGN1cnJlbnRfZW50aXRsZW1lbnRzIHZpZXcgdG8gZ2V0IGVmZmVjdGl2ZSBwbGFuXG4gICAgY29uc3QgeyBkYXRhOiBlbnRpdGxlbWVudCwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbShcImN1cnJlbnRfZW50aXRsZW1lbnRzXCIpXG4gICAgICAuc2VsZWN0KFwiY3VycmVudF9wbGFuXCIpXG4gICAgICAuZXEoXCJ1c2VyX2lkXCIsIHVzZXIuaWQpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IgfHwgIWVudGl0bGVtZW50KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdXNlciBlbnRpdGxlbWVudDpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIFwiZnJlZVwiOyAvLyBEZWZhdWx0IHRvIGZyZWUgaWYgZW50aXRsZW1lbnQgbm90IGZvdW5kXG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZVBsYW5OYW1lKFN0cmluZyhlbnRpdGxlbWVudC5jdXJyZW50X3BsYW4gfHwgXCJmcmVlXCIpKTtcbiAgICBpZiAobm9ybWFsaXplZCBpbiBQTEFOX0xJTUlUUykge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQgYXMgVXNlclBsYW47XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihcIlVua25vd24gcGxhbiBpbiBlbnRpdGxlbWVudHM6XCIsIGVudGl0bGVtZW50LmN1cnJlbnRfcGxhbik7XG4gICAgcmV0dXJuIFwiZnJlZVwiO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBnZXRVc2VyUGxhbjpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBcImZyZWVcIjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsIlBMQU5fTElNSVRTIiwibm9ybWFsaXplUGxhbk5hbWUiLCJnZXRVc2VyUGxhbiIsInVzZXIiLCJzdXBhYmFzZSIsImRhdGEiLCJlbnRpdGxlbWVudCIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwiaWQiLCJzaW5nbGUiLCJjb25zb2xlIiwibm9ybWFsaXplZCIsIlN0cmluZyIsImN1cnJlbnRfcGxhbiIsIndhcm4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/plans-server.ts\n");

/***/ }),

/***/ "(rsc)/./lib/plans.ts":
/*!**********************!*\
  !*** ./lib/plans.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PLAN_LIMITS: () => (/* binding */ PLAN_LIMITS),\n/* harmony export */   canAccessFeature: () => (/* binding */ canAccessFeature),\n/* harmony export */   exceedsLimit: () => (/* binding */ exceedsLimit),\n/* harmony export */   getClientUserPlan: () => (/* binding */ getClientUserPlan),\n/* harmony export */   getFeatureLimits: () => (/* binding */ getFeatureLimits),\n/* harmony export */   getUpgradeMessage: () => (/* binding */ getUpgradeMessage),\n/* harmony export */   hasEdgeAccess: () => (/* binding */ hasEdgeAccess),\n/* harmony export */   hasEliteAccess: () => (/* binding */ hasEliteAccess),\n/* harmony export */   hasHitRateAccess: () => (/* binding */ hasHitRateAccess),\n/* harmony export */   hasProAccess: () => (/* binding */ hasProAccess),\n/* harmony export */   hasSharpAccess: () => (/* binding */ hasSharpAccess),\n/* harmony export */   normalizePlanName: () => (/* binding */ normalizePlanName)\n/* harmony export */ });\n/**\n * Map legacy plan names to new plan names.\n * Early adopters get bumped up one tier as a loyalty reward:\n *   hit_rate  sharp  (was scout-level, now gets sharp tools)\n *   pro       elite  (was sharp-level, now gets full elite access)\n *   edge      elite  (consolidated into elite tier)\n */ function normalizePlanName(plan) {\n    if (plan === \"hit_rate\") return \"sharp\"; // Legacy hit_rate  sharp (bumped up)\n    if (plan === \"pro\") return \"elite\"; // Legacy pro  elite (bumped up)\n    if (plan === \"admin\") return \"elite\"; // Admins get full access\n    if (plan === \"edge\") return \"elite\"; // Edge consolidated into elite\n    return plan;\n}\n/**\n * Feature access limits by plan\n */ const PLAN_LIMITS = {\n    anonymous: {\n        arbitrage: {\n            maxResults: 100,\n            refreshRate: 60000,\n            canFilter: false,\n            canExport: false,\n            hasLiveArb: false\n        },\n        odds: {\n            maxLeagues: 1,\n            refreshRate: 30000,\n            canCompare: false\n        },\n        positiveEV: {\n            maxResults: 0,\n            refreshRate: 0,\n            hasCustomModels: false\n        },\n        hitRates: {\n            hasAccess: false,\n            hasEVSignals: false\n        }\n    },\n    free: {\n        arbitrage: {\n            maxResults: 100,\n            refreshRate: 10000,\n            canFilter: true,\n            canExport: false,\n            hasLiveArb: false\n        },\n        odds: {\n            maxLeagues: 3,\n            refreshRate: 5000,\n            canCompare: true\n        },\n        positiveEV: {\n            maxResults: 10,\n            refreshRate: 30000,\n            hasCustomModels: false\n        },\n        hitRates: {\n            hasAccess: false,\n            hasEVSignals: false\n        }\n    },\n    scout: {\n        arbitrage: {\n            maxResults: 100,\n            refreshRate: 10000,\n            canFilter: true,\n            canExport: false,\n            hasLiveArb: false\n        },\n        odds: {\n            maxLeagues: 3,\n            refreshRate: 5000,\n            canCompare: true\n        },\n        positiveEV: {\n            maxResults: 10,\n            refreshRate: 30000,\n            hasCustomModels: false\n        },\n        hitRates: {\n            hasAccess: true,\n            hasEVSignals: false\n        }\n    },\n    sharp: {\n        arbitrage: {\n            maxResults: -1,\n            refreshRate: 2000,\n            canFilter: true,\n            canExport: true,\n            hasLiveArb: false\n        },\n        odds: {\n            maxLeagues: -1,\n            refreshRate: 2000,\n            canCompare: true\n        },\n        positiveEV: {\n            maxResults: -1,\n            refreshRate: 5000,\n            hasCustomModels: false\n        },\n        hitRates: {\n            hasAccess: true,\n            hasEVSignals: false\n        }\n    },\n    elite: {\n        arbitrage: {\n            maxResults: -1,\n            refreshRate: 2000,\n            canFilter: true,\n            canExport: true,\n            hasLiveArb: true\n        },\n        odds: {\n            maxLeagues: -1,\n            refreshRate: 2000,\n            canCompare: true\n        },\n        positiveEV: {\n            maxResults: -1,\n            refreshRate: 5000,\n            hasCustomModels: true\n        },\n        hitRates: {\n            hasAccess: true,\n            hasEVSignals: true\n        }\n    }\n};\n/**\n * Check if a plan has access to Hit Rates\n */ function hasHitRateAccess(plan) {\n    return plan === \"scout\" || plan === \"sharp\" || plan === \"elite\";\n}\n/**\n * Check if a plan has access to sharp tools (EV, Arb, Edge Finder)\n */ function hasSharpAccess(plan) {\n    return plan === \"sharp\" || plan === \"elite\";\n}\n/**\n * Check if a plan has access to Elite features (live arb, custom models, EV signals)\n */ function hasEliteAccess(plan) {\n    return plan === \"elite\";\n}\n/** @deprecated Use hasEliteAccess instead */ function hasEdgeAccess(plan) {\n    return hasEliteAccess(plan);\n}\n/**\n * Check if a plan has full Sharp features (arb, EV, etc.)\n * @deprecated Use hasSharpAccess or hasEliteAccess instead\n */ function hasProAccess(plan) {\n    return plan === \"sharp\" || plan === \"elite\";\n}\n/**\n * Client-side: Get user's plan from profile (requires user object with profile data)\n */ function getClientUserPlan(user) {\n    if (!user) {\n        return \"anonymous\";\n    }\n    // Check user metadata for plan (you can store it there or fetch from DB)\n    const raw = user.user_metadata?.plan;\n    const normalized = normalizePlanName(raw || \"free\");\n    return normalized in PLAN_LIMITS ? normalized : \"free\";\n}\n/**\n * Check if user can access a feature\n */ function canAccessFeature(plan, feature) {\n    const limits = PLAN_LIMITS[plan][feature];\n    // Check if feature is accessible at all\n    if (\"maxResults\" in limits) {\n        return limits.maxResults !== 0;\n    }\n    return true;\n}\n/**\n * Get feature limits for a specific plan and feature\n */ function getFeatureLimits(plan, feature) {\n    return PLAN_LIMITS[plan][feature];\n}\n/**\n * Check if result count exceeds plan limit\n */ function exceedsLimit(plan, feature, count) {\n    const limits = PLAN_LIMITS[plan][feature];\n    if (\"maxResults\" in limits) {\n        const maxResults = limits.maxResults;\n        // -1 means unlimited\n        if (maxResults === -1) return false;\n        return count > maxResults;\n    }\n    return false;\n}\n/**\n * Get upgrade message for a feature\n */ function getUpgradeMessage(plan, feature) {\n    if (plan === \"anonymous\") {\n        return `Sign up for a free account to unlock more ${feature} opportunities!`;\n    }\n    if (plan === \"free\") {\n        return `Upgrade to Scout for hit rate research or Sharp for full betting tools!`;\n    }\n    if (plan === \"scout\") {\n        return `Upgrade to Sharp for unlimited ${feature} access with EV and arbitrage tools!`;\n    }\n    if (plan === \"sharp\") {\n        return `Upgrade to Elite for live arbitrage, custom models, and EV-enhanced hit rates!`;\n    }\n    return \"\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TyxDQUFDLHVFQUF1RSxDQUFDO0lBQ2xGO0lBRUEsSUFBSUEsU0FBUyxTQUFTO1FBQ3BCLE9BQU8sQ0FBQywrQkFBK0IsRUFBRWdDLFFBQVEsb0NBQW9DLENBQUM7SUFDeEY7SUFFQSxJQUFJaEMsU0FBUyxTQUFTO1FBQ3BCLE9BQU8sQ0FBQyw4RUFBOEUsQ0FBQztJQUN6RjtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL2RyZXdtYXNjaG9mZi9kZXYvdW5qdWljZWQvYXBwcy93ZWIvbGliL3BsYW5zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFVzZXIgfSBmcm9tIFwiQHN1cGFiYXNlL3N1cGFiYXNlLWpzXCI7XG5cbi8qKlxuICogVXNlciBwbGFuIHRpZXJzXG4gKiAtIGFub255bW91czogTm90IGxvZ2dlZCBpblxuICogLSBmcmVlOiBMb2dnZWQgaW4sIG5vIHN1YnNjcmlwdGlvblxuICogLSBzY291dDogJDE1L21vIC0gSGl0IHJhdGUgcmVzZWFyY2ggdG9vbHNcbiAqIC0gc2hhcnA6ICQzNS9tbyAtIEhpdCByYXRlcyArIEVWL0FyYiB0b29scyAobm8gbGl2ZSBhcmIsIG5vIGN1c3RvbSBtb2RlbHMpXG4gKiAtIGVsaXRlOiBGdWxsIGFjY2VzcyAtIGxpdmUgYXJiLCBjdXN0b20gbW9kZWxzLCBwcmlvcml0eSBzdXBwb3J0XG4gKi9cbmV4cG9ydCB0eXBlIFVzZXJQbGFuID0gXCJhbm9ueW1vdXNcIiB8IFwiZnJlZVwiIHwgXCJzY291dFwiIHwgXCJzaGFycFwiIHwgXCJlbGl0ZVwiO1xuXG4vKipcbiAqIExlZ2FjeSBwbGFuIHR5cGUgYWxpYXNlcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICogQGRlcHJlY2F0ZWQgVXNlIFVzZXJQbGFuIGluc3RlYWRcbiAqL1xuZXhwb3J0IHR5cGUgTGVnYWN5VXNlclBsYW4gPSBcImhpdF9yYXRlXCIgfCBcInByb1wiO1xuXG4vKipcbiAqIE1hcCBsZWdhY3kgcGxhbiBuYW1lcyB0byBuZXcgcGxhbiBuYW1lcy5cbiAqIEVhcmx5IGFkb3B0ZXJzIGdldCBidW1wZWQgdXAgb25lIHRpZXIgYXMgYSBsb3lhbHR5IHJld2FyZDpcbiAqICAgaGl0X3JhdGUg4oaSIHNoYXJwICAod2FzIHNjb3V0LWxldmVsLCBub3cgZ2V0cyBzaGFycCB0b29scylcbiAqICAgcHJvICAgICAg4oaSIGVsaXRlICAod2FzIHNoYXJwLWxldmVsLCBub3cgZ2V0cyBmdWxsIGVsaXRlIGFjY2VzcylcbiAqICAgZWRnZSAgICAg4oaSIGVsaXRlICAoY29uc29saWRhdGVkIGludG8gZWxpdGUgdGllcilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVBsYW5OYW1lKHBsYW46IHN0cmluZyk6IFVzZXJQbGFuIHtcbiAgaWYgKHBsYW4gPT09IFwiaGl0X3JhdGVcIikgcmV0dXJuIFwic2hhcnBcIjsgLy8gTGVnYWN5IGhpdF9yYXRlIOKGkiBzaGFycCAoYnVtcGVkIHVwKVxuICBpZiAocGxhbiA9PT0gXCJwcm9cIikgcmV0dXJuIFwiZWxpdGVcIjsgICAgICAvLyBMZWdhY3kgcHJvIOKGkiBlbGl0ZSAoYnVtcGVkIHVwKVxuICBpZiAocGxhbiA9PT0gXCJhZG1pblwiKSByZXR1cm4gXCJlbGl0ZVwiOyAgICAvLyBBZG1pbnMgZ2V0IGZ1bGwgYWNjZXNzXG4gIGlmIChwbGFuID09PSBcImVkZ2VcIikgcmV0dXJuIFwiZWxpdGVcIjsgICAgIC8vIEVkZ2UgY29uc29saWRhdGVkIGludG8gZWxpdGVcbiAgcmV0dXJuIHBsYW4gYXMgVXNlclBsYW47XG59XG5cbi8qKlxuICogRmVhdHVyZSBhY2Nlc3MgbGltaXRzIGJ5IHBsYW5cbiAqL1xuZXhwb3J0IGNvbnN0IFBMQU5fTElNSVRTID0ge1xuICBhbm9ueW1vdXM6IHtcbiAgICBhcmJpdHJhZ2U6IHtcbiAgICAgIG1heFJlc3VsdHM6IDEwMCwgLy8gTGltaXRlZCBwcmV2aWV3XG4gICAgICByZWZyZXNoUmF0ZTogNjAwMDAsIC8vIDYwIHNlY29uZHNcbiAgICAgIGNhbkZpbHRlcjogZmFsc2UsXG4gICAgICBjYW5FeHBvcnQ6IGZhbHNlLFxuICAgICAgaGFzTGl2ZUFyYjogZmFsc2UsXG4gICAgfSxcbiAgICBvZGRzOiB7XG4gICAgICBtYXhMZWFndWVzOiAxLFxuICAgICAgcmVmcmVzaFJhdGU6IDMwMDAwLFxuICAgICAgY2FuQ29tcGFyZTogZmFsc2UsXG4gICAgfSxcbiAgICBwb3NpdGl2ZUVWOiB7XG4gICAgICBtYXhSZXN1bHRzOiAwLCAvLyBObyBhY2Nlc3NcbiAgICAgIHJlZnJlc2hSYXRlOiAwLFxuICAgICAgaGFzQ3VzdG9tTW9kZWxzOiBmYWxzZSxcbiAgICB9LFxuICAgIGhpdFJhdGVzOiB7XG4gICAgICBoYXNBY2Nlc3M6IGZhbHNlLFxuICAgICAgaGFzRVZTaWduYWxzOiBmYWxzZSxcbiAgICB9LFxuICB9LFxuICBmcmVlOiB7XG4gICAgYXJiaXRyYWdlOiB7XG4gICAgICBtYXhSZXN1bHRzOiAxMDAsIC8vIExpbWl0ZWQgcHJldmlld1xuICAgICAgcmVmcmVzaFJhdGU6IDEwMDAwLCAvLyAxMCBzZWNvbmRzXG4gICAgICBjYW5GaWx0ZXI6IHRydWUsXG4gICAgICBjYW5FeHBvcnQ6IGZhbHNlLFxuICAgICAgaGFzTGl2ZUFyYjogZmFsc2UsXG4gICAgfSxcbiAgICBvZGRzOiB7XG4gICAgICBtYXhMZWFndWVzOiAzLFxuICAgICAgcmVmcmVzaFJhdGU6IDUwMDAsXG4gICAgICBjYW5Db21wYXJlOiB0cnVlLFxuICAgIH0sXG4gICAgcG9zaXRpdmVFVjoge1xuICAgICAgbWF4UmVzdWx0czogMTAsXG4gICAgICByZWZyZXNoUmF0ZTogMzAwMDAsXG4gICAgICBoYXNDdXN0b21Nb2RlbHM6IGZhbHNlLFxuICAgIH0sXG4gICAgaGl0UmF0ZXM6IHtcbiAgICAgIGhhc0FjY2VzczogZmFsc2UsXG4gICAgICBoYXNFVlNpZ25hbHM6IGZhbHNlLFxuICAgIH0sXG4gIH0sXG4gIHNjb3V0OiB7XG4gICAgYXJiaXRyYWdlOiB7XG4gICAgICBtYXhSZXN1bHRzOiAxMDAsIC8vIFNhbWUgYXMgZnJlZSAtIG5vIGFyYiBhY2Nlc3NcbiAgICAgIHJlZnJlc2hSYXRlOiAxMDAwMCxcbiAgICAgIGNhbkZpbHRlcjogdHJ1ZSxcbiAgICAgIGNhbkV4cG9ydDogZmFsc2UsXG4gICAgICBoYXNMaXZlQXJiOiBmYWxzZSxcbiAgICB9LFxuICAgIG9kZHM6IHtcbiAgICAgIG1heExlYWd1ZXM6IDMsIC8vIFNhbWUgYXMgZnJlZSAtIGxpbWl0ZWQgb2RkcyBhY2Nlc3NcbiAgICAgIHJlZnJlc2hSYXRlOiA1MDAwLFxuICAgICAgY2FuQ29tcGFyZTogdHJ1ZSxcbiAgICB9LFxuICAgIHBvc2l0aXZlRVY6IHtcbiAgICAgIG1heFJlc3VsdHM6IDEwLCAvLyBTYW1lIGFzIGZyZWUgLSBsaW1pdGVkIEVWIGFjY2Vzc1xuICAgICAgcmVmcmVzaFJhdGU6IDMwMDAwLFxuICAgICAgaGFzQ3VzdG9tTW9kZWxzOiBmYWxzZSxcbiAgICB9LFxuICAgIGhpdFJhdGVzOiB7XG4gICAgICBoYXNBY2Nlc3M6IHRydWUsIC8vIEZ1bGwgSGl0IFJhdGVzIGFjY2Vzc1xuICAgICAgaGFzRVZTaWduYWxzOiBmYWxzZSxcbiAgICB9LFxuICB9LFxuICBzaGFycDoge1xuICAgIGFyYml0cmFnZToge1xuICAgICAgbWF4UmVzdWx0czogLTEsIC8vIFVubGltaXRlZFxuICAgICAgcmVmcmVzaFJhdGU6IDIwMDAsIC8vIDIgc2Vjb25kc1xuICAgICAgY2FuRmlsdGVyOiB0cnVlLFxuICAgICAgY2FuRXhwb3J0OiB0cnVlLFxuICAgICAgaGFzTGl2ZUFyYjogZmFsc2UsIC8vIE5vIGxpdmUgYXJiIGZvciBTaGFycFxuICAgIH0sXG4gICAgb2Rkczoge1xuICAgICAgbWF4TGVhZ3VlczogLTEsIC8vIFVubGltaXRlZFxuICAgICAgcmVmcmVzaFJhdGU6IDIwMDAsXG4gICAgICBjYW5Db21wYXJlOiB0cnVlLFxuICAgIH0sXG4gICAgcG9zaXRpdmVFVjoge1xuICAgICAgbWF4UmVzdWx0czogLTEsIC8vIFVubGltaXRlZFxuICAgICAgcmVmcmVzaFJhdGU6IDUwMDAsXG4gICAgICBoYXNDdXN0b21Nb2RlbHM6IGZhbHNlLCAvLyBObyBjdXN0b20gbW9kZWxzIGZvciBTaGFycFxuICAgIH0sXG4gICAgaGl0UmF0ZXM6IHtcbiAgICAgIGhhc0FjY2VzczogdHJ1ZSxcbiAgICAgIGhhc0VWU2lnbmFsczogZmFsc2UsXG4gICAgfSxcbiAgfSxcbiAgZWxpdGU6IHtcbiAgICBhcmJpdHJhZ2U6IHtcbiAgICAgIG1heFJlc3VsdHM6IC0xLCAvLyBVbmxpbWl0ZWRcbiAgICAgIHJlZnJlc2hSYXRlOiAyMDAwLCAvLyAyIHNlY29uZHNcbiAgICAgIGNhbkZpbHRlcjogdHJ1ZSxcbiAgICAgIGNhbkV4cG9ydDogdHJ1ZSxcbiAgICAgIGhhc0xpdmVBcmI6IHRydWUsIC8vIEZ1bGwgYWNjZXNzXG4gICAgfSxcbiAgICBvZGRzOiB7XG4gICAgICBtYXhMZWFndWVzOiAtMSwgLy8gVW5saW1pdGVkXG4gICAgICByZWZyZXNoUmF0ZTogMjAwMCxcbiAgICAgIGNhbkNvbXBhcmU6IHRydWUsXG4gICAgfSxcbiAgICBwb3NpdGl2ZUVWOiB7XG4gICAgICBtYXhSZXN1bHRzOiAtMSwgLy8gVW5saW1pdGVkXG4gICAgICByZWZyZXNoUmF0ZTogNTAwMCxcbiAgICAgIGhhc0N1c3RvbU1vZGVsczogdHJ1ZSwgLy8gRnVsbCBhY2Nlc3NcbiAgICB9LFxuICAgIGhpdFJhdGVzOiB7XG4gICAgICBoYXNBY2Nlc3M6IHRydWUsXG4gICAgICBoYXNFVlNpZ25hbHM6IHRydWUsIC8vIEVWLWVuaGFuY2VkIGhpdCByYXRlc1xuICAgIH0sXG4gIH0sXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgcGxhbiBoYXMgYWNjZXNzIHRvIEhpdCBSYXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzSGl0UmF0ZUFjY2VzcyhwbGFuOiBVc2VyUGxhbik6IGJvb2xlYW4ge1xuICByZXR1cm4gcGxhbiA9PT0gXCJzY291dFwiIHx8IHBsYW4gPT09IFwic2hhcnBcIiB8fCBwbGFuID09PSBcImVsaXRlXCI7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwbGFuIGhhcyBhY2Nlc3MgdG8gc2hhcnAgdG9vbHMgKEVWLCBBcmIsIEVkZ2UgRmluZGVyKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzU2hhcnBBY2Nlc3MocGxhbjogVXNlclBsYW4pOiBib29sZWFuIHtcbiAgcmV0dXJuIHBsYW4gPT09IFwic2hhcnBcIiB8fCBwbGFuID09PSBcImVsaXRlXCI7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwbGFuIGhhcyBhY2Nlc3MgdG8gRWxpdGUgZmVhdHVyZXMgKGxpdmUgYXJiLCBjdXN0b20gbW9kZWxzLCBFViBzaWduYWxzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRWxpdGVBY2Nlc3MocGxhbjogVXNlclBsYW4pOiBib29sZWFuIHtcbiAgcmV0dXJuIHBsYW4gPT09IFwiZWxpdGVcIjtcbn1cblxuLyoqIEBkZXByZWNhdGVkIFVzZSBoYXNFbGl0ZUFjY2VzcyBpbnN0ZWFkICovXG5leHBvcnQgZnVuY3Rpb24gaGFzRWRnZUFjY2VzcyhwbGFuOiBVc2VyUGxhbik6IGJvb2xlYW4ge1xuICByZXR1cm4gaGFzRWxpdGVBY2Nlc3MocGxhbik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBwbGFuIGhhcyBmdWxsIFNoYXJwIGZlYXR1cmVzIChhcmIsIEVWLCBldGMuKVxuICogQGRlcHJlY2F0ZWQgVXNlIGhhc1NoYXJwQWNjZXNzIG9yIGhhc0VsaXRlQWNjZXNzIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc1Byb0FjY2VzcyhwbGFuOiBVc2VyUGxhbik6IGJvb2xlYW4ge1xuICByZXR1cm4gcGxhbiA9PT0gXCJzaGFycFwiIHx8IHBsYW4gPT09IFwiZWxpdGVcIjtcbn1cblxuLyoqXG4gKiBDbGllbnQtc2lkZTogR2V0IHVzZXIncyBwbGFuIGZyb20gcHJvZmlsZSAocmVxdWlyZXMgdXNlciBvYmplY3Qgd2l0aCBwcm9maWxlIGRhdGEpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRVc2VyUGxhbih1c2VyOiBVc2VyIHwgbnVsbCk6IFVzZXJQbGFuIHtcbiAgaWYgKCF1c2VyKSB7XG4gICAgcmV0dXJuIFwiYW5vbnltb3VzXCI7XG4gIH1cblxuICAvLyBDaGVjayB1c2VyIG1ldGFkYXRhIGZvciBwbGFuICh5b3UgY2FuIHN0b3JlIGl0IHRoZXJlIG9yIGZldGNoIGZyb20gREIpXG4gIGNvbnN0IHJhdyA9IHVzZXIudXNlcl9tZXRhZGF0YT8ucGxhbiBhcyBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVQbGFuTmFtZShyYXcgfHwgXCJmcmVlXCIpO1xuICByZXR1cm4gbm9ybWFsaXplZCBpbiBQTEFOX0xJTUlUUyA/IChub3JtYWxpemVkIGFzIFVzZXJQbGFuKSA6IFwiZnJlZVwiO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHVzZXIgY2FuIGFjY2VzcyBhIGZlYXR1cmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbkFjY2Vzc0ZlYXR1cmUoXG4gIHBsYW46IFVzZXJQbGFuLFxuICBmZWF0dXJlOiBrZXlvZiB0eXBlb2YgUExBTl9MSU1JVFMuYW5vbnltb3VzXG4pOiBib29sZWFuIHtcbiAgY29uc3QgbGltaXRzID0gUExBTl9MSU1JVFNbcGxhbl1bZmVhdHVyZV07XG4gIFxuICAvLyBDaGVjayBpZiBmZWF0dXJlIGlzIGFjY2Vzc2libGUgYXQgYWxsXG4gIGlmIChcIm1heFJlc3VsdHNcIiBpbiBsaW1pdHMpIHtcbiAgICByZXR1cm4gbGltaXRzLm1heFJlc3VsdHMgIT09IDA7XG4gIH1cbiAgXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldCBmZWF0dXJlIGxpbWl0cyBmb3IgYSBzcGVjaWZpYyBwbGFuIGFuZCBmZWF0dXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGZWF0dXJlTGltaXRzPFQgZXh0ZW5kcyBrZXlvZiB0eXBlb2YgUExBTl9MSU1JVFMuYW5vbnltb3VzPihcbiAgcGxhbjogVXNlclBsYW4sXG4gIGZlYXR1cmU6IFRcbik6ICh0eXBlb2YgUExBTl9MSU1JVFMpW1VzZXJQbGFuXVtUXSB7XG4gIHJldHVybiBQTEFOX0xJTUlUU1twbGFuXVtmZWF0dXJlXTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiByZXN1bHQgY291bnQgZXhjZWVkcyBwbGFuIGxpbWl0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGNlZWRzTGltaXQoXG4gIHBsYW46IFVzZXJQbGFuLFxuICBmZWF0dXJlOiBrZXlvZiB0eXBlb2YgUExBTl9MSU1JVFMuYW5vbnltb3VzLFxuICBjb3VudDogbnVtYmVyXG4pOiBib29sZWFuIHtcbiAgY29uc3QgbGltaXRzID0gUExBTl9MSU1JVFNbcGxhbl1bZmVhdHVyZV07XG4gIFxuICBpZiAoXCJtYXhSZXN1bHRzXCIgaW4gbGltaXRzKSB7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IGxpbWl0cy5tYXhSZXN1bHRzO1xuICAgIC8vIC0xIG1lYW5zIHVubGltaXRlZFxuICAgIGlmIChtYXhSZXN1bHRzID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBjb3VudCA+IG1heFJlc3VsdHM7XG4gIH1cbiAgXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgdXBncmFkZSBtZXNzYWdlIGZvciBhIGZlYXR1cmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVwZ3JhZGVNZXNzYWdlKHBsYW46IFVzZXJQbGFuLCBmZWF0dXJlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAocGxhbiA9PT0gXCJhbm9ueW1vdXNcIikge1xuICAgIHJldHVybiBgU2lnbiB1cCBmb3IgYSBmcmVlIGFjY291bnQgdG8gdW5sb2NrIG1vcmUgJHtmZWF0dXJlfSBvcHBvcnR1bml0aWVzIWA7XG4gIH1cblxuICBpZiAocGxhbiA9PT0gXCJmcmVlXCIpIHtcbiAgICByZXR1cm4gYFVwZ3JhZGUgdG8gU2NvdXQgZm9yIGhpdCByYXRlIHJlc2VhcmNoIG9yIFNoYXJwIGZvciBmdWxsIGJldHRpbmcgdG9vbHMhYDtcbiAgfVxuXG4gIGlmIChwbGFuID09PSBcInNjb3V0XCIpIHtcbiAgICByZXR1cm4gYFVwZ3JhZGUgdG8gU2hhcnAgZm9yIHVubGltaXRlZCAke2ZlYXR1cmV9IGFjY2VzcyB3aXRoIEVWIGFuZCBhcmJpdHJhZ2UgdG9vbHMhYDtcbiAgfVxuXG4gIGlmIChwbGFuID09PSBcInNoYXJwXCIpIHtcbiAgICByZXR1cm4gYFVwZ3JhZGUgdG8gRWxpdGUgZm9yIGxpdmUgYXJiaXRyYWdlLCBjdXN0b20gbW9kZWxzLCBhbmQgRVYtZW5oYW5jZWQgaGl0IHJhdGVzIWA7XG4gIH1cblxuICByZXR1cm4gXCJcIjtcbn1cbiJdLCJuYW1lcyI6WyJub3JtYWxpemVQbGFuTmFtZSIsInBsYW4iLCJQTEFOX0xJTUlUUyIsImFub255bW91cyIsImFyYml0cmFnZSIsIm1heFJlc3VsdHMiLCJyZWZyZXNoUmF0ZSIsImNhbkZpbHRlciIsImNhbkV4cG9ydCIsImhhc0xpdmVBcmIiLCJvZGRzIiwibWF4TGVhZ3VlcyIsImNhbkNvbXBhcmUiLCJwb3NpdGl2ZUVWIiwiaGFzQ3VzdG9tTW9kZWxzIiwiaGl0UmF0ZXMiLCJoYXNBY2Nlc3MiLCJoYXNFVlNpZ25hbHMiLCJmcmVlIiwic2NvdXQiLCJzaGFycCIsImVsaXRlIiwiaGFzSGl0UmF0ZUFjY2VzcyIsImhhc1NoYXJwQWNjZXNzIiwiaGFzRWxpdGVBY2Nlc3MiLCJoYXNFZGdlQWNjZXNzIiwiaGFzUHJvQWNjZXNzIiwiZ2V0Q2xpZW50VXNlclBsYW4iLCJ1c2VyIiwicmF3IiwidXNlcl9tZXRhZGF0YSIsIm5vcm1hbGl6ZWQiLCJjYW5BY2Nlc3NGZWF0dXJlIiwiZmVhdHVyZSIsImxpbWl0cyIsImdldEZlYXR1cmVMaW1pdHMiLCJleGNlZWRzTGltaXQiLCJjb3VudCIsImdldFVwZ3JhZGVNZXNzYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/plans.ts\n");

/***/ }),

/***/ "(rsc)/./libs/supabase/server.ts":
/*!*********************************!*\
  !*** ./libs/supabase/server.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_ssr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/ssr */ \"(rsc)/../../node_modules/@supabase/ssr/dist/module/index.js\");\n/* harmony import */ var next_headers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/headers */ \"(rsc)/../../node_modules/next/dist/api/headers.js\");\n\n\nasync function createClient() {\n    const cookieStore = await (0,next_headers__WEBPACK_IMPORTED_MODULE_1__.cookies)();\n    return (0,_supabase_ssr__WEBPACK_IMPORTED_MODULE_0__.createServerClient)(\"https://mcnbnrpaqretktdiglqd.supabase.co\", \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1jbmJucnBhcXJldGt0ZGlnbHFkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUyNjY0NDIsImV4cCI6MjA2MDg0MjQ0Mn0.p00Rdp73AiS8wlNtwSYnxBOJ-gIQkW7InuaWV-XaxfI\", {\n        cookies: {\n            getAll () {\n                return cookieStore.getAll();\n            },\n            setAll (cookiesToSet) {\n                try {\n                    cookiesToSet.forEach(({ name, value, options })=>cookieStore.set(name, value, options));\n                } catch  {\n                // The `setAll` method was called from a Server Component.\n                // This can be ignored if you have middleware refreshing\n                // user sessions.\n                }\n            }\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWJzL3N1cGFiYXNlL3NlcnZlci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUQ7QUFDWjtBQUVoQyxlQUFlRTtJQUNwQixNQUFNQyxjQUFjLE1BQU1GLHFEQUFPQTtJQUVqQyxPQUFPRCxpRUFBa0JBLENBQ3ZCSSwwQ0FBb0MsRUFDcENBLGtOQUF5QyxFQUN6QztRQUNFSCxTQUFTO1lBQ1BPO2dCQUNFLE9BQU9MLFlBQVlLLE1BQU07WUFDM0I7WUFDQUMsUUFBT0MsWUFBWTtnQkFDakIsSUFBSTtvQkFDRkEsYUFBYUMsT0FBTyxDQUFDLENBQUMsRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sRUFBRSxHQUM1Q1gsWUFBWVksR0FBRyxDQUFDSCxNQUFNQyxPQUFPQztnQkFFakMsRUFBRSxPQUFNO2dCQUNOLDBEQUEwRDtnQkFDMUQsd0RBQXdEO2dCQUN4RCxpQkFBaUI7Z0JBQ25CO1lBQ0Y7UUFDRjtJQUNGO0FBRUoiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kcmV3bWFzY2hvZmYvZGV2L3VuanVpY2VkL2FwcHMvd2ViL2xpYnMvc3VwYWJhc2Uvc2VydmVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVNlcnZlckNsaWVudCB9IGZyb20gXCJAc3VwYWJhc2Uvc3NyXCI7XG5pbXBvcnQgeyBjb29raWVzIH0gZnJvbSBcIm5leHQvaGVhZGVyc1wiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ2xpZW50KCkge1xuICBjb25zdCBjb29raWVTdG9yZSA9IGF3YWl0IGNvb2tpZXMoKTtcblxuICByZXR1cm4gY3JlYXRlU2VydmVyQ2xpZW50KFxuICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCEsXG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkhLFxuICAgIHtcbiAgICAgIGNvb2tpZXM6IHtcbiAgICAgICAgZ2V0QWxsKCkge1xuICAgICAgICAgIHJldHVybiBjb29raWVTdG9yZS5nZXRBbGwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0QWxsKGNvb2tpZXNUb1NldCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb29raWVzVG9TZXQuZm9yRWFjaCgoeyBuYW1lLCB2YWx1ZSwgb3B0aW9ucyB9KSA9PlxuICAgICAgICAgICAgICBjb29raWVTdG9yZS5zZXQobmFtZSwgdmFsdWUsIG9wdGlvbnMpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgLy8gVGhlIGBzZXRBbGxgIG1ldGhvZCB3YXMgY2FsbGVkIGZyb20gYSBTZXJ2ZXIgQ29tcG9uZW50LlxuICAgICAgICAgICAgLy8gVGhpcyBjYW4gYmUgaWdub3JlZCBpZiB5b3UgaGF2ZSBtaWRkbGV3YXJlIHJlZnJlc2hpbmdcbiAgICAgICAgICAgIC8vIHVzZXIgc2Vzc2lvbnMuXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG4gICk7XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlU2VydmVyQ2xpZW50IiwiY29va2llcyIsImNyZWF0ZUNsaWVudCIsImNvb2tpZVN0b3JlIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiZ2V0QWxsIiwic2V0QWxsIiwiY29va2llc1RvU2V0IiwiZm9yRWFjaCIsIm5hbWUiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJzZXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./libs/supabase/server.ts\n");

/***/ }),

/***/ "(ssr)/../../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \**********************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@opentelemetry","vendor-chunks/@supabase","vendor-chunks/tr46","vendor-chunks/@upstash","vendor-chunks/whatwg-url","vendor-chunks/webidl-conversions","vendor-chunks/uncrypto"], () => (__webpack_exec__("(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fv2%2Fpositive-ev%2Froute&page=%2Fapi%2Fv2%2Fpositive-ev%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fv2%2Fpositive-ev%2Froute.ts&appDir=%2FUsers%2Fdrewmaschoff%2Fdev%2Funjuiced%2Fapps%2Fweb%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fdrewmaschoff%2Fdev%2Funjuiced%2Fapps%2Fweb&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();